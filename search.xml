<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>const_iterator</title>
      <link href="/posts/39925.html"/>
      <url>/posts/39925.html</url>
      
        <content type="html"><![CDATA[<p><code>const_iterator</code>是STL提供的一个等同于<code>const</code>指针的东西，并且它所指向的值是不可变的。标准实践中，当你需要迭代器并且不需要更改迭代器指向的值的时候，你应该使用<code>const_iterator</code>，无论是在C++98，还是C++11，这个标准实践都是正确的，可是在C++98中是并不完全支持const_iterator。</p><h1 id="C-98里的const-iterator"><a href="#C-98里的const-iterator" class="headerlink" title="C++98里的const_iterator"></a>C++98里的const_iterator</h1><p>在C++98里，STL是有<code>const_iterator</code>类型的迭代器，但是没有办法创建一个<code>const_iterator</code>类型的迭代器。容器类只提供了<code>begin(),end()</code>等返回<code>iterator</code>的成员方法，<code>std::find</code>返回的也是非常量版本的<code>iterator</code>。或许有人认为可以通过<code>static_cast</code>转化一下，所以有了下面这段代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> IterT = vector&lt;<span class="type">int</span>&gt;::iterator;</span><br><span class="line"><span class="keyword">using</span> ConstIterT = vector&lt;<span class="type">int</span>&gt;::const_iterator;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;value;</span><br><span class="line">ConstIterT ci = <span class="built_in">find</span>(<span class="built_in">static_cast</span>&lt;ConstIterT&gt;(value.<span class="built_in">begin</span>()), <span class="built_in">static_cast</span>&lt;ConstIterT&gt;(value.<span class="built_in">end</span>()), <span class="number">198</span>);</span><br><span class="line">value.<span class="built_in">insert</span>(<span class="built_in">static_cast</span>&lt;IterT&gt;(ci), <span class="number">1998</span>);         <span class="comment">//error</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中<code>find</code>返回的是非常量的迭代器，因为后续不会改动，遵从代码标准通过<code>static_cast</code>将其转换为<code>const_iterator</code>。但是在后面，当我在要往这个迭代器出插入一个元素的时候，我又不得不把它转换为非常量的迭代器，因为<code>insert</code>方法接受的参数是<code>iterator</code>类型的迭代器，为此我又再次使用了<code>static_cast</code>，可是这次失败了，因为从<code>const_iterator</code>到<code>iterator</code>并不存在可以指的型别转换，就连<code>reinterpret_cast，const_cast</code>都不行。 </p><h1 id="C-11里的const-iterator"><a href="#C-11里的const-iterator" class="headerlink" title="C++11里的const_iterator"></a>C++11里的const_iterator</h1><p>上述问题在C++11中得以解决，在C++11中可以很轻松的创建和使用常量迭代器，它给容器都提供了<code>cbegin</code>和<code>cend</code>等成员函数都返回<code>const_iterator</code>类型，甚至对于非const容器也是如此，并且STL成员函数若要取用指示位置的迭代器（例如，作插入或删除之用），它们也要求使用<code>const_iterator</code>类型。在C++11中上面的代码可以更改成下面的形式:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> IterT = vector&lt;<span class="type">int</span>&gt;::iterator;</span><br><span class="line"><span class="keyword">using</span> ConstIterT = vector&lt;<span class="type">int</span>&gt;::const_iterator;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;value;</span><br><span class="line">ConstIterT ci = <span class="built_in">find</span>(value.<span class="built_in">cbegin</span>(), value.<span class="built_in">cend</span>(), <span class="number">198</span>);</span><br><span class="line">value.<span class="built_in">insert</span>(ci, <span class="number">1988</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一种情景下，C++11对于<code>const_iterator</code>的支持显得不够充分，那就是你想撰写最通用化的库代码的时候。除了标准容器外，其实还有一些类似于容器的数据结构，这些结构没有begin，end等这类方法，为此C++11中提供了非成员函数的版本，可以用于像数组这种类容器的数据结构。有了非成员函数版本的cbegin，cend，对于写一些通用代码就更加的方便了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> C,<span class="keyword">typename</span> V&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findAndInsert</span><span class="params">(C&amp; container,    <span class="comment">//在容器中查找targetVal</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> V&amp; targetVal,         <span class="comment">//第一次出现的位置</span></span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> V&amp; insertVal)</span>         <span class="comment">//然后在此处插入insertVal</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cbegin;</span><br><span class="line">    <span class="keyword">using</span> std::end;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(<span class="built_in">cbegin</span>(container),  <span class="comment">//非成员函数版本的cbegin</span></span><br><span class="line">                        <span class="built_in">cend</span>(container),    <span class="comment">//非成员函数版本的cend</span></span><br><span class="line">                        targetVal);</span><br><span class="line">    container.<span class="built_in">insert</span>(it, insertVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码就比较通用了，对于一切类容器的数据结构都是适用的，而不是只能用于标准的STL容器了。很可惜上面的代码需要C++14的支持，C++11只支持<code>begin</code>和<code>end</code>，而到C++14才开始支持<code>cbegin，cend</code>。如果你的编译器不支持C++14，那么你可以使用下面这段代码代替：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> C&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">cbegin</span><span class="params">(<span class="type">const</span> C&amp; container)</span>-&gt;<span class="title">decltype</span><span class="params">(std::begin(container))</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">begin</span>(container);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>noexcept</title>
      <link href="/posts/57754.html"/>
      <url>/posts/57754.html</url>
      
        <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>关于异常的基本语法如下：</p><img src="https://img.imgdd.com/ae166215-3c7d-4458-b940-549b0fc09b4e.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 20 auto;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="number">-1</span>;<span class="comment">//主动抛出异常值-1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (<span class="type">int</span> e) &#123;<span class="comment">//捕获整数类型的异常，这里的e就是被抛出的值(-1)。</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int exception, value: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;That&#x27;s ok!&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋。</code></p><h2 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h2><p>为加强程序可读性，可以在函数声明中列出所有可能抛出的所有异常类型，常用写法有如下三种：</p><ol><li><p>显示指定可以抛出的异常类型</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> &#123;</span><br><span class="line">    <span class="built_in">MyException</span>(string s) : <span class="built_in">msg</span>(s) &#123;&#125;</span><br><span class="line">    string msg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divisionMethod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="title">throw</span><span class="params">(MyException, <span class="type">int</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;division by zero!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> v = <span class="built_in">divisionMethod</span>(<span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v = &quot;</span> &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (MyException e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch except: &quot;</span> &lt;&lt; e.msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span> e) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;catch except: &quot;</span> &lt;&lt; e &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第6行代码<code>divisionMethod</code>函数后添加了<code>throw</code>异常接口声明，其参数表示可以抛出的异常类型分别为<code>int</code>和<code>MyException</code>类型。</p></li><li><p>抛出任意异常类型</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">MyException</span> &#123;</span><br><span class="line">    <span class="built_in">MyException</span>(string s) : <span class="built_in">msg</span>(s) &#123;&#125;</span><br><span class="line">    string msg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divisionMethod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">MyException</span>(<span class="string">&quot;division by zero!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第6行代码在<code>divisionMethod没有添加异常接口声明</code>，表示在该函数中<code>可以抛出任意类型的异常。</code></p></li><li><p>不抛出任何异常</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">divisionMethod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;division by zero!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>divisionMethod</code>函数后添加了<code>throw</code>异常接口声明，<code>其参数列表为空，表示该函数不允许抛出异常。</code></p></li></ol><h1 id="noexcept"><a href="#noexcept" class="headerlink" title="noexcept"></a>noexcept</h1><p>上面的例子中，在<code>divisionMethod</code>函数声明之后，我们定义了一个动态异常声明<code>throw(MyException, int)</code>，该声明指出了<code>divisionMethod</code>可能抛出的异常的类型。<code>事实上，该特性很少被使用，因此在C++11中被弃用了</code>，而表示函数不会抛出异常的动态异常声明throw()也被新的<code>noexcept</code>异常声明所取代。</p><p><code>noexcept</code>表示<code>其修饰的函数不会抛出异常</code>。与<code>throw()</code>动态抛出异常不同的是，在C++11中，如果noexcept修饰的函数抛出了异常，编译器可以选择直接调用<code>std::terminate()</code>函数来终止程序的运行，<code>这比throw()在效率上会高一些</code>。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（栈解旋），并自动调用析构函数释放栈上的所有对象。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">divisionMethod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;division by zero!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>noexcept</code>修饰有两种形式：</p><ol><li><p>简单地在函数声明后加上noexcept关键字</p></li><li><p>可以接受一个常量表达式作为参数，如下所示∶</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">divisionMethod</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="title">noexcept</span><span class="params">(常量表达式)</span></span>;</span><br></pre></td></tr></table></figure><p> 常量表达式的结果会被转换成一个bool类型的值：</p><ul><li>值为true，表示函数不会抛出异常</li><li>值为false，表示有可能抛出异常</li><li><code>不带常量表达式的noexcept相当于声明了noexcept（true），即不会抛出异常。</code></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>默认函数控制=default与=delete</title>
      <link href="/posts/1759.html"/>
      <url>/posts/1759.html</url>
      
        <content type="html"><![CDATA[<h1 id="类与默认函数"><a href="#类与默认函数" class="headerlink" title="类与默认函数"></a>类与默认函数</h1><p>在C++中声明自定义的类，编译器都会默认自动生成一些程序员未自定义的成员函数，这些成员函数被称为<code>默认函数</code>或<code>特种成员函数</code></p><ol><li><code>无参构造函数</code>：创建类对象</li><li><code>拷贝构造函数</code>：拷贝类对象</li><li><code>拷贝赋值函数</code>：类对象赋值</li><li><code>移动构造函数</code>：拷贝类对象</li><li><code>移动赋值函数</code>：类对象赋值</li><li><code>析构函数</code>：销毁类对象</li></ol><p><code>在C++语法规则中，一旦程序员实现了这些函数的自定义版本，则编译器不会再为该类自动生成默认版本。</code></p><h1 id="default和-delete"><a href="#default和-delete" class="headerlink" title="&#x3D;default和 &#x3D;delete"></a>&#x3D;default和 &#x3D;delete</h1><p>在C++11标准中称<code>=default</code>修饰的函数为<code>显式默认函数</code>，而称<code>=delete</code>修饰的函数为<code>删除函数</code>或者<code>显示删除函数</code>。</p><p>C++11引入显式默认和显式删除是为了增强对类默认函数的控制，让程序员能够更加精细地控制默认版本的函数。</p><h2 id="default"><a href="#default" class="headerlink" title="&#x3D;default"></a>&#x3D;default</h2><p><code>=default</code>用于显式地告诉编译器为成员函数生成默认实现。这通常用于那些编译器默认不会自动生成的成员函数，比如自定义类型的拷贝构造函数和拷贝赋值运算符。</p><p>移动操作的生成条件仅当以下三者同时成立：</p><ul><li>该类未声明任何拷贝操作</li><li>该类未声明任何移动操作</li><li>该类未声明任何析构函数</li></ul><p>在C++11及以后的版本，如果你想在已经存在任一拷贝操作或析构函数的条件下，仍然想让编译器自动生成移动操作，就需要通过<code>=default</code>来显示地表达这个想法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">const</span> MyClass&amp; other) : <span class="built_in">data</span>(other.data) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyClass&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Copy assignment called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式声明移动构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(MyClass&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显式声明移动赋值运算符</span></span><br><span class="line">    MyClass&amp; <span class="keyword">operator</span>=(MyClass&amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>定义默认函数的注意事项：</strong></p><p><code>如果程序猿对C++类提供的默认函数（上面提到的六个函数）进行了实现，那么可以通过=default将他们再次指定为默认函数，不能使用=default修饰这六个函数以外的函数。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp; obj) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Base</span>(Base&amp;&amp; obj) = <span class="keyword">default</span>;</span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; obj) = <span class="keyword">default</span>;</span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(Base&amp;&amp; obj) = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下写法全部都是错误的</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> a = <span class="number">0</span>) = <span class="keyword">default</span>;          <span class="comment">//有参构造</span></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> a, <span class="type">int</span> b) = <span class="keyword">default</span>;       <span class="comment">//有参构造</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="keyword">default</span>;             <span class="comment">//自定义函数</span></span><br><span class="line">    <span class="comment">//不是移动、复制赋值运算符重载，不允许使用 =default 修饰</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>== (<span class="type">const</span> Base&amp; obj) = <span class="keyword">default</span>;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Base&amp; obj) = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="delete"><a href="#delete" class="headerlink" title="&#x3D;delete"></a>&#x3D;delete</h2><p>在C++98中的basic_ios像下面这样规定的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">charT</span>,<span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : publi ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp;);                <span class="comment">//not defined</span></span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;);     <span class="comment">//not defined</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过将这些函数声明为<code>private</code>，就阻止了客户去调用它们。而故意不去定义它们，就意味着如果一段代码仍然可以访问它们（如成员函数或类的友元）并使用它们，链接阶段就会由于缺少函数定义而报错</p><p>在C++11中，有更好的途径来达成效果上相同的结果：使用<code>=delete</code>将拷贝构造和拷贝赋值将其标识为<code>删除函数</code>。以下是C++11中关于basic_ios规定的同一片段</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">charT</span>,<span class="keyword">class</span> <span class="title class_">traits</span> = char_traits&lt;charT&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> basic_ios : publi ios_base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">basic_ios</span>(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;                </span><br><span class="line">    basic_ios&amp; <span class="keyword">operator</span>=(<span class="type">const</span> basic_ios&amp;) = <span class="keyword">delete</span>;  </span><br><span class="line">    ...   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用delete关键字和将函数声明为private看起来只是不同风格的选择，但实际上是有区别的。</p><ol><li><p><code>使用delete删除的函数无法通过任何方法调用，即使是成员函数或友元函数中的代码也是无法调用的。</code>相对于private的做法来讲，这是一种改进。</p></li><li><p><code>删除函数往往被声明为public。</code>这样做的好处是，当客户代码尝试调用某个成员函数时，C++会先校验其可访问性，后校验删除状态。这么一来，当客户代码尝试调用某个private函数，编译器只会提示该函数为private。所以把新的delete函数声明为public会得到更好的错误信息。</p></li><li><p><code>任何函数都可以成为删除函数，但是只有类成员函数才能被声明为private。</code></p><p> 举例来讲，如果我们有一个函数<code>bool isLucky(int number);</code>C++中很多类型可以隐式转换到int中，所以会出现以下无意义的代码调用</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="string">&#x27;a&#x27;</span>))       <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="literal">true</span>))      <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isLucky</span>(<span class="number">3.14</span>))      <span class="comment">//ok</span></span><br></pre></td></tr></table></figure><p> 当我们想要阻止这样的调用的时候，我们可以通过delete关键字来删除对应的重载版本</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">int</span> number)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">char</span>)</span> </span>= <span class="keyword">delete</span>;    <span class="comment">//error</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">bool</span>)</span> </span>= <span class="keyword">delete</span>;    <span class="comment">//error</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLucky</span><span class="params">(<span class="type">double</span>)</span> </span>= <span class="keyword">delete</span>;  <span class="comment">//error</span></span><br></pre></td></tr></table></figure></li><li><p><code>删除函数还可以阻止那些不应该进行的模板实现。</code></p><p> 举例来讲，如果你需要一个和内建指针协作的模板</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processPointer</span><span class="params">(T* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 而指针的类型中有两个异类，一个是void*，因为无法对其进行自增、自减等操作；一个是char*，因为它们基本上表示的是C风格的字符串，而不是指向单个字符的指针。这时候我们可以通过删除函数来阻止对这两种类型的模板实现，而这一点是private无法做到的。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">void</span>&gt;(<span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">char</span>&gt;(<span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">void</span>&gt;(<span class="type">const</span> <span class="type">void</span>*) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">processPointer</span>&lt;<span class="type">const</span> <span class="type">char</span>&gt;(<span class="type">const</span> <span class="type">char</span>*) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>强类型枚举</title>
      <link href="/posts/52235.html"/>
      <url>/posts/52235.html</url>
      
        <content type="html"><![CDATA[<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h2 id="枚举的使用"><a href="#枚举的使用" class="headerlink" title="枚举的使用"></a>枚举的使用</h2><p>枚举类型是C及C++中一个基本的内置类型，不过也是一个有点“奇怪”的类型。从枚举的本意上来讲，就是要定义一个类别，并穷举同一类别下的个体以供代码中使用。由于枚举来源于C，所以出于设计上的简单的目的，枚举值常常是对应到整型数值的一些名字，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名枚举</span></span><br><span class="line"><span class="keyword">enum</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"><span class="comment">//有名枚举</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Colors</span> &#123; Red, Green, Blue &#125;;</span><br></pre></td></tr></table></figure><p>在枚举类型中的枚举值编译器会默认从0开始赋值，而后依次向下递增，也就是说Red&#x3D;0，Green&#x3D;1，Blue&#x3D;2。</p><h2 id="枚举的缺陷"><a href="#枚举的缺陷" class="headerlink" title="枚举的缺陷"></a>枚举的缺陷</h2><p>C&#x2F;C++的enum有个很”奇怪”的设定，就是<code>具名（有名字）的enum类型的名字，以及enum的成员的名字都是全局可见的</code>。这与 C++中具名的namespace、class&#x2F;struct 及union必须通过<code>名字::成员名</code>的方式访问相比是格格不入的，编码过程中一不小心程序员就容易遇到问题。比如∶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">China</span> &#123; Shanghai, Dongjing, Beijing, Nanjing &#125;;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Japan</span> &#123; Dongjing, Daban, Hengbin, Fudao &#125;;</span><br><span class="line"><span class="keyword">auto</span> Shanghai = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>上面的定义信息编译器会报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">“Dongjing”: 重定义；以前的定义是“枚举数”</span><br><span class="line">“Shanghai”: 重定义；以前的定义是“枚举数”</span><br></pre></td></tr></table></figure><p>错误的原因上面也提到了，在这两个具名的枚举中<code>Dongjing和Shanghai</code>是全局可见的，所有编译器就会提示其重定义了，这催生了此类枚举类型的官方属于：<code>不限范围的（unscoped）枚举类型</code>另外，由于C中枚举被设计为常量数值的”别名”的本性，所以枚举的成员总是可以被隐式地转换为整型，但是很多时候我们并不想这样。</p><h1 id="强类型枚举"><a href="#强类型枚举" class="headerlink" title="强类型枚举"></a>强类型枚举</h1><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>针对枚举的缺陷，C++11标准引入了一种新的枚举类型，即<code>枚举类</code>，又称<code>强类型枚举（strong-typed enum）或限定作用域的（scoped）枚举类型</code>。声明强类型枚举非常简单，<code>只需要在enum后加上关键字class</code>。比如∶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义强类型枚举，被限定在Color内</span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Colors</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"><span class="keyword">auto</span> Red = <span class="literal">false</span>;<span class="comment">// ok</span></span><br><span class="line">Colors c = Red;<span class="comment">// error 全局域下目前没有Red枚举量</span></span><br><span class="line">Colors c = Colors::Red;<span class="comment">// ok</span></span><br><span class="line"><span class="keyword">auto</span> c = Colors::Red;<span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>强类型枚举有如下优势：</p><ul><li><p>强作用域，强类型枚举成员的名称不会被输出到其父作用域空间。</p></li><li><p><code>强类型枚举只能是有名枚举</code>，如果是匿名枚举会导致枚举值无法使用</p></li><li><p>转换限制，强类型枚举成员的值<code>不可以与整型隐式地相互转换</code>。</p></li><li><p><code>可以指定底层类型</code>。强类型枚举默认的底层类型为 int，但也可以显式地指定底层类型，具体方法为在枚举名称后面加上∶type，其中 type 可以是除 wchar_t 以外的任何整型。比如:</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">Colors</span> :<span class="type">char</span> &#123; Red, Green, Blue &#125;;</span><br></pre></td></tr></table></figure></li></ul><p>接着通过一个例子来看看强类型枚举的使用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">China</span> &#123; Shanghai, Dongjing, Beijing, Nanjing &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Japan</span> :<span class="type">char</span> &#123; Dongjing, Daban, Hengbin, Fudao &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> m = Shanghai;    <span class="comment">//error</span></span><br><span class="line"><span class="type">int</span> n = China::Shanghai;    <span class="comment">//error</span></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">int</span>)China::Shanghai &gt;= <span class="number">2</span>) &#123;    <span class="comment">//ok</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ok&quot;</span> &lt;&lt; endl;   </span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size1: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(China::Dongjing) &lt;&lt; endl;   <span class="comment">// 4</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size2: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Japan::Dongjing) &lt;&lt; endl;   <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第4行：该行的代码有两处错误<ul><li>强类型枚举属于强作用于类型，不能直接使用，枚举值前必须加枚举类型</li><li><code>强类型枚举不会进行隐式类型转换</code>，因此枚举值不能直接给int行变量赋值（虽然强类型枚举的枚举值默认就是整形，但其不能作为整形使用）。</li></ul></li><li>第5行：语法错误，将强类型枚举值作为整形使用，此处不会进行隐式类型转换</li><li>第6行：语法正确，强类型枚举值在和整数比较之前做了<code>强制类型转换。</code></li><li>第9行：打印的结果为4，强类型枚举底层类型值默认为int，因此占用的内存是4个字节</li><li>第10行：打印的结果为1，显示指定了强类型枚举值的类型为char，因此占用的内存大小为1个字节，这样我们就可以节省更多的内存空间了。</li></ul><h2 id="对原有枚举的扩展"><a href="#对原有枚举的扩展" class="headerlink" title="对原有枚举的扩展"></a>对原有枚举的扩展</h2><p>相比于原来的枚举，强类型枚举更像是一个属于C++的枚举。但为了配合新的枚举类型，C++11还对原有枚举类型进行了扩展：</p><ol><li><p>原有枚举类型的底层类型在默认情况下，仍然由编译器来具体指定实现。但也可以跟强类型枚举类一样，显式地由程序员来指定。其指定的方式跟强类型枚举一样，都是枚举名称后面加上<code>∶type</code>，其中<code>type可以是除wchar_t以外的任何整型</code>。比如∶</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Colors</span> : <span class="type">char</span> &#123; Red, Green, Blue &#125;;</span><br></pre></td></tr></table></figure></li><li><p>关于作用域，在C++11中，枚举成员的名字除了会自动输出到父作用域，也可以在枚举类型定义的作用域内有效。比如：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Colors</span> : <span class="type">char</span> &#123; Red, Green, Blue &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Colors c1 = Green;          <span class="comment">// C++11以前的用法</span></span><br><span class="line">    Colors c2 = Colors::Green;  <span class="comment">// C++11的扩展语法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面程序中第3、4行的写法都是合法的。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法part03</title>
      <link href="/posts/41022.html"/>
      <url>/posts/41022.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-134-加油站"><a href="#LeetCode-134-加油站" class="headerlink" title="LeetCode 134 加油站"></a>LeetCode 134 加油站</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/gas-station">134.加油站</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先要明确的是，如果总油量减去总消耗大于等于零那么一定可以跑完一圈，说明各个站点的加油站剩油量rest[i]相加一定是大于等于零的。</p><p>i从0开始累加rest[i]，和记为curSum，一旦curSum小于零，说明[0,i]区间都不能作为起始位置，因为这个区间选择任何一个位置作为起点，到i这里都会断油，那么起始位置从i+1算起，再从0计算curSum。</p><img src="https://img.imgdd.com/14fafca7-6c38-4475-b7cb-f9dfb6f360a9.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 20 auto;" /><p>那么为什么一旦[0,i] 区间和为负数，起始位置就可以是i+1呢，i+1后面就不会出现更大的负数？如果出现更大的负数，就是更新i，那么起始位置又变成新的i+1了。</p><p><strong>那么局部最优：当前累加rest[i]的和curSum一旦小于0，起始位置至少要是i+1，因为从i之前开始一定不行。全局最优：找到可以跑一圈的起始位置。</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> gasSum = <span class="number">0</span>, costSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : gas) &#123;</span><br><span class="line">            gasSum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j : cost) &#123;</span><br><span class="line">            costSum += j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果总油量比总消耗小，那就不用比较了，一定不能跑完一圈</span></span><br><span class="line">        <span class="keyword">if</span>(gasSum &lt; costSum) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, curSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; gas.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            curSum += gas[i] - cost[i];</span><br><span class="line">            <span class="keyword">if</span>(curSum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-135-分发糖果"><a href="#LeetCode-135-分发糖果" class="headerlink" title="LeetCode 135 分发糖果"></a>LeetCode 135 分发糖果</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/candy">135.分发糖果</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题目一定是要确定一边之后，再确定另一边，例如比较每一个孩子的左边，然后再比较右边，<strong>如果两边一起考虑一定会顾此失彼。</strong></p><p>先确定右边评分大于左边的情况（也就是从前向后遍历）。此时局部最优：只要右边评分比左边大，右边的孩子就多一个糖果，全局最优：相邻的孩子中，评分高的右孩子获得比左边孩子更多的糖果</p><p>如果<code>ratings[i]&gt;ratings[i-1]</code>那么<code>ratings[i]</code>的糖 一定要比<code>ratings[i - 1]</code>的糖多一个，所以贪心：<code>candyVec[i] = candyVec[i - 1] + 1</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右边比左边大（从前向后遍历）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; ratings.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">        candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前向后遍历的结果如下图所示：</p><img src="https://img.imgdd.com/4a1a2a90-baf7-49eb-b1d8-e06d432210bc.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 20 auto;" /><p>然后再确定左孩子大于右孩子的情况（从后向前遍历）。遍历顺序这里有同学可能会有疑问，为什么不能从前向后遍历呢？因为rating[5]与rating[4]的比较 要利用上rating[5]与rating[6]的比较结果，所以 要从后向前遍历。如果从前向后遍历，rating[5]与rating[4]的比较 就不能用上rating[5]与rating[6]的比较结果了，如图：</p><img src="https://img.imgdd.com/8ccc2413-108f-46ea-95ef-3c04629266f9.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 20 auto;" /><p><strong>所以确定左孩子大于右孩子的情况一定要从后向前遍历！</strong></p><p>如果<code>ratings[i] &gt; ratings[i + 1]</code>（左孩子大于右孩子），此时candyVec[i]（第i个小孩的糖果数量）就有两个选择了，一个是candyVec[i + 1] + 1（从右边这个加1得到的糖果数量），一个是candyVec[i]（之前比较右孩子大于左孩子得到的糖果数量）。</p><p>那么又要贪心了，局部最优：取<code>candyVec[i + 1] + 1</code>和<code>candyVec[i]</code>最大的糖果数量，保证第i个小孩的糖果数量既大于左边的也大于右边的。全局最优：相邻的孩子中，评分高的孩子获得更多的糖果。</p><p>局部最优可以推出全局最优。</p><p>所以就取<code>candyVec[i + 1] + 1</code>和<code>candyVec[i]</code>最大的糖果数量，candyVec[i]只有取最大的才能既保持对左边<code>candyVec[i - 1]</code>的糖果多，也比右边<code>candyVec[i + 1]</code>的糖果多。如下图所示：</p><img src="https://img.imgdd.com/a7b47cc3-97be-490f-b58d-6790eb061601.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 20 auto;" /><p>所以该过程代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左边比有边大（从后向前遍历）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">//贪心</span></span><br><span class="line">        candyVec[i] = <span class="built_in">max</span>(candyVec[i + <span class="number">1</span>] + <span class="number">1</span>,candyVec[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">candyVec</span>(ratings.<span class="built_in">size</span>(),<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//右边比左边大（从前向后遍历）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; ratings.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                candyVec[i] = candyVec[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左边比有边大（从后向前遍历）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = ratings.<span class="built_in">size</span>() - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">//贪心</span></span><br><span class="line">                candyVec[i] = <span class="built_in">max</span>(candyVec[i + <span class="number">1</span>] + <span class="number">1</span>,candyVec[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计结果 </span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : candyVec) &#123;</span><br><span class="line">            count += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-860-柠檬水找零"><a href="#LeetCode-860-柠檬水找零" class="headerlink" title="LeetCode 860 柠檬水找零"></a>LeetCode 860 柠檬水找零</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/lemonade-change">860.柠檬水找零</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这是今天最简单的一道题目了，我们只需要维护三种金额的数量，5，10和20，维护情况有如下三种：</p><ul><li>情况一：账单是5，直接收下。</li><li>情况二：账单是10，消耗一个5，增加一个10</li><li>情况三：账单是20，优先消耗一个10和一个5，如果不够，再消耗三个5</li></ul><p>情况一和情况二是不能改变，情况三是则有两种策略。根据贪心的思想，我们既然要尽可能地给所有客人都能找零钱，那么肯定优先消耗一个10和一个5，<strong>因为美元10只能给账单20找零，而美元5可以给账单10和账单20找零，美元5更万能！</strong></p><p>所以局部最优：遇到账单20，优先消耗美元10，完成本次找零。全局最优：完成全部账单的找零。</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> five = <span class="number">0</span>, ten = <span class="number">0</span>, twenty = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; bills.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(bills[i] == <span class="number">5</span>) five++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">10</span>) &#123;</span><br><span class="line">                ten++;</span><br><span class="line">                five--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//优先给一张5美元和一张10美元，尽可能均摊钞票</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(bills[i] == <span class="number">20</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(ten &gt; <span class="number">0</span> &amp;&amp; five &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ten--;</span><br><span class="line">                    five--;</span><br><span class="line">                    twenty++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(five &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                    five -= <span class="number">3</span>;</span><br><span class="line">                    twenty++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(five &lt; <span class="number">0</span> || ten &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-406-根据身高重建队列"><a href="#LeetCode-406-根据身高重建队列" class="headerlink" title="LeetCode 406 根据身高重建队列"></a>LeetCode 406 根据身高重建队列</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/queue-reconstruction-by-height">406.根据身高重建队列</a></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这题和<a href="https://leetcode.cn/problems/candy">135.分发糖果</a>一样，都存在两个维度。本题的两个维度分别是h和k，看到这种题目一定要想如何确定一个维度，然后再按照另一个维度重新排列。<strong>如果两个维度一起考虑一定会顾此失彼。</strong></p><p>那么本题是先确定k还是先确定h呢，也就是究竟先按h排序呢，还是先按照k排序呢？如果是按照k来进行升序或降序排序，排完之后发现，身高并没有呈现单调增或减的趋势，两个维度哪一个都没有确定下来。那么按照身高h来排序呢，身高一定是从大到小排（身高相同的话则k小的站前面），让高个子在前面。<strong>此时我们可以确定一个维度了，就是身高，前面的节点一定都比本节点高！</strong> 如果没有理解这段话可以看看下图：</p><img src="https://img.imgdd.com/7b0dabb0-7087-478c-ac69-4db86291531a.jpg" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 20 auto;" /><p>还有更多的情况我就不一一列举了，下面给出的是身高从大到小排序的过程</p><img src="https://img.imgdd.com/48d2f051-6542-4e11-afe7-797291eba55a.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 20 auto;" /><p>按照身高排序之后，优先按身高高的people的k来插入，后续插入节点也不会影响前面已经插入的节点，最终按照k的规则完成了队列。</p><p><strong>局部最优：优先按照身高高的people的k来插入，插入操作过后的people满足队列属性</strong></p><p><strong>全局最优：最后都昨晚插入操作，整个队列满足题目队列属性</strong></p><p>整个插入过程如下：</p><p>排序完的people： [[7,0], [7,1], [6,1], [5,0], [5,2], [4,4]]</p><p>插入的过程：</p><ul><li>插入[7,0]：[[7,0]]</li><li>插入[7,1]：[[7,0],[7,1]]</li><li>插入[6,1]：[[7,0],[6,1],[7,1]]</li><li>插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]</li><li>插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]</li><li>插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]</li></ul><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//身高从大到小排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//身高相同，k小在前</span></span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>]) <span class="keyword">return</span> a[<span class="number">1</span>] &lt; b[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &gt; b[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(),people.<span class="built_in">end</span>(),cmp);</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt;que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; people.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="type">int</span> position = people[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">auto</span> it = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(position--) &#123;</span><br><span class="line">                it++;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">insert</span>(it,people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(),que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>弱引用智能指针</title>
      <link href="/posts/22337.html"/>
      <url>/posts/22337.html</url>
      
        <content type="html"><![CDATA[<p>C++中没有回收机制，必须要手动释放分配到的内存，否则就会造成内存泄漏，解决这个问题最有效的方法是使用智能指针（smart pointer）。<code>智能指针是指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</code></p><p>C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件<code>&lt;memory&gt;</code>：</p><ul><li><code>std::shared_ptr：</code>共享的智能指针</li><li><code>std::unique_ptr：</code>独占的智能指针</li><li><code>std::weak_ptr：</code>弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。</li></ul><h1 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h1><p>弱引用智能指针<code>std::weak_ptr</code>可以看作时<code>shared_ptr</code>的助手，它不管理<code>shared_ptr</code>内部的指针。<code>std::weak_ptr</code>没有重载操作符<code>*</code>和<code>-&gt;</code>，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视<code>shared_ptr</code>中管理的资源是否存在。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">weak_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="built_in">weak_ptr</span> (<span class="type">const</span> weak_ptr&amp; x) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">weak_ptr</span> (<span class="type">const</span> weak_ptr&lt;U&gt;&amp; x) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 通过shared_ptr对象构造</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">weak_ptr</span> (<span class="type">const</span> shared_ptr&lt;U&gt;&amp; x) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，<code>weak_ptr</code>可以通过另一个<code>weak_ptr</code>或<code>shared_ptr</code>进行拷贝构造初始化。可能光看上面的定义会显得很复杂，下面通过一个例子来说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">sp</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;wp1;<span class="comment">//默认构造函数初始化</span></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">wp2</span>(wp1);<span class="comment">//拷贝构造函数初始化</span></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">wp3</span>(sp);<span class="comment">//拷贝构造函数初始化</span></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;wp4;</span><br><span class="line">wp4 = sp;<span class="comment">//拷贝赋值初始化</span></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;wp5;</span><br><span class="line">wp5 = wp3;<span class="comment">//拷贝赋值初始化</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h2><h3 id="use-count"><a href="#use-count" class="headerlink" title="use_count()"></a>use_count()</h3><p>通过调用<code>std::weak_ptr</code>类提供的方法<code>use_count()</code>方法可以获得当前所观测资源的引用计数，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">sp</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;wp1;    <span class="comment">//只声明，未初始化，引用计数0</span></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">wp2</span>(wp1);</span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">wp3</span>(sp);</span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;wp4;</span><br><span class="line">wp4 = sp;</span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;wp5;</span><br><span class="line">wp5 = wp3;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wp1: &quot;</span> &lt;&lt; wp<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl; </span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wp2: &quot;</span> &lt;&lt; wp<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wp3: &quot;</span> &lt;&lt; wp<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wp4: &quot;</span> &lt;&lt; wp<span class="number">4.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wp5: &quot;</span> &lt;&lt; wp<span class="number">5.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use_count:</span><br><span class="line">wp1: <span class="number">0</span></span><br><span class="line">wp2: <span class="number">0</span></span><br><span class="line">wp3: <span class="number">1</span></span><br><span class="line">wp4: <span class="number">1</span></span><br><span class="line">wp5: <span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过打印的结果可以知道，虽然弱引用智能指针<code>wp3、wp4、wp5</code>监测的资源是同一个，但是它的引用计数并没有发生任何的变化，也进一步证明了weak_ptr只是监测资源，并不管理资源</p><h3 id="expired"><a href="#expired" class="headerlink" title="expired()"></a>expired()</h3><p>通过调用<code>std::weak_ptr</code>类提供的<code>expired()</code>方法来判断观测的资源是否已经被释放，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">shared</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>));</span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">weak</span>(shared);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1.weak&quot;</span> &lt;&lt; (weak.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">shared.<span class="built_in">reset</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2.weak&quot;</span> &lt;&lt; (weak.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>weakis <span class="keyword">not</span> expired</span><br><span class="line"><span class="number">2.</span>weakis expired</span><br></pre></td></tr></table></figure><p><code>weak_ptr</code>监视的是<code>shared_ptr</code>所管理的资源，当<code>shared_ptr</code>调用<code>reset()</code>方法释放资源后，<code>weak.expired()</code>函数的返回结果是<code>true</code>，表示监视的资源已经不存在了</p><h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><p>通过调用<code>std::weak_ptr</code>类提供的<code>lock()</code>方法来获取管理所监测资源的shared_ptr对象，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;sp1, sp2;</span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt;wp;</span><br><span class="line"></span><br><span class="line">sp1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">wp = sp1;</span><br><span class="line">sp2 = wp.<span class="built_in">lock</span>();<span class="comment">//相当于sp2 = sp1</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">sp<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">sp1 = wp.<span class="built_in">lock</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*sp1: &quot;</span> &lt;&lt; *sp1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*sp2: &quot;</span> &lt;&lt; *sp2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">use_count: <span class="number">2</span></span><br><span class="line">use_count: <span class="number">1</span></span><br><span class="line">use_count: <span class="number">2</span></span><br><span class="line">*sp1: <span class="number">520</span></span><br><span class="line">*sp2: <span class="number">520</span></span><br></pre></td></tr></table></figure><ul><li><code>sp2 = wp.lock();</code>通过调用<code>lock()</code>方法得到一个<code>wp</code>所管理的<code>shared_ptr</code>类型资源的对象，使用这个对象初始化<code>sp2</code>，此时所监测资源的引用计数为<code>2</code></li><li><code>sp1.reset();</code>共享智能指针<code>sp1</code>被重置，<code>weak_ptr</code>对象所监测的资源的引用计数减1</li><li><code>sp1 = wp.lock();</code>sp1重新被初始化，但是<code>wp</code>管理的还是原来<code>shared_ptr</code>类型的资源对象，因此引用计数加1</li><li>共享智能指针对象<code>sp1</code>和<code>sp2</code>管理的是同一块内存，因此最终打印的内存中的结果是相同的，都是520</li></ul><h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p>通过调用<code>std::weak_ptr</code>类提供的<code>reset()</code>方法来清空对象，使其不监测任何资源，示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">sp</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">wp</span>(sp);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1. wp &quot;</span> &lt;&lt; (wp.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    wp.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2. wp &quot;</span> &lt;&lt; (wp.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> wp is <span class="keyword">not</span> expired</span><br><span class="line"><span class="number">2.</span> wp is expired</span><br></pre></td></tr></table></figure><p><code>weak_ptr</code>对象<code>sp</code>被重置之后<code>wp.reset();</code>变成了空对象，不再监测任何资源，因此<code>wp.expired()</code>返回<code>true</code></p><h1 id="返回管理this的shared-ptr"><a href="#返回管理this的shared-ptr" class="headerlink" title="返回管理this的shared_ptr"></a>返回管理this的shared_ptr</h1>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法part02</title>
      <link href="/posts/24831.html"/>
      <url>/posts/24831.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-122-买卖股票的最佳时机II"><a href="#LeetCode-122-买卖股票的最佳时机II" class="headerlink" title="LeetCode 122 买卖股票的最佳时机II"></a>LeetCode 122 买卖股票的最佳时机II</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii">122.买卖股票的最佳时机II</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们最初会想到，这道题目可以选一个低的买入，再选个高的卖，再选一个低的买入…..循环反复。那么问题来了，我们要怎么确定哪些是低的能够买入，哪些是高的能够卖出？</p><p><strong>如果最终利润可以分解的话，那题目是不是就容易很多了</strong>，那怎么分解呢？</p><p>假设第0天买入，第3天卖出，那么利润就是：<code>prices[3]-prices[0]</code>，可以分解为：<code>(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])</code>。<strong>此时就是吧总的利润分解为以每天为单位的维度，而不是从0到3天的整体去考虑</strong>。我们可以绘制出每一天的利润数组，如下图所示：</p><img src="https://img.imgdd.com/4cc77f6e-5a81-47eb-b211-08e2a5245696.jpg" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p>这里我们需要注意一下，第一天是没有利润的，结合实际我们也能想到：第一天购买然后就卖出那利润可不就是0吗。此外，我们只需要收集每天正利润就可以了，<strong>收集正利润的区间，就是股票买卖的区间，我们只需关注最终利润，不需要记录区间，</strong> 这就是贪心所贪的地方。</p><p><strong>局部最优：收集每天的正利润</strong></p><p><strong>全局最优：求得最大利润</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">profit</span>(prices.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; prices.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            profit[i - <span class="number">1</span>] = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; profit.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="comment">//如果利润大于0，那就卖出去</span></span><br><span class="line">            <span class="keyword">if</span>(profit[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result += profit[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-55-跳跃游戏"><a href="#LeetCode-55-跳跃游戏" class="headerlink" title="LeetCode 55 跳跃游戏"></a>LeetCode 55 跳跃游戏</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/jump-game">55.跳跃游戏</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>既然是贪心问题，我们自然不会关注每一次能够跳跃几步这种行为，我们要关注的是可跳的覆盖范围，因为这题并没有说最小或最大跳跃次数，只关注能否跳到终点，那我们每次都取最大的跳跃步数，尽可能多的覆盖可跳跃范围，这个范围内，别管是怎么跳的，反正一定可以跳过来。<strong>那么这个问题就转化为跳跃覆盖范围究竟可不可以覆盖到终点！</strong></p><p>每次移动取最大跳跃步数（得到最大的覆盖范围），每移动一个单位，就更新最大覆盖范围。</p><img src="https://img.imgdd.com/63b05c6b-9c8b-437f-a901-a3129e2f2e16.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p><strong>局部最优解：每次取最大跳跃步数（最大覆盖范围）</strong></p><p><strong>全局最优解：最后得到整体最大覆盖范围，看能否到达终点</strong></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><p>思路讲完了，但是我相信很多人和我一样还有有个疑惑，那就是代码怎么写？</p><ol><li>i每次只能在cover的范围内移动，每移动一个元素，cover就得到该元素数值（新的覆盖范围）的补充，让 i 继续移动下去。</li><li>cover每次只取max(该元素数值补充后的范围, cover本身范围)。</li><li>如果cover大于等于终点下标，表明覆盖范围可以覆盖终点。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;          <span class="comment">//cover表示可以遍历到的最大范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt;= cover;i++) &#123;</span><br><span class="line">            cover = <span class="built_in">max</span>(i + nums[i],cover);</span><br><span class="line">            <span class="keyword">if</span>(cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-45-跳跃游戏II"><a href="#LeetCode-45-跳跃游戏II" class="headerlink" title="LeetCode 45 跳跃游戏II"></a>LeetCode 45 跳跃游戏II</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/jump-game-ii">45.跳跃游戏II</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>很多人会想，既然要求最小跳跃次数，那我们每次都跳最远不就可以了，这当然不行，例如：<code>2,3,1,1,4</code>。<a href="https://leetcode.cn/problems/jump-game">55.跳跃游戏</a>讲过覆盖范围的概念，<strong>我们每一步都要尽可能多的增加覆盖范围，覆盖范围一旦覆盖了终点，得到就是最小步数。</strong> 简单来说就是，<strong>我们要在当前覆盖范围内找到最大的元素值作为下一跳的起始点</strong></p><img src="https://img.imgdd.com/7bf0b42c-51e4-43c1-ada2-46614e34453c.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p>例如<code>2,3,1,1,4</code>，第一个元素是2，它的覆盖范围是<code>2,3,1</code>，此时覆盖范围没有包括终点，那么就要有下一跳，我们找到当前覆盖范围<code>2,3,1</code>内的最大元素是3，让它成为下一跳的起始点，这是的覆盖范围就是<code>2,3,1,1,4</code>，恰好覆盖了终点，所以最小跳跃次数是2</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><p>现在又是老问题，思路有了，代码怎么写？</p><p>从上图可以看出来，就是移动下标达到了当前覆盖的最远距离下标时，步数就要加一，来增加覆盖距离。最后的步数就是最少步数。这里还是有个特殊情况需要考虑，当移动下标达到了当前覆盖的最远距离下标时</p><ul><li>如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。</li><li>如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> curDistance = <span class="number">0</span>;        <span class="comment">//当前覆盖最远下标</span></span><br><span class="line">        <span class="type">int</span> nextDistance = <span class="number">0</span>;       <span class="comment">//下一步覆盖最远范围</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            nextDistance = <span class="built_in">max</span>(i + nums[i],nextDistance);</span><br><span class="line">            <span class="keyword">if</span>(i == curDistance) &#123;          <span class="comment">//遇到当前覆盖最远距离下标</span></span><br><span class="line">                <span class="keyword">if</span>(curDistance != nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;    <span class="comment">//还未覆盖终点，需要更新下一步</span></span><br><span class="line">                    count++;</span><br><span class="line">                    curDistance = nextDistance;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(nextDistance &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-1005-K次取反后最大化的数组和"><a href="#LeetCode-1005-K次取反后最大化的数组和" class="headerlink" title="LeetCode 1005 K次取反后最大化的数组和"></a>LeetCode 1005 K次取反后最大化的数组和</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations">1005.K次取反后最大化的数组和</a></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><ol><li>将数组进行升序排序后，从前向后遍历数组，利用贪心的思想，我们只把负数进行取反，同时k–。</li><li>当负数全部取反后，如果k仍大于0并且是偶数，那就不需要改变结果，直接返回，因为对最小的正数取偶数次反，结果保持不变；如果k仍大于0并且是奇数，那么就将最小正数取反</li><li>求和</li></ol><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span> &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i] = nums[i] * (<span class="number">-1</span>);</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = <span class="built_in">min_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">            *it *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums) result += i;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法part01</title>
      <link href="/posts/25023.html"/>
      <url>/posts/25023.html</url>
      
        <content type="html"><![CDATA[<h1 id="贪心理论基础"><a href="#贪心理论基础" class="headerlink" title="贪心理论基础"></a>贪心理论基础</h1><h2 id="什么是贪心"><a href="#什么是贪心" class="headerlink" title="什么是贪心"></a>什么是贪心</h2><p><strong>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</strong></p><p>这么说有点抽象，来举一个例子：例如，有一堆钞票，你可以拿走十张，如果想达到最大的金额，你要怎么拿？</p><p>指定每次拿最大的，最终结果就是拿走最大数额的钱。每次拿最大的就是局部最优，最后拿走最大数额的钱就是推出全局最优。</p><h2 id="什么时候用贪心"><a href="#什么时候用贪心" class="headerlink" title="什么时候用贪心"></a>什么时候用贪心</h2><p>很多同学做贪心的题目的时候，想不出来是贪心，想知道有没有什么套路可以一看就看出来是贪心。<strong>说实话贪心算法并没有固定的套路</strong> ，所以唯一的难点就是如何通过局部最优，推出整体最优。</p><p>那么如何能看出局部最优是否能推出整体最优呢？有没有什么固定策略或者套路呢？<strong>不好意思，也没有！</strong> 靠自己手动模拟，如果模拟可行，就可以试一试贪心策略，如果不可行，可能需要动态规划。</p><p>有同学问了如何验证可不可以用贪心算法呢？<strong>最好用的策略就是举反例，如果想不到反例，那么就试一试贪心吧。</strong></p><hr><h1 id="LeetCode-455-分发饼干"><a href="#LeetCode-455-分发饼干" class="headerlink" title="LeetCode 455 分发饼干"></a>LeetCode 455 分发饼干</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/assign-cookies">455.分发饼干</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有两种方式，可以将大尺寸的饼干优先满足胃口大的孩子，也可将尺寸小的饼干优先满足胃口小的孩子。<strong>这里的局部最优就是大饼干（小饼干）喂给胃口大（胃口小）的孩子，充分利用饼干尺寸喂饱一个，全局最优就是喂饱尽可能多的小孩。</strong></p><p>我采用了尺寸小的饼干优先满足胃口小的孩子的方式。先将饼干数组和小孩数组升序排序。然后从前向后遍历小孩数组，用小饼干优先满足胃口小的，并统计满足小孩数量。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> gIndex = <span class="number">0</span>, sIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(),g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">while</span>(gIndex &lt; g.<span class="built_in">size</span>() &amp;&amp; sIndex &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[sIndex] &gt;= g[gIndex]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                sIndex++;</span><br><span class="line">                gIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-376-摆动序列"><a href="#LeetCode-376-摆动序列" class="headerlink" title="LeetCode 376 摆动序列"></a>LeetCode 376 摆动序列</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/wiggle-subsequence">376.摆动序列</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>本题要求通过原始序列中删除（也可以不删除）一些元素来获得子序列，剩下的元素保持其原始序列。相信这么一说会吓到不少人，我们要怎么分析问题？如何删除元素？删除什么样的元素？</p><p>用示例2来举例，可以绘制出下图：</p><p><a href=""></a></p><p><strong>局部最优：对于单调坡度上的点，只有两个局部峰值，即首位端点</strong></p><p><strong>全局最优：整个序列是由多个单调坡度（单调增&#x2F;单调减）构成，这就有多个局部峰值，从而达到最长摆动序列</strong></p><p>当然，我们并不需要真的删除节点，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）。<strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong></p><p><a href=""></a></p><p>根据上图所示，判断两个峰值的代码可以这样写：<code>if((preDiff &lt; 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt; 0 &amp;&amp; curDiff &lt; 0))</code></p><p>这是我们思考本题的一个大体思路，但本题要考虑三种情况：</p><ol><li>情况一：上下坡中有平坡</li><li>情况二：数组首尾两端</li><li>情况三：单调坡中有平坡</li></ol><h3 id="情况一：上下坡中有平坡"><a href="#情况一：上下坡中有平坡" class="headerlink" title="情况一：上下坡中有平坡"></a>情况一：上下坡中有平坡</h3><p><a href=""></a></p><p>它的摇摆序列长度是3，即<code>1 2 1</code>，也就是我们在删除的时候 要不删除左面的量个2，要不就删除右边的量个2。如图，可以统一规则，删除左边的两个2：</p><p><a href=""></a></p><p>在图中，当i指向第一个2的时候，此时<code>preDiff &gt; 0 &amp;&amp; curDiff == 0</code>，当i指向最后一个2的时候，此时<code>preDiff == 0 &amp;&amp; curDiff &lt; 0</code>。我们既然要保留最后一个2，那么preDiff可以等于0，此时判断峰值的代码就可以改成：<code>if((preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0))</code></p><h3 id="情况二：数组首尾两端"><a href="#情况二：数组首尾两端" class="headerlink" title="情况二：数组首尾两端"></a>情况二：数组首尾两端</h3><p>我们可以从判断峰值的代码看出，判断一个峰值需要三个元素，如果此时只有两个元素的话，我们应该怎么判断？</p><p><a href=""></a></p><p>可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？之前我们在讨论情况一的时候，<code>prediff = 0,curdiff &lt; 0</code>或者 <code>&gt; 0</code> 也记为波谷。那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 preDiff &#x3D; 0，如图：</p><p><a href=""></a></p><p>当然，还有另外一种更直观的方法，那就是将含有两个元素的数组进行单独判断，如果两个元素不一样，那就是两个峰值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[<span class="number">0</span>] != nums[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过以上分析后，我们可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] != nums[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>;        <span class="comment">//当前的一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>;        <span class="comment">//前一对差值</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>;i++) &#123;    <span class="comment">//i最终指向的是倒数第二个元素</span></span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span>((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            preDiff = curDiff;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="情况三：单调坡中有平坡"><a href="#情况三：单调坡中有平坡" class="headerlink" title="情况三：单调坡中有平坡"></a>情况三：单调坡中有平坡</h3><p>在版本一中，我们忽略了一种情况，即如果在一个单调坡度上有平坡，例如[1,2,2,2,3,4]，如图：</p><p><a href=""></a></p><p>图中，我们可以看出，版本一的代码在三个地方记录峰值，但其实结果因为是2，因为<strong>单调中的平坡</strong>不能算峰值（即摆动）。</p><p>之所以版本一会出问题，是因为我们实时更新了prediff。那么我们应该什么时候更新prediff呢？</p><p><strong>我们只需要在这个坡度摆动变化的时候，更新prediff就行，这样prediff在单调区间有平坡的时候就不会发生变化，造成我们的误判。</strong></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[<span class="number">0</span>] != nums[<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> curDiff = <span class="number">0</span>;        <span class="comment">//当前的一对差值</span></span><br><span class="line">        <span class="type">int</span> preDiff = <span class="number">0</span>;        <span class="comment">//前一对差值</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>;i++) &#123;    <span class="comment">//i最终指向的是倒数第二个元素</span></span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">if</span>((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                preDiff = curDiff;      <span class="comment">//只有在摆动点才更新preDiff</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其实本题看起来好像简单，但需要考虑的情况还是很复杂的，而且很难一次性想到位。</p><h1 id="LeetCode-53-最大子数组和"><a href="#LeetCode-53-最大子数组和" class="headerlink" title="LeetCode 53 最大子数组和"></a>LeetCode 53 最大子数组和</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/maximum-subarray">53.最大子数组和</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>思路其实很简单，既然我们要使子数组的和最大，那么我们肯定是要避免取负数。只要取到的连续元素依然是正数，那么它就会对后面的元素起到增大总和的作用。</p><p>从局部最优的视角来看，我们在连续子数组中开始计数时就不能从负数开始，因为负数会使我们的和变小；从代码角度上来讲：遍历nums，从头开始用sum累积，一旦sum加上nums[i]变为负数，那么就应该从nums[i+1]开始从0累积sum，因为已经变为负数的sum，只会拖累总和。</p><p><strong>这相当于是暴力解法中的不断调整最大子序和区间的起始位置。</strong></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxSum = INT32_MIN, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; maxSum) &#123;</span><br><span class="line">                maxSum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>独占的智能指针</title>
      <link href="/posts/8843.html"/>
      <url>/posts/8843.html</url>
      
        <content type="html"><![CDATA[<p>C++中没有回收机制，必须要手动释放分配到的内存，否则就会造成内存泄漏，解决这个问题最有效的方法是使用智能指针（smart pointer）。<code>智能指针是指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</code></p><p>C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件<code>&lt;memory&gt;</code>：</p><ul><li><code>std::shared_ptr：</code>共享的智能指针</li><li><code>std::unique_ptr：</code>独占的智能指针</li><li><code>std::weak_ptr：</code>弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。</li></ul><h1 id="unique-ptr的初始化"><a href="#unique-ptr的初始化" class="headerlink" title="unique_ptr的初始化"></a>unique_ptr的初始化</h1><p><code>std::unique_ptr</code>是一个独占型的智能指针，<code>它不允许其他的智能指针共享其内部的指针，可以通过它的构造函数初始化一个独占智能指针对象，但是不允许通过赋值将一个unique_ptr赋值给另一个unique_ptr</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过构造函数初始化对象</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line"><span class="comment">//unique_ptr&lt;int&gt;ptr2 = ptr1;//error</span></span><br></pre></td></tr></table></figure><p><code>std::unique_ptr</code>不允许复制，但是可以通过函数返回给其他的std::unique_ptr，还可以通过<code>std::move</code>来转译给其他的std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">520</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line"><span class="comment">//转移所有权</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;ptr3 = <span class="built_in">func</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::unique_ptr</code>独占的智能指针也有<code>reset</code>方法，使用reset方法可以让unique_ptr解除对原始内存的管理，也可以用来初始化一个独占的智能指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">ptr<span class="number">1.</span><span class="built_in">reset</span>();<span class="comment">//解除对原始内存的管理，该内存引用计数变为0</span></span><br><span class="line">ptr<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));<span class="comment">//重新指定智能指针管理的原始内存</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要获取独占的智能指针的原始对象，可以调用get方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line"><span class="type">int</span>* p = ptr<span class="number">1.</span><span class="built_in">get</span>();</span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h1 id="删除器"><a href="#删除器" class="headerlink" title="删除器"></a>删除器</h1><p><code>unique_ptr</code>指定删除器和<code>shared_ptr</code>指定删除器还是有区别的，unique_ptr指定删除器的时候需要确定删除器的类型，所以不能像shared_ptr那样直接指定删除器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [](<span class="type">int</span>* p) &#123; <span class="keyword">delete</span> p; &#125;);<span class="comment">//ok</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr2</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [](<span class="type">int</span>* p) &#123; <span class="keyword">delete</span> p; &#125;);<span class="comment">//error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt;<span class="built_in">ptr2</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span> p; &#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，func_ptr的类型和lambda表达式的类型是一致的。在lambda表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [&amp;](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;<span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中错误原因是这样的，在lambda表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用对象包装器来处理声明的函数指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [&amp;](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法part04</title>
      <link href="/posts/35839.html"/>
      <url>/posts/35839.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法part03</title>
      <link href="/posts/18878.html"/>
      <url>/posts/18878.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-93-复原IP地址"><a href="#LeetCode-93-复原IP地址" class="headerlink" title="LeetCode 93 复原IP地址"></a>LeetCode 93 复原IP地址</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/restore-ip-addresses">93.复原IP地址</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和<a href="https://leetcode.cn/problems/palindrome-partitioning">131.分割回文串</a>一样，属于切割问题，该问题可以抽象为树形结构，如下图所示：</p><img src="https://img.imgdd.com/573fbd72-37a5-4830-bed1-8978986fd04c.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p>接着就是递归&#x2F;回溯三要素分析：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 和前面的组合问题类似，startIndex是一定需要的，记录下一层递归分割的起始位置。此外，我们还需要一个变量pointNum，记录添加逗点的数量，这个变量在判断终止条件的时候就能体现其作用了</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string s, <span class="type">int</span> startIndex, <span class="type">int</span> pointNum)</span> </span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong>  本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件，此时，之前的pointNum变量为3时就说明了字符串分成了四段，然后验证一下第四段是否合法，如果合法就加入结果集。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(poinNum == <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isValid</span>(s,startIndex,s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">      result.<span class="built_in">push_back</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 这里需要注意一下，我们不能像前面的组合问题一样，把终止条件写成<code>startIndex &gt;= s.size()</code>，如果这样写，就没法控制<code>.</code>的数量了，那可能就会求得<code>2.5.5.2.5.5</code>这样的非法IP了</p></li><li><p><strong>确定单层递归的逻辑：</strong> 在<code>for(int i = startIndex;i &lt; s.size();i++)</code>循环中<code>[startIndex,i]</code>这个区间就是截取的子串，需要判断这个子串是否合法。如果合法就在字符串后面加上符号.表示已经分割；如果不合法就结束本层循环，如图中剪掉的分支：</p> <img src="https://img.imgdd.com/ed8f1fc4-301f-4944-b95a-8b5aa91e8b49.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p> 然后就是递归和回溯的过程：递归调用时，下一层递归的startIndex要从i+2开始（因为需要在字符串中加入了分隔符.），同时记录分割符的数量pointNum要+1。回溯的时候，就将刚刚加入的分隔符. 删掉就可以了，pointNum也要-1。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt; s.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isValid</span>(s,startIndex,i)) &#123;</span><br><span class="line">      s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">      poinNum++;</span><br><span class="line">      <span class="built_in">backtracking</span>(s,i + <span class="number">2</span>,poinNum);</span><br><span class="line">      poinNum--;</span><br><span class="line">      s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="判断子串是否合法"><a href="#判断子串是否合法" class="headerlink" title="判断子串是否合法"></a>判断子串是否合法</h2><p>主要考虑到如下三点：</p><ul><li>段位以0为开头的数字不合法</li><li>段位里有非正整数字符不合法</li><li>段位如果大于255了不合法</li></ul><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s,<span class="type">int</span> start,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt; end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = start;i &lt;= end;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        num = num * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num &gt; <span class="number">255</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s,<span class="type">int</span> start,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s[start] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; start != end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start;i &lt;= end;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            num = num * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string s, <span class="type">int</span> startIndex, <span class="type">int</span> poinNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(poinNum == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(s,startIndex,s.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt; s.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isValid</span>(s,startIndex,i)) &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                poinNum++;</span><br><span class="line">                <span class="built_in">backtracking</span>(s,i + <span class="number">2</span>,poinNum);</span><br><span class="line">                poinNum--;</span><br><span class="line">                s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>() + i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">4</span> || s.<span class="built_in">size</span>() &gt; <span class="number">12</span>) <span class="keyword">return</span> result;   <span class="comment">//剪枝</span></span><br><span class="line">        <span class="built_in">backtracking</span>(s,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-78-子集"><a href="#LeetCode-78-子集" class="headerlink" title="LeetCode 78 子集"></a>LeetCode 78 子集</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/subsets">78.子集</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>如果把子集问题、组合问题、分割问题都抽象为一棵树的话，那么<strong>组合问题和分割问题都是收集树的叶子节点</strong>，而<strong>子集问题是找树的所有节点！</strong></p><p>其实子集也是一种组合问题，因为它的集合是无序的，子集{1,2}和子集{2,1}是一样的。<strong>那么既然是无序，取过的元素不会重复取，写回溯算法的时候，for就要从startIndex开始，而不是从0开始！</strong></p><p>以示例中nums&#x3D;[1,2,3]为例把求子集抽象为树型结构，如下：</p><img src="https://img.imgdd.com/0c1e3862-995b-4564-b5d8-283a1abf7a51.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p>接着就是递归&#x2F;回溯三要素进行分析：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 全局变量数组path为子集收集元素，二维数组result存放子集组合。递归函数参数在上面讲到了，需要startIndex。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startIndex)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 从刚才的树形结构图也能看出，我们在每一层起始时刻就需要收集结果了。当剩余集合为空的时候，可以回溯，<strong>那什么时候剩余集合为空呢？</strong> 当然时startIndex已经大于数组的长度了就终止</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">if</span>(startIndex &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树。</strong> </p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(nums,i + <span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-90-子集II"><a href="#LeetCode-90-子集II" class="headerlink" title="LeetCode 90 子集II"></a>LeetCode 90 子集II</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/subsets-ii">90.子集II</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>和<a href="https://leetcode.cn/problems/subsets">78.子集</a>类似，就是在此基础上增加了一个去重操作，我们可以先把树形结构图绘制出来</p><img src="https://img.imgdd.com/eac714f2-1d97-4e76-a305-dbaf145049b6.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p>从图中可以看出，同一树层上重复取2就要过滤掉，同一树枝上就可以重复取2，因为同一树枝上元素的集合才是唯一子集！我们把同一树层的去重称为<strong>树层去重</strong>，同一树枝的去重称为<strong>数值去重</strong>，这题明显就是树层去重。</p><p>这里直接给出去重的代码，因为这部分比较抽象，还需要大家多多动手模拟去重的过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归&#x2F;回溯三要素和<a href="https://leetcode.cn/problems/subsets">78.子集</a>一样，此处不再分析</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> startIndex,vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="comment">//树层去重</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">backtracking</span>(nums,i + <span class="number">1</span>,used);</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt;<span class="built_in">used</span>(nums.<span class="built_in">size</span>(),<span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(nums,<span class="number">0</span>,used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法part02</title>
      <link href="/posts/35199.html"/>
      <url>/posts/35199.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-39-组合总和"><a href="#LeetCode-39-组合总和" class="headerlink" title="LeetCode 39 组合总和"></a>LeetCode 39 组合总和</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/combination-sum">39.组合总和</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本题和<a href="https://leetcode.cn/problems/combinations">77.组合</a>和<a href="https://leetcode.cn/problems/combination-sum-iii">216.组合总和III</a>的区别是：本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。</p><p>接着就是递归&#x2F;回溯三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 依旧是定义两个全局变量，二维数组result存放结果集，数组path存放符合条件的结果。然后传入参数，数组candidates、目标值target、保存求和值sum以及startIndex。</p><p> <strong>对于组合问题，什么时候需要startIndex呢？</strong> 我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如：<a href="https://leetcode.cn/problems/combinations">77.组合</a>和<a href="https://leetcode.cn/problems/combination-sum-iii">216.组合总和III</a>。如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：<a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number">17.电话号码的数字组合</a></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> sum, <span class="type">int</span> startIndex)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 终止只有两种情况，sum大于target和sum等于target。其中，sum等于target的时候，需要收集结果，代码如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 单层for循环依然是从startIndex开始，搜索candidates集合。注意本题和<a href="https://leetcode.cn/problems/combinations">77.组合</a>和<a href="https://leetcode.cn/problems/combination-sum-iii">216.组合总和III</a>的区别是：本题元素为可重复选取的。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target;i++) &#123;</span><br><span class="line">    sum += candidates[i];</span><br><span class="line">    path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(candidates,target,sum,i);  <span class="comment">// 关键点:不用i+1了，表示可以重复读取当前的数</span></span><br><span class="line">    sum -= candidates[i];</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,<span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt; candidates.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates,target,sum,i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>我们可以通过手动模拟得出，对于sum已经大于target的情况，依然会进入下一层递归，只是下一层递归结束判断的时候，会判断sum &gt; target的话就返回。</p><p>如果我们已经知道下一层的sum会大于target，就没有必要进入下一层递归了，那么就可以在for循环的搜索范围上做做文章。<strong>对总集合排序之后，如果下一层的sum（就是本层的 sum + candidates[i]）已经大于target，就可以结束本轮for循环的遍历。</strong></p><p>for循环剪枝代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target;i++) </span><br></pre></td></tr></table></figure><p>剪枝优化后的完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates,<span class="type">int</span> target,<span class="type">int</span> sum,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target;i++) &#123;</span><br><span class="line">            sum += candidates[i];</span><br><span class="line">            path.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates,target,sum,i);</span><br><span class="line">            sum -= candidates[i];</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());  <span class="comment">//排序</span></span><br><span class="line">        <span class="built_in">backtracking</span>(candidates,target,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-131-分割回文串"><a href="#LeetCode-131-分割回文串" class="headerlink" title="LeetCode 131 分割回文串"></a>LeetCode 131 分割回文串</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/palindrome-partitioning">131.分割回文串</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们来分析一下切割，<strong>其实切割问题类似组合问题。</strong></p><p>例如字符串abcdef：</p><ul><li>组合问题：选取一个a之后，在bcdef中在选取第二个，选取b之后再cdef中再选取第三个…</li><li>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中再切割第三段…</li></ul><p>所以切割问题也可以抽象为一个树形结构，如图：</p><img src="https://img.imgdd.com/d1f69acc-3cdf-472a-bd3e-6bde945db757.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p>递归用来纵向遍历，for循环用来横向遍历，切割线（就是图中的红线）切割到字符串的结尾位置，说明找到了一个切割方法。此时可以发现，切割问题的回溯搜索的过程和组合问题的回溯搜索的过程是差不多的。</p><p>接着就是递归&#x2F;回溯三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 全局变量数组path存放切割后回文的子串，二维数组result存放结果集。此外，还需要设置形参startIndex，因为切割过的地方，不能重复切割，和组合问题也是保持一致的。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt;result;</span><br><span class="line">vector&lt;string&gt;path;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span> <span class="params">(<span class="type">const</span> string s, <span class="type">int</span> startIndex)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件</strong></p> <img src="https://img.imgdd.com/d1f69acc-3cdf-472a-bd3e-6bde945db757.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p> 从树形结构的图中可以看出：切割线切到了字符串最后面，说明找到了一种切割方法，此时就是本层递归的终止条件。<strong>那么切割线在代码里怎么表示？</strong></p><p> 在处理组合问题的时候，递归参数需要传入startIndex，表示下一轮递归遍历的起始位置，这个startIndex就是切割线。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 在<code>for(int i = startIndex; i &lt; s.size(); i++)</code>循环中，我们定义了起始位置startIndex，那么<code>[startIndex,i]</code>就是要截取的子串。首先判断这个子串是不是回文，如果是回文，就加入在path中，path用来记录切割过的回文子串。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt; s.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isPalindrome</span>(s,startIndex,i)) &#123;</span><br><span class="line">        string subStr = s.<span class="built_in">substr</span>(startIndex,i-startIndex<span class="number">+1</span>);</span><br><span class="line">        path.<span class="built_in">push_back</span>(subStr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">backtracking</span>(s,i + <span class="number">1</span>);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>注意切割过的位置，不能重复切割，所以，backtracking(s,i + 1); 传入下一层的起始位置为i + 1</strong></p></li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string s,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(startIndex &gt;= s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt; s.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isPalindrome</span>(s,startIndex,i)) &#123;</span><br><span class="line">                string subStr = s.<span class="built_in">substr</span>(startIndex,i-startIndex<span class="number">+1</span>);</span><br><span class="line">                path.<span class="built_in">push_back</span>(subStr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">backtracking</span>(s,i + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(string s,<span class="type">int</span> start,<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start,j = end;i &lt; j;i++,j--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != s[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt;path;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>共享智能指针</title>
      <link href="/posts/26838.html"/>
      <url>/posts/26838.html</url>
      
        <content type="html"><![CDATA[<p>C++中没有回收机制，必须要手动释放分配到的内存，否则就会造成内存泄漏，解决这个问题最有效的方法是使用智能指针（smart pointer）。<code>智能指针是指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</code></p><p>C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件<code>&lt;memory&gt;</code>：</p><ul><li><code>std::shared_ptr：</code>共享的智能指针</li><li><code>std::unique_ptr：</code>独占的智能指针</li><li><code>std::weak_ptr：</code>弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。</li></ul><h1 id="shared-ptr的初始化"><a href="#shared-ptr的初始化" class="headerlink" title="shared_ptr的初始化"></a>shared_ptr的初始化</h1><p>共享智能指针是指多个智能指针同时管理同一块有效的内存，共享智能指针<code>shared_ptr</code>是一个模板类，有三种初始化方式：<code>通过构造函数、std::make_shared辅助函数以及reset方法</code>。共享智能指针对象初始化完毕之后就指向了要管理的那块堆内存，如果想要查看当前有多少个智能指针同时管理着这块内存可以使用共享智能指针提供的一个成员函数<code>use_count</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr&lt;T&gt; 类模板中，提供了多种实用的构造函数, 语法格式如下:</span></span><br><span class="line">std::shared_ptr&lt;T&gt; 智能指针名字(创建堆内存);</span><br></pre></td></tr></table></figure><h2 id="通过构造函数初始化"><a href="#通过构造函数初始化" class="headerlink" title="通过构造函数初始化"></a>通过构造函数初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用智能指针管理一块内存空间</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1管理的内存空间引用计数: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//使用智能指针管理一块字符数组对应的堆内存</span></span><br><span class="line">shared_ptr&lt;<span class="type">char</span>&gt;<span class="built_in">ptr2</span>(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">12</span>]);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr2管理的内存空间引用引用计数: &quot;</span> &lt;&lt; ptr<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//创建智能指针，不管理任何内存</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;ptr3;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr3管理的内存空间引用引用计数: &quot;</span> &lt;&lt; ptr<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//创建智能指针，初始化为空</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr4</span>(<span class="literal">nullptr</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr4管理的内存空间引用引用计数: &quot;</span> &lt;&lt; ptr<span class="number">4.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptr1管理的内存空间引用计数: <span class="number">1</span></span><br><span class="line">ptr2管理的内存空间引用引用计数: <span class="number">1</span></span><br><span class="line">ptr3管理的内存空间引用引用计数: <span class="number">0</span></span><br><span class="line">ptr4管理的内存空间引用引用计数: <span class="number">0</span></span><br></pre></td></tr></table></figure><p><code>如果智能指针初始化一块有效内存，那么引用计数加1，如果未被初始化或初始化为nullptr，引用计数不会加1。此外，不要使用一个原始指针初始化多个shared_ptr</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr11</span>(p);  <span class="comment">//ok</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr22</span>(p);  <span class="comment">//error，编译不会报错, 运行会出错</span></span><br></pre></td></tr></table></figure><h2 id="通过拷贝构造和移动构造函数初始化"><a href="#通过拷贝构造和移动构造函数初始化" class="headerlink" title="通过拷贝构造和移动构造函数初始化"></a>通过拷贝构造和移动构造函数初始化</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">520</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1管理的内存空间引用计数: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr2</span>(ptr1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr2管理的内存空间引用引用计数: &quot;</span> &lt;&lt; ptr<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;ptr3 = ptr1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr3管理的内存空间引用引用计数: &quot;</span> &lt;&lt; ptr<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//移动构造</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr4</span>(<span class="built_in">move</span>(ptr1));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr4管理的内存空间引用引用计数: &quot;</span> &lt;&lt; ptr<span class="number">4.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;ptr5 = <span class="built_in">move</span>(ptr2);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr5管理的内存空间引用引用计数: &quot;</span> &lt;&lt; ptr<span class="number">5.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ptr1管理的内存空间引用计数: <span class="number">1</span></span><br><span class="line">ptr2管理的内存空间引用引用计数: <span class="number">2</span></span><br><span class="line">ptr3管理的内存空间引用引用计数: <span class="number">3</span></span><br><span class="line">ptr4管理的内存空间引用引用计数: <span class="number">3</span></span><br><span class="line">ptr5管理的内存空间引用引用计数: <span class="number">3</span></span><br></pre></td></tr></table></figure><p><code>如果使用拷贝构造函数初始化共享智能指针对象，这两个对象会共同管理同一块堆内存，该堆内存空间引用增加；如果使用移动构造的方式进行初始化，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。</code></p><h2 id="通过std-make-shared初始化"><a href="#通过std-make-shared初始化" class="headerlink" title="通过std::make_shared初始化"></a>通过std::make_shared初始化</h2><p>通过<code>std::make_shared</code>就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span>... _Types&gt;</span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_shared</span><span class="params">(_Types&amp;&amp;... _Args)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>T</code>: 模板参数的数据类型</li><li><code>_Types&amp;&amp;... _Args</code>: 待初始化的数据，如果是通过make_shared创建对象，需按照构造函数的参数列表指定</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(string str) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Test</span>() &#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;destruct Test ...&quot; &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1管理的内存空间引用计数: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">shared_ptr&lt;Test&gt;ptr2 = <span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr2管理的内存空间引用计数: &quot;</span> &lt;&lt; ptr<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//初始化Test里int型的有参构造函数</span></span><br><span class="line">shared_ptr&lt;Test&gt; ptr3 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">520</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//初始化Test里string型的有参构造函数</span></span><br><span class="line">shared_ptr&lt;Test&gt; ptr4 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;我是要成为海贼王的男人!!!&quot;</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr<span class="number">4.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ptr1管理的内存空间引用计数: <span class="number">1</span></span><br><span class="line">construct Test...</span><br><span class="line">ptr2管理的内存空间引用计数: <span class="number">1</span></span><br><span class="line">construct Test, x = <span class="number">520</span></span><br><span class="line">ptr3管理的内存引用计数: <span class="number">1</span></span><br><span class="line">construct Test, str = 我是要成为海贼王的男人!!!</span><br><span class="line">ptr4管理的内存引用计数: <span class="number">1</span></span><br></pre></td></tr></table></figure><p><code>使用std::make_shared模板函数可以完成内存地址的创建，并将得到的内存空间地址传递给共享智能指针对象进行管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。</code></p><h2 id="通过reset方法初始化"><a href="#通过reset方法初始化" class="headerlink" title="通过reset方法初始化"></a>通过reset方法初始化</h2><p><code>std::shared_ptr::reset</code>方法可以重置指针或使指针重新指向一块新的内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1管理的内存空间引用计数: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">ptr<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1管理的内存空间引用计数: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"><span class="comment">//ptr1最开始指向的是int类型的空间，调用reset方法只能重新指向新的int类型空间</span></span><br><span class="line"><span class="comment">//ptr1.reset(new int(13));error</span></span><br><span class="line">ptr<span class="number">1.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">13</span>));</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ptr1管理的内存空间引用计数: &quot;</span> &lt;&lt; ptr<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr1管理的内存空间引用计数: <span class="number">1</span></span><br><span class="line">ptr1管理的内存空间引用计数: <span class="number">0</span></span><br><span class="line">ptr1管理的内存空间引用计数: <span class="number">1</span></span><br></pre></td></tr></table></figure><h2 id="获取原始指针"><a href="#获取原始指针" class="headerlink" title="获取原始指针"></a>获取原始指针</h2><p>通过智能指针可以管理一个普通变量或者对象的地址，此时原始地址就不可见了。当我们想要修改变量或者对象中的值的时候，就需要从智能指针对象中先取出数据的原始内存的地址再操作，解决方案是调用共享智能指针类提供的get()方法，其函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">m_value = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; m_value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//方法一：获取原始指针</span></span><br><span class="line">shared_ptr&lt;Test&gt;ptr1 = <span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">Test* t = ptr<span class="number">1.</span><span class="built_in">get</span>();</span><br><span class="line">t-&gt;<span class="built_in">setValue</span>(<span class="number">1000</span>);</span><br><span class="line">t-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">ptr1-&gt;<span class="built_in">setValue</span>(<span class="number">999</span>);</span><br><span class="line">ptr1-&gt;<span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">construct Test...</span><br><span class="line"><span class="number">1000</span></span><br><span class="line"><span class="number">999</span></span><br></pre></td></tr></table></figure><p><code>shared_ptr</code>本身就是一个函数模板，我们可以通过<code>.</code>调用这个函数模板里的<code>get</code>方法获取原始指针；当然，我们也可以不使用函数模板里的方法，直接通过<code>-&gt;</code>调用Test对象里的成员函数</p><h1 id="指定删除器"><a href="#指定删除器" class="headerlink" title="指定删除器"></a>指定删除器</h1><p>当智能指针管理的内存对应的引用计数变为0的时候，这块内存就被智能指针析构掉了。另外，我们在初始化智能指针的时候可以自己指定删除动作，这个删除操作对应的函数被称之为删除器。这个删除器函数本质是一个回调函数，我们只需要进行实现，其调用是由智能指针完成的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int型内存被释放了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>), func);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，这个回调函数也可以是lambda表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>), [](<span class="type">int</span>* p) &#123;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int型内存被释放了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>lambda表达式的参数就是智能指针管理的内存的地址，有了这个地址之后函数体内部就可以完成删除操作了。</code></p><p>在C++11中<code>使用shared_ptr管理动态数组时，需要指定删除器</code>，<code>因为std::shared_ptr的默认删除器不支持数组对象</code>，具体的处理代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>],[](<span class="type">int</span>* p) &#123;</span><br><span class="line"><span class="keyword">delete</span>[]p; </span><br><span class="line">&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在删除数组内存时，除了自己编写删除器，也可以使用C++提供的<code>std::default_delete&lt;T&gt;()</code>函数作为删除器，这个函数内部的删除功能也是通过调用<code>delete</code>来实现的，要释放什么类型的内存就将模板类型T指定为什么类型即可。具体处理代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">ptr</span>(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>],<span class="built_in">default_delete</span>&lt;<span class="type">int</span>[]&gt;());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法part01</title>
      <link href="/posts/34879.html"/>
      <url>/posts/34879.html</url>
      
        <content type="html"><![CDATA[<h1 id="回溯理论基础"><a href="#回溯理论基础" class="headerlink" title="回溯理论基础"></a>回溯理论基础</h1><p>回溯法也可以叫做回溯搜索法，它是一种搜索的方式。<strong>回溯是递归的副产品，只要有递归就会有回溯</strong></p><h2 id="回溯法的效率"><a href="#回溯法的效率" class="headerlink" title="回溯法的效率"></a>回溯法的效率</h2><p>虽然回溯法很难，很不好理解，但是回溯法并不是什么高效的算法。它的本质就是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p><h2 id="回溯法解决的问题"><a href="#回溯法解决的问题" class="headerlink" title="回溯法解决的问题"></a>回溯法解决的问题</h2><p>回溯法，一般可以解决如下几种问题：</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>这里需要注意一下，<strong>组合是不强调元素顺序的，排列是强调元素顺序。</strong> 例如：{1,2}和{2,1}在组合问题上是一种结果，但是在排列问题上则是两种结果</p><h2 id="如何理解回溯法"><a href="#如何理解回溯法" class="headerlink" title="如何理解回溯法"></a>如何理解回溯法</h2><p>回溯法可以**抽象成一个图（树）形结构：**递归一定是有终止的。可以抽象成N叉树，树的宽度就是每个节点处理的集合大小，用for循环遍历。树的深度，用递归来处理。（很像层序遍历加上处理节点和回溯的操作）</p><h2 id="回溯法模板"><a href="#回溯法模板" class="headerlink" title="回溯法模板"></a>回溯法模板</h2><p>回溯法可以使用递归三要素进行分析：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 回溯算法中函数返回值一般为void。再来看一下参数，因为回溯算法需要的参数可不像二叉树递归的时候那么容易一次性确定下来，所以一般是先写逻辑，然后需要什么参数，就填什么参数。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 什么时候达到了终止条件，树中就可以看出，一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">    存放结果;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 在上面我们提到了，回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p> <img src="https://img.imgdd.com/efb04144-907d-48e0-976e-9a8f081650aa.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p> 回溯函数遍历过程伪代码如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">    处理节点;</span><br><span class="line">    <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">    回溯，撤销处理结果</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。backtracking这里自己调用自己，实现递归。</p><p> 大家可以从图中看出for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p><p> 分析完过程，回溯算法模板框架如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        <span class="built_in">backtracking</span>(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="LeetCode-77-组合"><a href="#LeetCode-77-组合" class="headerlink" title="LeetCode 77 组合"></a>LeetCode 77 组合</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/combinations">77.组合</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们将该问题抽象成如下树形结构：</p><img src="https://img.imgdd.com/be2c5ab9-c626-41d8-92e9-ae4f7549bb68.jpg" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p>可以看出这棵树最开始的集合是{1,2,3,4}，从左向右取数，取过数不会再重复取。第一次取1，集合变为{2,3,4}，因为k为2，我们还需要在集合里再取一个数，分别可以取2，3，4，得到集合{1,2},{1,3},{1,4}，以此类推求得其他集合。</p><p><strong>每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。图中可以发现n相当于树的宽度，k相当于树的深度。</strong> 那么如何在这个树上遍历，然后收集到我们要的结果集呢？</p><p><strong>图中每次搜索到了叶子节点，我们就找到了一个结果。</strong> 我们只需要把达到叶子节点的结果收集起来，就可以求得n个数中k个数的组合集合。</p><p>接着又是我们最熟悉的递归&#x2F;回溯三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 首先，在这里要定义两个全局变量，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合（也可以通过引用的形式作为参数传入）。其次，函数里一定有两个参数，既然是集合n里面取k个数，那么n和k是两个int型的参数。最后还需要一个int型参数startIndex，这个参数用来记录本层递归中集合从数组的哪个位置开始遍历。</p><p> 例如，在集合[1,2,3,4]取1之后，下一层递归，就要在[2,3,4]中取数了，那么下一层递归如何知道从[2,3,4]中取数呢，靠的就是startIndex。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;     <span class="comment">// 存放符合条件结果的集合</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;path;               <span class="comment">// 用来存放符合条件单一结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 当我们搜索到叶子节点就表明我们可以收集结果了（加入结果集），那我们怎么知道什么时候搜索到叶子节点？很简单，当path这个数组的大小达到k，说明我们找到了一个子集大小为k的组合了</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> for循环每次从startIndex开始遍历，然后用path保存取到的节点i。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt;= n; i++) &#123;     <span class="comment">// 控制树的横向遍历</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(i);                      <span class="comment">// 处理节点</span></span><br><span class="line">    <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>);              <span class="comment">// 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();                        <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 可以看出backtracking（递归函数）通过不断调用自己一直往深处遍历，总会遇到叶子节点，遇到了叶子节点就要返回。backtracking的下面部分就是回溯的操作了，撤销本次处理的结果。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt;= n;i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtracking</span>(n,k,i<span class="number">+1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剪枝优化"><a href="#剪枝优化" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>举一个例子，n&#x3D;4，k&#x3D;4的话，那么第一层for循环的时候，从元素2开始的遍历都没有意义了。 在第二层for循环，从元素3开始的遍历都没有意义了。这么说有点抽象，如图所示：</p><img src="https://img.imgdd.com/ab6fa68a-716f-4c31-83d0-764ff913af8c.jpg" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p>图中每一个节点（图中为矩形），就代表本层的一个for循环，那么每一层的for循环从第二个数开始遍历的话，都没有意义，都是无效遍历。<strong>所以，可以剪枝的地方就在递归中每一层的for循环所选择的起始位置。如果for循环选择的起始位置之后的元素个数已经不足我们需要的元素个数了，那么就没有必要搜索了。</strong></p><p>所以优化之后的for循环是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>;i++)</span><br></pre></td></tr></table></figure><ol><li>已经选择的元素个数：path.size();</li><li>还需要的元素个数为: k - path.size();</li><li>在集合n中<strong>至多</strong>要从该起始位置 : n - (k - path.size()) + 1，开始遍历</li></ol><p>为什么有个+1呢，因为包括起始位置，我们要是一个左闭的集合。举个例子，n &#x3D; 4，k &#x3D; 3， 目前已经选取的元素为0（path.size为0），n - (k - 0) + 1 即 4 - ( 3 - 0) + 1 &#x3D; 2。从2开始搜索都是合理的，可以是组合[2, 3, 4]。</p><p>这里大家想不懂的话，建议也举一个例子，就知道是不是要+1了。</p><p>优化后整体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//至多从哪个位置开始搜索</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt;= n - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>;i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">backtracking</span>(n,k,i<span class="number">+1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-216-组合总和III"><a href="#LeetCode-216-组合总和III" class="headerlink" title="LeetCode 216 组合总和III"></a>LeetCode 216 组合总和III</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/combination-sum-iii">216.组合总和III</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>和上一题<a href="https://leetcode.cn/problems/combinations">77.组合</a>一样，无非就是多了一个限制，本题是要找到和为n的k个数的组合，而整个集合已经是固定的了[1,…,9]。想到这一点了，做过<a href="https://leetcode.cn/problems/combinations">77.组合</a>之后，本题是简单一些了。</p><p>例如k &#x3D; 2，n &#x3D; 4的话，就是在集合[1,2,3,4,5,6,7,8,9]中求 k &#x3D; 2, n &#x3D; 4的组合。选取过程如图：</p><img src="https://img.imgdd.com/23928fb4-8aee-4d09-95fa-aceae21dccca.png" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p>接着就是回溯&#x2F;递归三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 依旧是定义两个全局变量path和result，一个用来存放符合条件单一结果，一个用来存放符合条件结果的集合。还需要传入n和k以及startIndex，startIndex表示本层递归中集合从数组的哪个位置开始遍历。此外，我们还需要传入int类型的变量sum，它表示已经收集的元素的总和，也就是path里元素的总和。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> startIndex,<span class="type">int</span> sum)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 如果path.size()和k相等了，就可以执行终止逻辑。如果此时path里收集到的元素和（sum）和n相同，就用result收集当前的结果。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(path.<span class="built_in">size</span>() == k &amp;&amp; sum == n) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 处理过程就是path收集每次选取的元素，相当于树型结构里的边，sum来统计path里元素的总和。<strong>别忘了处理过程和回溯过程是一一对应的，处理有加，回溯就要有减！</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt;= <span class="number">9</span>;i++) &#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(i);</span><br><span class="line">    sum += i;</span><br><span class="line">    <span class="built_in">backtracking</span>(k,n,i<span class="number">+1</span>,sum);</span><br><span class="line">    sum -= i;           <span class="comment">//回溯</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();    <span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> startIndex,<span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k &amp;&amp; sum == n) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt;= <span class="number">9</span>;i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="built_in">backtracking</span>(k,n,i<span class="number">+1</span>,sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(k,n,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="剪枝优化-1"><a href="#剪枝优化-1" class="headerlink" title="剪枝优化"></a>剪枝优化</h2><p>如果已选元素总和如果已经大于n了，那么继续往后遍历就没有意义了，可以直接剪掉。那么剪枝的地方可以放在递归函数开始的地方，剪枝代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//剪枝：如果此时path里的和已经大于n了，直接回溯</span></span><br><span class="line"><span class="keyword">if</span>(sum &gt; n) &#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和<a href="https://leetcode.cn/problems/combinations">77.组合</a>一样，or循环的范围也可以剪枝，<code>i &lt;= 9 - (k - path.size()) + 1</code>就可以了。</p><p>剪枝优化后的完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> n,<span class="type">int</span> startIndex,<span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//剪枝：如果此时path里的和已经大于n了，直接回溯</span></span><br><span class="line">        <span class="keyword">if</span>(sum &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == k &amp;&amp; sum == n) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剪枝：至多从哪个位置开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = startIndex;i &lt;= <span class="number">9</span> - (k - path.<span class="built_in">size</span>()) + <span class="number">1</span>;i++) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(i);</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="built_in">backtracking</span>(k,n,i<span class="number">+1</span>,sum);</span><br><span class="line">            sum -= i;</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">backtracking</span>(k,n,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-17-电话号码的数字组合"><a href="#LeetCode-17-电话号码的数字组合" class="headerlink" title="LeetCode 17 电话号码的数字组合"></a>LeetCode 17 电话号码的数字组合</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number">17.电话号码的数字组合</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>理解本题后，要解决如下三个问题：</p><ol><li>数字和字母如何映射</li><li>两个字母就两个for循环，三个字符就三个for循环，以此类推，然后发现代码根本写不出来</li><li>输入1 * #按键等等异常情况</li></ol><h3 id="数字和字母如何映射"><a href="#数字和字母如何映射" class="headerlink" title="数字和字母如何映射"></a>数字和字母如何映射</h3><p>可以使用map或者定义一个二维数组，例如：string letterMap[10]，来做映射，我这里定义一个二维数组，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> string str[<span class="number">10</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;def&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">    <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">    <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">    <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="回溯法解决n个for循环"><a href="#回溯法解决n个for循环" class="headerlink" title="回溯法解决n个for循环"></a>回溯法解决n个for循环</h3><p>例如：输入：”23”，抽象为树形结构，如图所示：</p><img src="https://img.imgdd.com/2dc41360-e1dd-4641-8c15-817975632546.jpg" style="width: 80%; height: 80%; object-fit: cover;display: block; margin: 0 auto;" /><p>图中可以看出遍历的深度，就是输入”23”的长度，而叶子节点就是我们要收集的结果，输出[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]。</p><p>接着就是递归&#x2F;回溯三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 首先需要一个字符串s来收集叶子节点的结果，然后用一个字符串数组result保存起来，这两个变量我依然定义为全局变量。其次，参数指定是有题目中给的string digits，然后还要有一个参数就是int型的index，这个index是记录遍历第几个数字了，就是用来遍历digits的，同时也表示树的深度</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt;result;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">const</span> string digits, <span class="type">int</span> index)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> index表示的是当前遍历到的是第几个数字，如果此时index等于数字个数了（数字遍历完了），就可以收集结果，结束本层递归</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(digits.<span class="built_in">size</span>() == index) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(s);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 首先要取index指向的数字，并找到对应的字符集，然后for循环来处理这个字符集，代码如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">string letters = str[num];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; letters.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">    s.<span class="built_in">push_back</span>(letters[i]);</span><br><span class="line">    <span class="built_in">backtracking</span>(digits,index + <span class="number">1</span>);</span><br><span class="line">    s.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 注意这里for循环，可不像是在回溯算法：<a href="https://leetcode.cn/problems/combination-sum-iii">216.组合总和III</a>和<a href="https://leetcode.cn/problems/combinations">77.组合</a>中从startIndex开始遍历的。</p><p> <strong>因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而<a href="https://leetcode.cn/problems/combination-sum-iii">216.组合总和III</a>和<a href="https://leetcode.cn/problems/combinations">77.组合</a>都是求同一个集合中的组合！</strong></p><p> 最后注意输入1 * #按键等等异常情况，代码中最好考虑这些异常情况的数据，但题目的测试数据中应该没有异常情况的数据，所以我就没有加了。<strong>但是要知道会有这些异常，如果是现场面试中，一定要考虑到！</strong></p></li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(string digits,<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == index) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = digits[index] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        string letters = str[num];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; letters.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(letters[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(digits,index + <span class="number">1</span>);</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">backtracking</span>(digits,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt;result;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">const</span> string str[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转移和转发</title>
      <link href="/posts/52736.html"/>
      <url>/posts/52736.html</url>
      
        <content type="html"><![CDATA[<h1 id="move"><a href="#move" class="headerlink" title="move"></a>move</h1><p>在C++11中，不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助<code>std::move()</code>函数，<code>使用std::move方法可以将左值转换为右值（将亡值）</code>，这个函数并不会移动任何东西，而是和移动构造函数一样都具有移动语义，<code>将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。</code></p><p>使用方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">250</span>;</span><br><span class="line"><span class="type">int</span>&amp; i = a;</span><br><span class="line"><span class="type">int</span>&amp;&amp; j = i;        <span class="comment">// error</span></span><br><span class="line"><span class="type">int</span>&amp;&amp; j = <span class="built_in">move</span>(i);      <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在第四行中，因为i是左值引用，不能对右值引用进行初始化</li><li>在第五行中，使用<code>move()</code>函数将左值转换为右值，这样就可以初始化右值引用了。</li></ul><p>假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt;ls&#123; <span class="string">&quot;jack&quot;</span>,<span class="string">&quot;mike&quot;</span>,<span class="string">&quot;lucy&quot;</span>,<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;huang&quot;</span> &#125;;</span><br><span class="line">list&lt;string&gt;ls1 = ls;            <span class="comment">//需要拷贝，效率低</span></span><br><span class="line">list&lt;string&gt;ls2 = <span class="built_in">move</span>(ls);</span><br></pre></td></tr></table></figure><p>如果不使用<code>move</code>，拷贝的代价很大，性能较低。使用<code>move</code>几乎没有任何代价，只是转换了资源的所有权。如果一个对象内部有较大的堆内存或者动态数组时，使用move()就可以非常方便的进行数据所有权的转移。</p><h1 id="forward"><a href="#forward" class="headerlink" title="forward"></a>forward</h1><p>右值引用类型是独立于值得，<code>一个右值引用作为函数形参时，在函数内部转发给其他函数时，它就变成了一个左值，并不是原来的类型了。</code>如果需要按照参数原来的类型转发到另一个函数，可以使用C++11提供的<code>std::forward()</code>函数，该函数实现的功能称之为完美转发。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T&amp;&amp; <span class="title">forward</span> <span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="function">T&amp;&amp; <span class="title">forward</span> <span class="params">(<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp; t)</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 精简之后的样子</span></span><br><span class="line">std::forward&lt;T&gt;(t);</span><br></pre></td></tr></table></figure><ul><li><code>当T为左值引用类型时，t将被转换为T类型的左值</code></li><li><code>当T不是左值引用类型时，t将被转换为T类型的右值</code></li></ul><p>下面通过例子了解forward的使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testForward</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printValue</span>(v);</span><br><span class="line"><span class="built_in">printValue</span>(<span class="built_in">move</span>(v));</span><br><span class="line"><span class="built_in">printValue</span>(forward&lt;T&gt;(v));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">testForward</span>(<span class="number">520</span>);</span><br><span class="line"><span class="type">int</span> num = <span class="number">1314</span>;</span><br><span class="line"><span class="built_in">testForward</span>(num);</span><br><span class="line"><span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&gt;(num));</span><br><span class="line"><span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&gt;(num));</span><br><span class="line"><span class="built_in">testForward</span>(forward&lt;<span class="type">int</span>&amp;&amp;&gt;(num));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">l-value: <span class="number">520</span></span><br><span class="line">r-value: <span class="number">520</span></span><br><span class="line">r-value: <span class="number">520</span></span><br><span class="line"></span><br><span class="line">l-value: <span class="number">1314</span></span><br><span class="line">r-value: <span class="number">1314</span></span><br><span class="line">l-value: <span class="number">1314</span></span><br><span class="line"></span><br><span class="line">l-value: <span class="number">1314</span></span><br><span class="line">r-value: <span class="number">1314</span></span><br><span class="line">r-value: <span class="number">1314</span></span><br><span class="line"></span><br><span class="line">l-value: <span class="number">1314</span></span><br><span class="line">r-value: <span class="number">1314</span></span><br><span class="line">l-value: <span class="number">1314</span></span><br><span class="line"></span><br><span class="line">l-value: <span class="number">1314</span></span><br><span class="line">r-value: <span class="number">1314</span></span><br><span class="line">r-value: <span class="number">1314</span></span><br></pre></td></tr></table></figure><ul><li><p><code>testForward(520);</code>函数的形参为未定引用类型T&amp;&amp;，实参为右值，初始化后被推导为一个右值引用</p><ul><li><code>printValue(v);</code>编译器会视为左值处理，实参为左值</li><li><code>printValue(move(v));</code>已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为右值</li><li><code>printValue(forward&lt;T&gt;(v));</code>forward的模板参数为右值引用，最终得到一个右值，实参为<code>右值</code></li></ul></li><li><p><code>testForward(num);</code>函数的形参为未定引用类型T&amp;&amp;，实参为左值，初始化后被推导为一个左值引用</p><ul><li><code>printValue(v);</code>实参为左值</li><li><code>printValue(move(v));</code>通过move将左值转换为右值，实参为右值</li><li><code>printValue(forward&lt;T&gt;(v));</code>forward的模板参数为左值引用，最终得到一个左值引用，实参为左值</li></ul></li><li><p><code>testForward(forward&lt;int&gt;(num));</code>forward的模板类型为int，最终会得到一个右值，函数的形参为未定引用类型T&amp;&amp;被右值初始化后得到一个右值引用类型</p><ul><li><code>printValue(v);</code>已命名的右值v，编译器会视为左值处理，实参为左值</li><li><code>printValue(move(v));</code>已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为右值</li><li><code>printValue(forward&lt;T&gt;(v));</code>forward的模板参数为右值引用，最终得到一个右值，实参为右值</li></ul></li><li><p><code>testForward(forward&lt;int&amp;&gt;(num));</code>forward的模板类型为int&amp;，最终会得到一个左值，函数的形参为未定引用类型T&amp;&amp;被左值初始化后得到一个左值引用类型</p><ul><li><code>printValue(v);</code>实参为左值</li><li><code>printValue(move(v));</code>通过move将左值转换为右值，实参为右值</li><li><code>printValue(forward&lt;T&gt;(v));</code>forward的模板参数为左值引用，最终得到一个左值，实参为左值</li></ul></li><li><p><code>testForward(forward&lt;int&amp;&amp;&gt;(num));</code>forward的模板类型为int&amp;&amp;，最终会得到一个右值，函数的形参为未定引用类型T&amp;&amp;被右值初始化后得到一个右值引用类型</p><ul><li><code>printValue(v);</code>已命名的右值v，编译器会视为左值处理，实参为左值</li><li><code>printValue(move(v));</code>已命名的右值编译器会视为左值处理，通过move又将其转换为右值，实参为右值</li><li><code>printValue(forward&lt;T&gt;(v));</code>forward的模板参数为右值引用，最终得到一个右值，实参为右值</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树part08</title>
      <link href="/posts/17121.html"/>
      <url>/posts/17121.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-669-修剪二叉搜索树"><a href="#LeetCode-669-修剪二叉搜索树" class="headerlink" title="LeetCode  669 修剪二叉搜索树"></a>LeetCode  669 修剪二叉搜索树</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/trim-a-binary-search-tree">669.修剪二叉搜索树 </a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><hr><h1 id="LeetCode-108-将有序数组转换为二叉搜索树"><a href="#LeetCode-108-将有序数组转换为二叉搜索树" class="headerlink" title="LeetCode  108 将有序数组转换为二叉搜索树"></a>LeetCode  108 将有序数组转换为二叉搜索树</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree">108.将有序数组转换为二叉搜索树</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>构造一棵平衡二叉树，**本质就是寻找分割点，分割点作为当前节点，然后递归左区间和右区间。**分割点就是数组中间位置的节点。那么为问题来了，如果数组长度为偶数，中间节点有两个，取哪一个？</p><p>其实取哪一个都可以，只不过构成了不同的平衡二叉搜索树。</p><p><a href=""></a></p><p>接着是递归三要素进行分析：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 本题要构造二叉树，依然用递归函数的返回值来构造中节点的左右孩子。再来看参数，首先是传入数组，然后就是左下标left和右下标right。我们要知道，在构造二叉树的时候尽量不要重新定义左右区间数组，而是用下标来操作原数组。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 这里定义的是左闭右闭的区间，所以当区间 left&gt;right的时候，就是空节点了。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 我们在当前数组区间找到中间节点后，以该中间节点的值建立子树根节点，接着划分区间，root的左孩子接住下一层左区间的构造节点，右孩子接住下一层右区间构造的节点，最后返回该子树的根节点。递归遍历时，我们要注意区间的范围的变化</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">root-&gt;left = <span class="built_in">traversal</span>(nums,left,mid<span class="number">-1</span>);</span><br><span class="line">root-&gt;right = <span class="built_in">traversal</span>(nums,mid<span class="number">+1</span>,right);</span><br><span class="line"><span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> left,<span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[mid]);</span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(nums,left,mid<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(nums,mid<span class="number">+1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(nums,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-538-把二叉搜索树转换为累加树"><a href="#LeetCode-538-把二叉搜索树转换为累加树" class="headerlink" title="LeetCode  538 把二叉搜索树转换为累加树"></a>LeetCode  538 把二叉搜索树转换为累加树</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree">538.把二叉搜索树转换为累加树</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>初看题目，我和大家都一样懵，什么是累加树？测试用例中的输入输出表示什么意思？我们先来了解什么是累加树</p><p><strong>累加树（Sum Tree）<strong>是一种特殊的二叉树，其定义为：对于树中的每一个节点node，它的新值等于 原始树中所有比 node 的值更大的节点的值之和，再加上 node 自身的原始值。换句话说，累加树可以理解为</strong>从右到左的中序遍历累加</strong></p><p><a href=""></a></p><p>我们已经知道累加树是怎么求得的，接下来就很好求解了，我们只需要把遍历顺序由左中右调整为右中左，然后顺序累加就可以了</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 我们通过全局变量sum进行累加，因此不需要额外的返回值，参数只需要传入根节点进行遍历即可</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 遍历顺序是右中左，中间节点即为处理逻辑，将节点序号进行累加然后再赋值就行了</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">traversal</span>(node-&gt;right);         <span class="comment">//右</span></span><br><span class="line">sum += node-&gt;val;               <span class="comment">//中</span></span><br><span class="line">node-&gt;val = sum;</span><br><span class="line"><span class="built_in">traversal</span>(node-&gt;left);          <span class="comment">//左</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">traversal</span>(node-&gt;right);         <span class="comment">//右</span></span><br><span class="line">        sum += node-&gt;val;               <span class="comment">//中</span></span><br><span class="line">        node-&gt;val = sum;</span><br><span class="line">        <span class="built_in">traversal</span>(node-&gt;left);          <span class="comment">//左</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树part07</title>
      <link href="/posts/18081.html"/>
      <url>/posts/18081.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-235-二叉搜索树的最近公共祖先"><a href="#LeetCode-235-二叉搜索树的最近公共祖先" class="headerlink" title="LeetCode  235 二叉搜索树的最近公共祖先"></a>LeetCode  235 二叉搜索树的最近公共祖先</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree">235.二叉搜索树的最近公共祖先</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>做过<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst">530.二叉搜索树的最小绝对差</a>题目的同学应该知道，利用回溯从底向上搜索，遇到一个节点的左子树里有p，右子树里有q，那么当前节点就是最近公共祖先。那么本题是二叉搜索树，二叉搜索树是有序的，那得好好利用一下这个特点。</p><p>因为是有序树，所以如果中间节点是q和p的公共祖先，那么中节点的数组一定是在[p,q]区间的。即<code>中节点&gt;p &amp;&amp; 中节点&lt;q</code> 或者<code>中节点&gt;q &amp;&amp; 中节点&lt;p</code></p><p>那么只要从上到下去遍历，遇到cur节点是数值在[p,q]区间中则一定可以说明该节点cur就是p和q的公共祖先。那问题来了，<strong>一定是最近公共祖先吗？</strong></p><p>()[]</p><p>此时节点5是不是最近公共祖先？ 如果从节点5继续向左遍历，那么将错过成为p的祖先， 如果从节点5继续向右遍历则错过成为q的祖先。<strong>所以当我们从上向下去递归遍历，第一次遇到cur节点是数值在[q,p]区间中，那么cur就是q和p的最近公共祖先。</strong></p><p>依旧是递归三要素分析：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 参数就是当前节点，以及两个结点 p、q。返回值是要返回最近公共祖先，所以是TreeNode。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* node, TreeNode* p, TreeNode* q)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;val &gt;= p-&gt;val &amp;&amp; node-&gt;val &lt;= q-&gt;val) &#123;    </span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 如果想利用left和right做逻辑处理，不能立刻返回，而是要等left与right逻辑处理完之后才能返回。那么先用left和right接住左子树和右子树的返回值，然后进行后续相应的处理，代码如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* left = <span class="built_in">traversal</span>(node-&gt;left,p,q);         <span class="comment">//左</span></span><br><span class="line">TreeNode* right = <span class="built_in">traversal</span>(node-&gt;right,p,q);       <span class="comment">//右</span></span><br><span class="line"><span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;     <span class="comment">//中</span></span><br><span class="line"><span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* node, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &gt;= p-&gt;val &amp;&amp; node-&gt;val &lt;= q-&gt;val) &#123;    </span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;   </span><br><span class="line">        TreeNode* left = <span class="built_in">traversal</span>(node-&gt;left,p,q);         <span class="comment">//左</span></span><br><span class="line">        TreeNode* right = <span class="built_in">traversal</span>(node-&gt;right,p,q);       <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;     <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 确保 p-&gt;val &lt;= q-&gt;val</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &gt; q-&gt;val) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root,p,q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-701-二叉搜索树中的插入操作"><a href="#LeetCode-701-二叉搜索树中的插入操作" class="headerlink" title="LeetCode  701 二叉搜索树中的插入操作"></a>LeetCode  701 二叉搜索树中的插入操作</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree">701.二叉搜索树中的插入操作</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题目其实是一道简单题目，但是题目中的提示：有多种有效的插入方式，还可以重构二叉搜索树，一下子吓退了不少人，瞬间感觉题目复杂了很多。其实，我们只需要根据二叉搜索树的性质遍历，遇到空节点就插入节点就可以了</p><p>依旧是递归三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 参数就是根节点指针，以及要插入元素，因为我们要让父节点（上一层的节点）和新建立的叶子节点相连，实现叶子节点插入，因此需要返回值</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* node,<span class="type">int</span> val)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 如果当前节点为空，就证明我们找到插入的位置了，建立插入节点并把待插入的节点返回。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    TreeNode* leaveNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">return</span> leaveNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 此时要明确，需要遍历整棵树么？别忘了这是搜索树，遍历整棵搜索树简直是对搜索树的侮辱。搜索树是有方向了，可以根据插入元素的数值，决定递归方向。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node-&gt;val &lt; val) &#123;</span><br><span class="line">    node-&gt;right = <span class="built_in">traversal</span>(node-&gt;right,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    node-&gt;left = <span class="built_in">traversal</span>(node-&gt;left,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> node;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* node,<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            TreeNode* leaveNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">            <span class="keyword">return</span> leaveNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &lt; val) &#123;</span><br><span class="line">            node-&gt;right = <span class="built_in">traversal</span>(node-&gt;right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;left = <span class="built_in">traversal</span>(node-&gt;left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* node = <span class="built_in">traversal</span>(root,val);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-450-删除二叉搜索树中的节点"><a href="#LeetCode-450-删除二叉搜索树中的节点" class="headerlink" title="LeetCode  450 删除二叉搜索树中的节点"></a>LeetCode  450 删除二叉搜索树中的节点</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/delete-node-in-a-bst">450.删除二叉搜索树中的节点</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>二叉搜索树插入、删除节点的具体过程可以从视频<a href="https://www.bilibili.com/video/BV1b7411N798/?p=76&share_source=copy_web&vd_source=0db260a29b428cc91330eced2669ad8a">王道计算机考研 数据结构</a>了解，此处不在赘述</p><p>要想删除二叉搜索树中的节点，需要分以下无种情况讨论</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点， 返回NULL为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>第五种情况：左右孩子节点都不为空，则令删除节点z的直接后继（或直接前驱）替代z，然后从二叉搜索树中删除这个直接后继（或直接前驱）</li></ul></li></ul><p>递归三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 递归返回值来加入新节点， 这里也可以通过递归返回值删除节点。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> key)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 遇到空返回，其实这也说明没找到删除的节点，遍历到空节点直接返回了</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 单层递归的逻辑就是上述提到的5种情况</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node-&gt;val == key) &#123;</span><br><span class="line">    <span class="comment">//如果是叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有一棵左子树，让子树成为父节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        TreeNode* newNode = node-&gt;left;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果只有一棵右子树，让子树成为父节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right) &#123;</span><br><span class="line">        TreeNode* newNode = node-&gt;right;</span><br><span class="line">        <span class="keyword">delete</span> node;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//左右孩子都不为空，此处使用前驱节点来代替</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        TreeNode* cur = node-&gt;left;</span><br><span class="line">        <span class="comment">//找到node的前驱节点</span></span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;right = node-&gt;right;</span><br><span class="line">        TreeNode* temp = node;</span><br><span class="line">        node = node-&gt;left;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val == key) &#123;</span><br><span class="line">            <span class="comment">//如果是叶子节点</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果只有一棵左子树，让子树成为父节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                TreeNode* newNode = node-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                <span class="keyword">return</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果只有一棵右子树，让子树成为父节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right) &#123;</span><br><span class="line">                TreeNode* newNode = node-&gt;right;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">                <span class="keyword">return</span> newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左右孩子都不为空，此处使用前驱节点来代替</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode* cur = node-&gt;left;</span><br><span class="line">                <span class="comment">//找到node的前驱节点</span></span><br><span class="line">                <span class="keyword">while</span>(cur-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cur = cur-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                cur-&gt;right = node-&gt;right;</span><br><span class="line">                TreeNode* temp = node;</span><br><span class="line">                node = node-&gt;left;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &gt; key) node-&gt;left = <span class="built_in">traversal</span>(node-&gt;left,key);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &lt; key) node-&gt;right = <span class="built_in">traversal</span>(node-&gt;right,key);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* temp = <span class="built_in">traversal</span>(root,key);</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>右值引用</title>
      <link href="/posts/26838.html"/>
      <url>/posts/26838.html</url>
      
        <content type="html"><![CDATA[<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><h2 id="右值"><a href="#右值" class="headerlink" title="右值"></a>右值</h2><p>C++11增加了一个新的类型，称为右值引用，标记为<code>&amp;&amp;</code>。在介绍右值引用类型之前先了解什么是左值和右值：</p><ul><li><code>左值</code>是指<code>存储在内存中、有明确存储地址（可取地址）的数据；</code></li><li><code>右值</code>是指<code>可以提供数据值的数据（不可取地址），例如临时对象、字符串除外的字面量；</code></li></ul><p>通过描述可以看出，区分左值和右值的方法就是：<code>可以对表达式取地址（&amp;）就是左值，否则为右值 。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">1314</span>;</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure><p>一般情况下，位于<code>=</code>前的表达式为左值，位于<code>=</code>后边的表达式为右值。也就是说例子中的<code>a, b</code>为左值，<code>520,1314</code>为右值。其中，最容易被大家误解的是<code>a=b</code>，这是一种特殊情况，在这个表达式中<code>a, b</code>都是左值，因为变量<code>b</code>是可以被取地址的，不能视为右值。</p><p>C++11中右值可以分为两种：一种是<code>将亡值</code>，另一个是<code>纯右值</code>：</p><ul><li><code>将亡值：非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等</code></li><li><code>纯右值：与右值引用相关的表达式，比如，T&amp;&amp;类型函数的返回值std::move的返回值等。</code></li></ul><h2 id="右值引用-1"><a href="#右值引用-1" class="headerlink" title="右值引用"></a>右值引用</h2><p>右值引用就是对一个右值进行引用的类型。因为右值是匿名的，所有我们只能通过引用方式找到它。<code>无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又“重获新生”</code>，只要该变量还活着，该右值临时变量将会一直存活下去。</p><p>关于右值引用的使用，参考代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; value = <span class="number">520</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回的是匿名对象，也就是说它不能被取地址，是个右值</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a1;</span><br><span class="line"><span class="type">int</span>&amp;&amp; a2 = a1;<span class="comment">//error</span></span><br><span class="line">Test&amp; t = <span class="built_in">getObj</span>();<span class="comment">//error</span></span><br><span class="line">Test&amp;&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line"><span class="type">const</span> Test&amp; t = <span class="built_in">getObj</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>int&amp;&amp; value = 520;</code>其中，<code>520</code>是纯右值，<code>value</code>是对字面量<code>520</code>这个右值的引用</li><li>在<code>int&amp;&amp; a2 = a1;</code>中<code>a1</code>虽然写在<code>=</code>右边，但它仍然是个左值，<code>使用左值初始化一个右值引用类型是不合法的。</code></li><li><code>Test&amp; t = getObj();</code>这句代码语法是错误的，<code>右值不能给普通的左值引用赋值</code></li><li>在<code>Test&amp;&amp; t = getObj();</code>中<code>getObj();</code>返回的临时对象称之为<code>将亡值</code>，<code>t</code>是这个将亡值的右值引用</li><li><code>const Test&amp; t = getObj();</code>这句代码的语法是正确的，<code>常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值。</code></li></ul><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以使用右值引用进行性能的优化。</p><p>再来修改一下上面的实例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Test</span>() &#123;</span><br><span class="line"><span class="keyword">delete</span> m_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test t;</span><br><span class="line"><span class="comment">//返回临时对象，可以被取地址，是个左值</span></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test t = <span class="built_in">getObj</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t.m_num&quot;</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：(vs版本为2019可以看到如下输出，但是vs2022已无法看到相同的输出，代码被优化了)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">construct: my name is jerry</span><br><span class="line">copy construct: my name is tom</span><br><span class="line">t.m_num: <span class="number">100</span></span><br></pre></td></tr></table></figure><p>通过输出结果可以看到调用<code>Test t = getObj();</code>的时候，调用拷贝构造函数对返回的临时变量进行深拷贝得到对象<code>t</code>，在<code>getObj()</code>函数中创建的对象虽然申请内存，但是没有使用就释放掉了。如果能够使用临时对象已经申请过的资源，既能节省资源，还能节省资源申请和释放的时间，如果要执行这样的操作就需要使用右值引用了。<code>右值引用具有移动语义，移动语义可以将资源（堆、系统对象等）通过浅拷贝从一个对象转移到另一个对象，这样能减少不必要的临时对象的创建、拷贝以及销毁</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;construct: my name is jerry&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="type">const</span> Test&amp; a) : <span class="built_in">m_num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*a.m_num)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;copy construct: my name is tom&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移动构造函数 -&gt; 复用其他对象中的资源</span></span><br><span class="line"><span class="built_in">Test</span>(Test&amp;&amp; a) : <span class="built_in">m_num</span>(a.m_num) &#123;</span><br><span class="line">a.m_num = <span class="literal">nullptr</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;move construct: my name is sunny&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">Test</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;destruct Test class...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">delete</span> m_num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* m_num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test t;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Test <span class="title">getObj1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Test&amp;&amp; <span class="title">getObj2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Test</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//要求右侧的对象是一个临时对象，才会调用移动构造函数</span></span><br><span class="line"><span class="comment">//如果没有移动构造函数，就会调用拷贝构造函数</span></span><br><span class="line"><span class="comment">//两种方式进行调用：</span></span><br><span class="line">Test t = <span class="built_in">getObj</span>();</span><br><span class="line"><span class="comment">//Test&amp;&amp; t1 = getObj();</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t.m_num&quot;</span> &lt;&lt; *t.m_num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有移动构造函数，使用右值引用初始化要求会更高一些</span></span><br><span class="line"><span class="comment">//要求右侧是一个临时的不能取地址的对象</span></span><br><span class="line"><span class="comment">//Test&amp;&amp; t2 = getObj1();</span></span><br><span class="line"><span class="comment">//或者函数返回的是一个右值引用类型</span></span><br><span class="line"><span class="comment">//Test&amp;&amp; t3 = getObj2();</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：(vs版本为2019可以看到如下输出，但是vs2022已无法看到相同的输出，代码被优化了)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">construct: my name is jerry</span><br><span class="line">move construct: my name is sunny</span><br><span class="line">destruct Test <span class="keyword">class</span> ...</span><br><span class="line">t.m_num: <span class="number">100</span></span><br><span class="line">destruct Test <span class="keyword">class</span> ...</span><br></pre></td></tr></table></figure><h1 id="的特性"><a href="#的特性" class="headerlink" title="&amp;&amp;的特性"></a>&amp;&amp;的特性</h1><p>在C++中，并不是所有情况下<code>&amp;&amp;</code>都代表是一个右值引用，具体的场景体现在模板和自动类型推导中。如果是<code>模板参数</code>需指定为<code>T&amp;&amp;</code>，如果<code>自动类型推导</code>需要指定为<code>auto&amp;&amp;</code>，在这两种场景下<code>&amp;&amp;</code>被称作未定的引用类型。此外，还需要注意的是<code>const T&amp;&amp;</code>直接表示右值引用，不需要推导。</p><p>先看第一个例子，在模板参数指定T&amp;&amp;：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f1</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);          <span class="comment">//ok，传入的实参是右值，因此T&amp;&amp;表示右值引用</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x);           <span class="comment">//ok，传入的实参是左值，因此T&amp;&amp;表示左值引用</span></span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">10</span>);         <span class="comment">//errno，形参const T&amp;&amp; param直接表示右值引用，而实参是左值</span></span><br><span class="line"><span class="built_in">f1</span>(x);          <span class="comment">//ok</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看第二个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">520</span>, y = <span class="number">1314</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; v1 = x;<span class="comment">// ok，auto&amp;&amp;表示左值引用</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; v2 = <span class="number">250</span>;<span class="comment">// ok，auto&amp;&amp;表示左值引用</span></span><br><span class="line"><span class="keyword">decltype</span>(x) &amp;&amp; v3 = y;<span class="comment">// error，decltype(x)&amp;&amp;等价与int&amp;&amp;，而y是一个左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码可以看出<code>T&amp;&amp;</code>和<code>auto&amp;&amp;</code>这种未定义类型，当它作为参数时，有可能被一个右值引用初始化，也有可能被一个左值引用初始化。在进行类型推导时，右值引用类型（&amp;&amp;）会发生变化，这种变化称为<code>引用折叠</code>。在C++11中引用折叠规则如下：</p><ul><li><code>通过右值推导T&amp;&amp;或者auto&amp;&amp;得到的是一个右值引用类型</code></li><li><code>通过非右值（右值引用、左值、左值引用、常量右值引用、常量左值引用）推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个左值引用类型。</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; a1 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb = a1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; bb1 = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> &amp;a3 = a2;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc = a3;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; cc1 = a2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; s1 = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp;&amp; s2 = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; dd = s1;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; ee = s2;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp;&amp; x = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><ul><li>第2行，<code>a1</code>为右值引用，推导出<code>bb</code>为<code>左值引用</code>类型</li><li>第3行，<code>5</code>为右值，推导出<code>bb1</code>为<code>右值引用</code>类型</li><li>第7行，<code>a3</code>为左值引用，推导出<code>cc</code>为<code>左值引用</code>类型</li><li>第8行，<code>a2</code>为左值，推导出<code>cc1</code>为<code>左值引用</code>类型</li><li>第12行，<code>s1</code>为常量左值引用，推导出<code>dd</code>为<code>常量左值引用</code>类型</li><li>第13行，<code>s2</code>为常量右值引用，推导出<code>ee</code>为<code>常量左值引用</code>类型</li><li>第15行，<code>X</code>为右值引用，不需要推导，只能通过右值初始化</li></ul><p>再看最后一个例子，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数 左值引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;l-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//参数 右值引用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span>&amp;&amp; i)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;r-value: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">forward</span><span class="params">(<span class="type">int</span>&amp;&amp; k)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printValue</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">520</span>;</span><br><span class="line"><span class="built_in">printValue</span>(i);<span class="comment">//调用形参为左值引用的函数</span></span><br><span class="line"><span class="built_in">printValue</span>(<span class="number">1314</span>);<span class="comment">//调用形参为右值引用的函数</span></span><br><span class="line">forward(<span class="number">250</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l-value: <span class="number">520</span></span><br><span class="line">r-value: <span class="number">1314</span></span><br><span class="line">l-value: <span class="number">250</span></span><br></pre></td></tr></table></figure><p>根据测试结果可知，编译器会根据传入的参数的类型（左值还是右值）调用对应的重载函数（printValue），函数forward()接收一个右值，但是在这个函数中调用函数printValue()时，参数k变成了</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li><code>左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</code></li><li><code>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。</code></li><li><code>auto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）。</code></li><li><code>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型。</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树part06</title>
      <link href="/posts/34400.html"/>
      <url>/posts/34400.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-530-二叉搜索树的最小绝对差"><a href="#LeetCode-530-二叉搜索树的最小绝对差" class="headerlink" title="LeetCode 530 二叉搜索树的最小绝对差"></a>LeetCode 530 二叉搜索树的最小绝对差</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst">530.二叉搜索树的最小绝对差</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>思路很简单，通过递归或者迭代的方式都可以求解，此处只通过递归求解。</p><p>我们通过递归的方式中序遍历二叉搜索树，将遍历到的节点放入vec数组保存，因为二叉搜索树的性质，最后得出的vec数组一定是升序排序的，然后就是<strong>在一个有序数组上求两个数最小差值</strong>，这简直就是送分题！</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">traversal</span>(node-&gt;left);          <span class="comment">//左</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val);       <span class="comment">//中</span></span><br><span class="line">        <span class="built_in">traversal</span>(node-&gt;right);         <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinGap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minGap = INT32_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; vec.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="type">int</span> valueGap = vec[i]-vec[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(valueGap &lt; minGap) &#123;</span><br><span class="line">                minGap = valueGap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minGap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinimumDifference</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="type">int</span> ret = <span class="built_in">findMinGap</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-501-二叉搜索树中的众数"><a href="#LeetCode-501-二叉搜索树中的众数" class="headerlink" title="LeetCode 501 二叉搜索树中的众数"></a>LeetCode 501 二叉搜索树中的众数</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree">501.二叉搜索树中的众数</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>和<a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst">530.二叉搜索树的最小绝对差</a>题目类似，只是把求解数组中的差值变为求解数组中的众数</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">traversal</span>(node-&gt;left);          <span class="comment">//左</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(node-&gt;val);       <span class="comment">//中</span></span><br><span class="line">        <span class="built_in">traversal</span>(node-&gt;right);         <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findModeValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; freqMap;</span><br><span class="line">        <span class="type">int</span> maxFreq = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : vec) &#123;</span><br><span class="line">            freqMap[i]++;</span><br><span class="line">            maxFreq = <span class="built_in">max</span>(maxFreq, freqMap[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; pair : freqMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.second == maxFreq) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(pair.first);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findMode</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="built_in">findModeValue</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-236-二叉树的最近公共祖先"><a href="#LeetCode-236-二叉树的最近公共祖先" class="headerlink" title="LeetCode 236 二叉树的最近公共祖先"></a>LeetCode 236 二叉树的最近公共祖先</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree">236. 二叉树的最近公共祖先</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>通过后序遍历自底向上查找，这样就可以找到公共祖先了，接下来就看如何判断一个节点是节点q和节点p的公共祖先呢。</p><ol><li><p><strong>首先最容易想到的一个情况：如果找到一个节点，发现左子树出现结点p，右子树出现节点q，或者 左子树出现结点q，右子树出现节点p，那么该节点就是节点p和q的最近公共祖先。</strong> 即情况一：</p><p> <a href=""></a></p><p> 判断逻辑是 如果递归遍历遇到q，就将q返回，遇到p 就将p返回，那么如果 左右子树的返回值都不为空，说明此时的中节点，一定是q 和p 的最近祖先。</p></li><li><p>情况二：</p><p> <a href=""></a></p><p> 其实情况一 和 情况二 代码实现过程都是一样的，也可以说，实现情况一的逻辑，顺便包含了情况二。因为遇到 q 或者 p 就返回，这样也包含了 q 或者 p 本身就是 公共祖先的情况。</p></li></ol><p>接下来就是递归三要素进行分析：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 需要递归函数返回值，来告诉我们是否找到节点q或者p，那么返回值为bool类型就可以了。但我们还要返回最近公共节点，可以利用上题目中返回值是TreeNode* ，那么如果遇到p或者q，就把q或者p返回，返回值不为空，就说明找到了q或者p。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* node,TreeNode* p, TreeNode* q)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 遇到空的话，因为树都是空了，所以返回空。如果 root &#x3D;&#x3D; q，或者 root &#x3D;&#x3D; p，说明找到 q p ，则将其返回</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span>(node == p || node == q) <span class="keyword">return</span> node;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑</strong> </p><p> 我们要知道，递归函数有返回值就是要遍历某一条边，但有返回值也要看如何处理返回值！如果递归函数有返回值，如何区分要搜索一条边，还是搜索整个树呢？</p><p> 搜索一条边的写法：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(递归函数(root-&gt;left)) <span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">if</span>(递归函数(root-&gt;right)) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure><p> 搜索整个树写法：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">right = 递归函数(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">left与right的逻辑处理;          <span class="comment">// 中 </span></span><br></pre></td></tr></table></figure><p> <strong>在递归函数有返回值的情况下：如果要搜索一条边，递归函数返回值不为空的时候，立刻返回，如果搜索整个树，直接用一个变量left、right接住返回值，这个left、right后序还有逻辑处理的需要，也就是后序遍历中处理中间节点的逻辑（也是回溯）。那么为什么要遍历整棵树呢？直观上来看，找到最近公共祖先，直接一路返回就可以了。</strong></p><p> 因为在如下代码的后序遍历中，如果想利用left和right做逻辑处理，不能立刻返回，而是要等left与right逻辑处理完之后才能返回。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left = 递归函数(root-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">right = 递归函数(root-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">left与right的逻辑处理;          <span class="comment">// 中 </span></span><br></pre></td></tr></table></figure><p> 那么先用left和right接住左子树和右子树的返回值，代码如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* left = <span class="built_in">traversal</span>(node-&gt;left,p,q);     <span class="comment">//左</span></span><br><span class="line">TreeNode* right = <span class="built_in">traversal</span>(node-&gt;right,p,q);   <span class="comment">//右</span></span><br></pre></td></tr></table></figure><p> <strong>如果left 和 right都不为空，说明此时root就是最近公共节点。这个比较好理解</strong></p><p> <strong>如果left为空，right不为空，就返回right，说明目标节点是通过right返回的，反之依然。</strong></p><p> <strong>如果left和right都为空，则返回left或者right都是可以的，也就是返回空。</strong></p><p> 代码如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> node;    <span class="comment">//中</span></span><br><span class="line"><span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* node,TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(node == p || node == q) <span class="keyword">return</span> node;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">traversal</span>(node-&gt;left,p,q);     <span class="comment">//左</span></span><br><span class="line">        TreeNode* right = <span class="built_in">traversal</span>(node-&gt;right,p,q);   <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> node;    <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        TreeNode* node = <span class="built_in">traversal</span>(root,p,q);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lambda表达式</title>
      <link href="/posts/40489.html"/>
      <url>/posts/40489.html</url>
      
        <content type="html"><![CDATA[<h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p><code>lambda</code>表达式定义了一个匿名函数，并且可以捕获一定范围内的变量。<code>lambda</code>表达式的语法形式可以简单归纳为如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](params) opt -&gt; ret &#123;body;&#125;;</span><br></pre></td></tr></table></figure><p>其中，<code>capture</code>是捕获列表，<code>params</code>是参数列表，<code>opt</code>是函数选项，<code>ret</code>是返回值类型，<code>body</code>是函数体</p><ol><li><p><code>捕获列表[]</code>: 捕获一定范围内的变量</p></li><li><p><code>参数列表()</code>: 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []()&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表为空</span></span><br><span class="line"><span class="keyword">auto</span> f = []&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;<span class="comment">// 没有参数, 参数列表省略不写</span></span><br></pre></td></tr></table></figure></li><li><p><code>opt选项</code>，不需要可省略<br>- mutable：可以修改按值传递进来的拷贝（注意是修改拷贝，而不是值本身）<br>- exception：指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</p></li><li><p><code>ret返回值类型</code>：在C++11中，lambda表达式的返回值是通过返回值后置语法来定义的，可省略，由编译器自动推导返回值</p></li><li><p><code>body函数体</code>：函数的实现，这部分不能省略，但函数体可以为空。</p></li></ol><h1 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h1><p>lambda表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p><ul><li><code>[]</code>：不捕捉任何变量</li><li><code>[&amp;]</code>：捕获外部作用域中所有变量, 并作为引用在函数体内使用<code>(按引用捕获)</code></li><li><code>[=]</code>：捕获外部作用域中所有变量, 并作为副本在函数体内使用<code>(值拷贝，只读)</code></li><li><code>[=, &amp;foo]</code>：只有foo变量是引用，其他变量都是值拷贝</li><li><code>[bar]</code>：按值捕获bar变量, 同时不捕获其他变量</li><li><code>[&amp;bar]</code>：按引用捕获bar变量, 同时不捕获其他变量</li><li><code>[this]</code>：捕获当前类中的this指针，访问对象内部成员<ul><li>让lambda表达式拥有和当前类成员函数同样的访问权限</li><li>如果已经使用了 &amp; 或者 &#x3D;, 默认添加此选项</li></ul></li></ul><p>其中，较常使用的是<code>[]、[&amp;]、[=]和[this]</code>，下面来看具体的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> x1 = []() &#123;<span class="keyword">return</span> m_num; &#125;;<span class="comment">// error</span></span><br><span class="line"><span class="keyword">auto</span> x2 = [=]() &#123;<span class="keyword">return</span> m_num + x + y; &#125;;<span class="comment">// ok</span></span><br><span class="line"><span class="keyword">auto</span> x3 = [&amp;]() &#123;<span class="keyword">return</span> m_num + x + y; &#125;;<span class="comment">// ok</span></span><br><span class="line"><span class="keyword">auto</span> x4 = [<span class="keyword">this</span>]() &#123;<span class="keyword">return</span> m_num; &#125;;<span class="comment">// ok</span></span><br><span class="line"><span class="keyword">auto</span> x5 = [<span class="keyword">this</span>]() &#123;<span class="keyword">return</span> m_num + x + y; &#125;;<span class="comment">// errno</span></span><br><span class="line"><span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y]() &#123;<span class="keyword">return</span> m_num + x + y; &#125;;<span class="comment">// ok</span></span><br><span class="line"><span class="keyword">auto</span> x7 = [<span class="keyword">this</span>]() &#123;<span class="keyword">return</span> m_num++; &#125;;<span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num = <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><code>x1</code>：错误，没有捕获外部变量，不能使用类成员 m_num</li><li><code>x2</code>：正确，以值拷贝的方式捕获所有外部变量</li><li><code>x3</code>：正确，以引用的方式捕获所有外部变量</li><li><code>x4</code>：正确，捕获this指针，可以访问对象内部成员</li><li><code>x5</code>：错误，捕获this指针，可访问类内部成员，没有捕获到变量x，y，因此不能访问。</li><li><code>x6</code>：正确，捕获this指针，x，y</li><li><code>x7</code>：正确，捕获this指针，并且可以修改对象内部变量的值</li></ul><h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>很多时候，lambda表达式的返回值是非常明显的，因此在C++11中允许省略lambda表达式的返回值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完整的lambda表达式定义</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a)-&gt;<span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a + <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//忽略返回值的lambda表达式定义</span></span><br><span class="line"><span class="keyword">auto</span> f1 = [](<span class="type">int</span> a) &#123;</span><br><span class="line"><span class="keyword">return</span> a + <span class="number">10</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般情况下，不指定lambda表达式的返回值，编译器会根据return语句自动推导返回值的类型，但需要注意的是<code>labmda表达式不能通过列表初始化自动推导出返回值类型。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//报错，不能推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> t = []() &#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="number">1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="函数的本质"><a href="#函数的本质" class="headerlink" title="函数的本质"></a>函数的本质</h1><p>使用lambda表达式捕获列表捕获外部变量，如果希望<strong>修改按值捕获到的外部变量</strong>，就需要<code>mutable</code>选项，<code>mutable修改时，lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=] &#123;<span class="keyword">return</span> a++; &#125;;<span class="comment">// error</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]<span class="keyword">mutable</span> &#123;<span class="keyword">return</span> a++; &#125;;<span class="comment">// error</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=]()<span class="keyword">mutable</span> &#123;<span class="keyword">return</span> a++; &#125;;<span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>当捕获列表为空时，此时lambda表达式可以看成是一个函数指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line"><span class="comment">// 没有捕获任何外部变量的匿名函数</span></span><br><span class="line">func_ptr f = [](<span class="type">int</span> a) &#123;</span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1314</span>);</span><br></pre></td></tr></table></figure><p>如果捕获列表捕获到了外部变量，那么它就作为仿函数来使用，因此可以使用<code>std::function</code>和<code>std::bind</code>来存储和操作lambda表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 包装可调用函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f1 = [](<span class="type">int</span> a) &#123;<span class="keyword">return</span> a; &#125;;</span><br><span class="line">    <span class="comment">// 绑定可调用函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f2 = <span class="built_in">bind</span>([](<span class="type">int</span> a) &#123;<span class="keyword">return</span> a; &#125;, placeholders::_1);</span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树part05</title>
      <link href="/posts/34592.html"/>
      <url>/posts/34592.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-654-最大二叉树"><a href="#LeetCode-654-最大二叉树" class="headerlink" title="LeetCode 654 最大二叉树"></a>LeetCode 654 最大二叉树</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/maximum-binary-tree">654.最大二叉树</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和<a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal">106.从中序与后序遍历序列构造二叉树</a>题目一样，只是由两个数组确定变成一个数组确定。首先找出数组中的最大元素作为根节点，然后将数组分成左右两部分，再递归地在左右子数组中找出最大值作为左右子节点。</p><p>我们根据递归三要素进行分析：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 我们每次递归要处理的是nums数组，所以要把数组作为参数传入。此外，每次划分左右数组之后会找到一个根节点，所以返回值是TreeNode*</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 如果遍历到的nums数组为0，表示这颗子树已经遍历完了，直接返回nullptr；如果遍历到的nums数组只有1个节点，那么直接把它作为根节点返回</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//叶子节点</span></span><br><span class="line"><span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑</strong></p><ul><li>nums数组为0，空节点</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><ul><li>找到当前数组最大元素作为根节点</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = <span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line"><span class="type">int</span> rootValue = *it;</span><br><span class="line">TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br></pre></td></tr></table></figure><ul><li>寻找nums数组中的切割点</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> delimiterIndex;</span><br><span class="line"><span class="keyword">for</span>(delimiterIndex = <span class="number">0</span>;delimiterIndex &lt; nums.<span class="built_in">size</span>();delimiterIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将nums数组切成两个子数组，delimiterIndex作为切分左右区间的标记点</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">leftNums</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>()+delimiterIndex);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">rightNums</span>(nums.<span class="built_in">begin</span>()+delimiterIndex<span class="number">+1</span>,nums.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><ul><li>递归处理左右子数组</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left = <span class="built_in">traversal</span>(leftNums);</span><br><span class="line">root-&gt;right = <span class="built_in">traversal</span>(rightNums);</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = <span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> rootValue = *it;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">int</span> delimiterIndex;</span><br><span class="line">        <span class="keyword">for</span>(delimiterIndex = <span class="number">0</span>;delimiterIndex &lt; nums.<span class="built_in">size</span>();delimiterIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将区间切割成左右</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">leftNums</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">begin</span>()+delimiterIndex);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">rightNums</span>(nums.<span class="built_in">begin</span>()+delimiterIndex<span class="number">+1</span>,nums.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(leftNums);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rightNums);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-617-合并二叉树"><a href="#LeetCode-617-合并二叉树" class="headerlink" title="LeetCode 617 合并二叉树"></a>LeetCode 617 合并二叉树</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/merge-two-binary-trees">617.合并二叉树</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>老套路，依旧是递归三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 首先要合入两个二叉树，那么参数至少是要传入两个二叉树的根节点，返回值就是合并之后二叉树的根节点。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* root1,TreeNode* root2)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 终止条件有三种情况，如下所示</p><ul><li>root1为空，root2为空，返回nullptr</li><li>root1不为空，root2为空，此时以root1构建新二叉树节点，返回root1</li><li>root1为空，root2不为空，此时以root2构建新二叉树节点，返回root2</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span>(root1 &amp;&amp; root2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root1;</span><br><span class="line"><span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> &amp;&amp; root2) <span class="keyword">return</span> root2;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 单层循环逻辑就是<strong>root1不为空，root2也不为空</strong>情况，此时这两个节点重叠，将这两个节点的值相加作为合并后节点的新值</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = root1-&gt;val + root2-&gt;val;</span><br><span class="line">TreeNode* newNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(value);</span><br><span class="line">newNode-&gt;left = <span class="built_in">traversal</span>(root1-&gt;left,root2-&gt;left);</span><br><span class="line">newNode-&gt;right = <span class="built_in">traversal</span>(root1-&gt;right,root2-&gt;right);</span><br><span class="line"><span class="keyword">return</span> newNode;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* root1,TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> &amp;&amp; root2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 &amp;&amp; root2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> root1;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">nullptr</span> &amp;&amp; root2) <span class="keyword">return</span> root2;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> value = root1-&gt;val + root2-&gt;val;</span><br><span class="line">        TreeNode* newNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(value);</span><br><span class="line">        newNode-&gt;left = <span class="built_in">traversal</span>(root1-&gt;left,root2-&gt;left);</span><br><span class="line">        newNode-&gt;right = <span class="built_in">traversal</span>(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">mergeTrees</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root1,root2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-700-二叉搜索树中的搜索"><a href="#LeetCode-700-二叉搜索树中的搜索" class="headerlink" title="LeetCode 700 二叉搜索树中的搜索"></a>LeetCode 700 二叉搜索树中的搜索</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree">700.二叉搜索树中的搜索 </a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>二叉搜索树是一棵有序树：</p><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉搜索树</li></ul><p>简单来说就是<strong>左节点值&lt;根节点值&lt;右节点值</strong>。二叉搜索树的性质就决定了递归遍历和迭代遍历和普通二叉树都不一样。</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>依旧是递归三部曲来分析：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 我们要判断当前节点node和目标值val的关系来决定向左子树还是右子树遍历，因此需要传入参数node和val，返回值就是以这个搜索数值所在的节点</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> val)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 如果当前节点为空，或者当前节点是叶子节点且其值不等于目标值val，则说明未找到目标值val，返回nullptr。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> &amp;&amp; node-&gt;val != val) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 因为二叉搜索树的节点是有序的，所以可以有方向的去搜索。如果root-&gt;val &gt; val，搜索左子树，如果root-&gt;val &lt; val，就搜索右子树</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* newNode = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;val &gt; val) &#123;</span><br><span class="line">    newNode = <span class="built_in">traversal</span>(node-&gt;left,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;val &lt; val) &#123;</span><br><span class="line">    newNode = <span class="built_in">traversal</span>(node-&gt;right,val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;val == val) &#123;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newNode;</span><br></pre></td></tr></table></figure></li></ol><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>一提到二叉树遍历的迭代法，可能立刻想起使用栈来模拟深度遍历，使用队列来模拟广度遍历。对于二叉搜索树可就不一样了，因为二叉搜索树的特殊性，也就是节点的有序性，可以不使用辅助栈或者队列就可以写出迭代法。<strong>此外，对于二叉搜索树而言，不需要回溯的过程，因为节点的有序性就帮我们确定了搜索的方向。</strong></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> val)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> &amp;&amp; node-&gt;val != val) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* newNode = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &gt; val) &#123;</span><br><span class="line">            newNode = <span class="built_in">traversal</span>(node-&gt;left,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &lt; val) &#123;</span><br><span class="line">            newNode = <span class="built_in">traversal</span>(node-&gt;right,val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(root,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;val &gt; val) root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; val) root = root-&gt;right;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-98-验证二叉搜索树"><a href="#LeetCode-98-验证二叉搜索树" class="headerlink" title="LeetCode 98 验证二叉搜索树"></a>LeetCode 98 验证二叉搜索树</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/validate-binary-search-tree">98.验证二叉搜索树</a></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这道题可以使用递归或者迭代进行求解，但是迭代法有点难度，这里只分析递归法的求解过程。</p><p>依旧是递归三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 我们定义一个全局变量maxValue来记录已经遍历过的节点值的最大值，这样可以与后续节点的值进行比较，以判断是否符合二叉搜索树的要求，函数接收当前节点node作为参数，返回一个布尔值。需要注意的是，如果我们使用INT32_MIN 作为初始值，它表示[-2147483648]，但是后台测试数据中有int最小值[-2147483648]，这样结果第一次比较node-&gt;val &gt; maxValue 时就会错误地返回 false</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> maxValue = LONG_MIN;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* node)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件</strong> </p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 中序遍历，一直更新maxValue，一旦发现maxValue &gt;&#x3D; root-&gt;val，就返回false</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> left = <span class="built_in">traversal</span>(node-&gt;left);      <span class="comment">//左</span></span><br><span class="line"><span class="keyword">if</span>(node-&gt;val &gt; maxValue) &#123;              <span class="comment">//中</span></span><br><span class="line">    maxValue = node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> right = <span class="built_in">traversal</span>(node-&gt;right);    <span class="comment">//右</span></span><br><span class="line"><span class="comment">//如果某个子树不满足左&lt;根&lt;右，那么就不是二叉搜索树</span></span><br><span class="line"><span class="keyword">return</span> left &amp;&amp; right;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">bool</span> left = <span class="built_in">traversal</span>(node-&gt;left);      <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;val &gt; maxValue) &#123;              <span class="comment">//中</span></span><br><span class="line">            maxValue = node-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> right = <span class="built_in">traversal</span>(node-&gt;right);    <span class="comment">//右</span></span><br><span class="line">        <span class="comment">//如果某个子树不满足左&lt;根&lt;右，那么就不是二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxValue = LONG_MIN;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树part04</title>
      <link href="/posts/18401.html"/>
      <url>/posts/18401.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-513-找树左下角的值"><a href="#LeetCode-513-找树左下角的值" class="headerlink" title="LeetCode 513 找树左下角的值"></a>LeetCode 513 找树左下角的值</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/find-bottom-left-tree-value">513.找树左下角的值</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目可以使用递归和迭代求解，递归法较难，迭代法较简单</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>和<a href="https://leetcode.cn/problems/binary-tree-paths">257.二叉树的所有路径</a>类似，采用前序遍历，在遍历过程中我们要记录最大深度和该层的第一个节点，接下来看看递归三部曲：</p><ol><li><strong>确定递归函数的参数和返回值：</strong> 既然要遍历，那肯定要传入当前节点值，还需要一个变量记录当前深度，不需要返回值</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node,<span class="type">int</span> depth)</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>确定终止条件：</strong> 当遍历到节点是叶子节点就可以返回上一层了</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">//更新最大深度和当前层第一个节点的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>确定单层递归的逻辑：</strong> 因为是前序遍历，先处理中间节点，在处理左右节点。我们在遍历中间节点时只需要将当前深度depth加1即可，然后遍历左右节点</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">depth++;                        <span class="comment">//中</span></span><br><span class="line"><span class="keyword">if</span>(node-&gt;left) &#123;                <span class="comment">//左</span></span><br><span class="line">    <span class="built_in">traversal</span>(node-&gt;left,depth);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;right) &#123;               <span class="comment">//右</span></span><br><span class="line">    <span class="built_in">raversal</span>(node-&gt;right,depth);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>本题使用层序遍历再合适不过了，比递归要好理解得多！只需要记录最后一行第一个节点的数值就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node,<span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//每次到达一个最新的深度，都要记录当前的深度和当前层的第一个值</span></span><br><span class="line">            <span class="keyword">if</span>(depth &gt; maxDepth) &#123;</span><br><span class="line">                maxDepth = depth;</span><br><span class="line">                result = node-&gt;val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) &#123;                <span class="comment">//左</span></span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;left,depth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) &#123;               <span class="comment">//右</span></span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;right,depth);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(root,depth);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> maxDepth = INT_MIN;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代-1"><a href="#迭代-1" class="headerlink" title="迭代"></a>迭代</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        queue&lt;TreeNode*&gt;que;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) result = node-&gt;val;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-112-路径总和"><a href="#LeetCode-112-路径总和" class="headerlink" title="LeetCode 112 路径总和"></a>LeetCode 112 路径总和</h1><p><strong>题目链接：</strong> <a href="https://leetcode.cn/problems/path-sum">112.路径总和</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>依然是回溯思想，老规矩，我们直接写出递归三要素来分析：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 要对树进行遍历，当然要传进来当前节点，还需要传进一个数标记当前路径上的节点和是多少，返回值是bool类型</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* node,<span class="type">int</span> targetSum)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 终止条件当然是遍历到叶节点结束，遍历结束的时候我们要判断当前路径上的数相加是否为targetSum，如果是，向上一层返回true，否则，返回false</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果遍历到叶子节点，targetSum不为0，此时这条路径不符合要求，返回到上一层</span></span><br><span class="line"><span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//如果遍历到叶子节点，targetSum等于0，那么这条路径符合要求</span></span><br><span class="line"><span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 因为终止条件是判断叶子节点，所以递归过程中就不需要让空节点进入递归了。此外，我们还需要设置回溯的过程，代码如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">targetSum -= node-&gt;left-&gt;val;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">traversal</span>(node-&gt;left,targetSum)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    targetSum += node-&gt;left-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">    targetSum -= node-&gt;right-&gt;val;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">traversal</span>(node-&gt;right,targetSum)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//回溯</span></span><br><span class="line">    targetSum += node-&gt;right-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">traversal</span><span class="params">(TreeNode* node,<span class="type">int</span> targetSum)</span> </span>&#123;     </span><br><span class="line">        <span class="comment">//如果遍历到叶子节点，targetSum不为0，此时这条路径不符合要求，返回到上一层</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//如果遍历到叶子节点，targetSum等于0，那么这条路径符合要求</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">            targetSum -= node-&gt;left-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">traversal</span>(node-&gt;left,targetSum)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            targetSum += node-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">            targetSum -= node-&gt;right-&gt;val;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">traversal</span>(node-&gt;right,targetSum)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            targetSum += node-&gt;right-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="built_in">traversal</span>(root,targetSum-(root-&gt;val));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-113-路径总和II"><a href="#LeetCode-113-路径总和II" class="headerlink" title="LeetCode 113 路径总和II"></a>LeetCode 113 路径总和II</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/path-sum-ii">113.路径总和II</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>和<a href="https://leetcode.cn/problems/path-sum">112.路径总和</a>类似，依然采用递归三部曲来分析：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 要对树进行遍历，当然要传进来当前节点，还需要传进一个数标记当前路径上的节点和是多少，因为我们通过全局的数组来保存结果集，因此像<a href="https://leetcode.cn/problems/path-sum-ii">113.路径总和II</a>一样需要返回值</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> targetSum)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 终止条件是遍历到叶节点结束，如果当前路径的和等于targetSum，表明这条路径是我们需要的，返回上一层的时候将该路径加入结果集；如果当前路径的和不等于targetSum，直接返回上层，不需要保存到结果集</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 和<a href="https://leetcode.cn/problems/path-sum-ii">113.路径总和II</a>类似，只是多了一些步骤。在遍历之前将节点值保存到path数组里，在回溯的时候，从path数组弹出值</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(node-&gt;left-&gt;val);</span><br><span class="line">    targetSum -= node-&gt;left-&gt;val;</span><br><span class="line">    <span class="built_in">traversal</span>(node-&gt;left,targetSum);</span><br><span class="line">    targetSum += node-&gt;left-&gt;val;       <span class="comment">//回溯</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(node-&gt;right-&gt;val);</span><br><span class="line">    targetSum -= node-&gt;right-&gt;val;</span><br><span class="line">    <span class="built_in">traversal</span>(node-&gt;right,targetSum);</span><br><span class="line">    targetSum += node-&gt;right-&gt;val;      <span class="comment">//回溯</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span> &amp;&amp; targetSum == <span class="number">0</span>) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(node-&gt;left-&gt;val);</span><br><span class="line">            targetSum -= node-&gt;left-&gt;val;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;left,targetSum);</span><br><span class="line">            targetSum += node-&gt;left-&gt;val;       <span class="comment">//回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(node-&gt;right-&gt;val);</span><br><span class="line">            targetSum -= node-&gt;right-&gt;val;</span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;right,targetSum);</span><br><span class="line">            targetSum += node-&gt;right-&gt;val;      <span class="comment">//回溯</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="type">int</span> targetSum) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(root,targetSum-(root-&gt;val));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-106-从中序与后序遍历序列构造二叉树"><a href="#LeetCode-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="LeetCode 106 从中序与后序遍历序列构造二叉树"></a>LeetCode 106 从中序与后序遍历序列构造二叉树</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal">106.从中序与后序遍历序列构造二叉树</a></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p><strong>我们应该如何通过两个遍历序列构造二叉树？</strong> 因为篇幅有限，大家可以从视频<a href="https://www.bilibili.com/video/BV1b7411N798/?p=48&share_source=copy_web&vd_source=0db260a29b428cc91330eced2669ad8a">王道计算机考研 数据结构</a>中自行学习，此处就不过多叙述。</p><p>既然我们知道了如何通过两个遍历序列构造二叉树，<strong>那么代码应该如何写呢？</strong> 说到一层一层切割，就应该想到了递归。</p><ol><li><p>后序数组为0，空节点</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure></li><li><p>后序数组最后一个元素为节点元素</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br></pre></td></tr></table></figure></li><li><p>寻找中序数组位置作为切割点</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> delimiterIndex;</span><br><span class="line"><span class="keyword">for</span>(delimiterIndex = <span class="number">0</span>;delimiterIndex &lt; inorder.<span class="built_in">size</span>();delimiterIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>切中序数组。delimiterIndex作为中序遍历数组切分左右区间的标记点</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左闭右开 [0,delimiterIndex)  [delimiterIndex+1,end]</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">leftInorder</span>(inorder.<span class="built_in">begin</span>(),inorder.<span class="built_in">begin</span>()+delimiterIndex);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">rightInorder</span>(inorder.<span class="built_in">begin</span>()+delimiterIndex<span class="number">+1</span>,inorder.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li><li><p>切后序数组。使用左中序数组大小作为切割点</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历舍弃末尾元素</span></span><br><span class="line">postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//左闭右开</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">leftPostorder</span>(postorder.<span class="built_in">begin</span>(),postorder.<span class="built_in">begin</span>()+leftInorder.<span class="built_in">size</span>());</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">rightPostorder</span>(postorder.<span class="built_in">begin</span>()+leftInorder.<span class="built_in">size</span>(),postorder.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></li><li><p>递归处理左右后区间</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left = <span class="built_in">traversal</span>(leftInorder,leftPostorder);</span><br><span class="line">root-&gt;right = <span class="built_in">traversal</span>(rightInorder,rightPostorder);</span><br></pre></td></tr></table></figure></li></ol><p>接着就是递归三要素分析：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 我们每次递归是要处理左右区间，而左右区间的划分就是根据inorder和postorder数组来划分，所以要把两个数组作为参数传入。此外，每次划分左右数组之后会找到一个根节点，所以返回值是TreeNode*</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 如果遍历到的后序数组为0，表示这颗子树已经遍历完了，直接返回nullptr；如果遍历到的后序数组只有1个节点，那么直接把他作为根节点返回</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//叶子节点</span></span><br><span class="line"><span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 单层递归的逻辑就是上述的6个步骤</p></li></ol><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">traversal</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果postorder只有一个节点，该节点即是根节点，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在中序遍历中找到切割点</span></span><br><span class="line">        <span class="type">int</span> delimiterIndex;</span><br><span class="line">        <span class="keyword">for</span>(delimiterIndex = <span class="number">0</span>;delimiterIndex &lt; inorder.<span class="built_in">size</span>();delimiterIndex++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将中序数组切割成左闭右开区间  [0,delimiterIndex)  [delimiterIndex+1,end)</span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">leftInorder</span>(inorder.<span class="built_in">begin</span>(),inorder.<span class="built_in">begin</span>() + delimiterIndex);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">rightInorder</span>(inorder.<span class="built_in">begin</span>() + delimiterIndex + <span class="number">1</span>,inorder.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//舍弃后序遍历数组末尾元素</span></span><br><span class="line">        postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//将后序数组切割成左闭右开区间 </span></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">leftPostorder</span>(postorder.<span class="built_in">begin</span>(),postorder.<span class="built_in">begin</span>() + leftInorder.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">rightPostorder</span>(postorder.<span class="built_in">begin</span>() + leftInorder.<span class="built_in">size</span>(),postorder.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归遍历左右区间</span></span><br><span class="line">        root-&gt;left = <span class="built_in">traversal</span>(leftInorder,leftPostorder);</span><br><span class="line">        root-&gt;right = <span class="built_in">traversal</span>(rightInorder,rightPostorder);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span> || postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">traversal</span>(inorder,postorder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可调用对象包装器、绑定器</title>
      <link href="/posts/37637.html"/>
      <url>/posts/37637.html</url>
      
        <content type="html"><![CDATA[<h1 id="可调用对象"><a href="#可调用对象" class="headerlink" title="可调用对象"></a>可调用对象</h1><p>在C++中存在<code>可调用对象</code>这么一个概念。准确来说，可调用对象有如下几种定义：</p><ul><li><p><code>是一个函数指针</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义函数指针</span></span><br><span class="line"><span class="built_in">int</span> (*func)(<span class="type">int</span>, <span class="type">double</span>) = &amp;print;</span><br></pre></td></tr></table></figure></li><li><p><code>是一个具有 operator() 成员函数的类对象（仿函数）</code></p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="comment">//重载()操作符</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string msg)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;msg: &quot;</span> &lt;&lt; msg &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="built_in">t</span>(<span class="string">&quot;我是要成为海贼王的男人！&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>是一个可被转换为函数指针的类对象</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>, string);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">(<span class="type">int</span> a, string b)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> a, string b)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 将类对象转换为函数指针</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">func_ptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//此处只能返回print，不能返回hello</span></span><br><span class="line">        <span class="comment">//因为hello非静态的，它是要在创建对象之后才能存在</span></span><br><span class="line">        <span class="keyword">return</span> print;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="comment">// 将对象转换为函数指针 并调用</span></span><br><span class="line">    <span class="built_in">t</span>(<span class="number">19</span>, <span class="string">&quot;Monkey D. Luffy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>是一个类成员函数指针或者类成员指针</code></p></li></ul><p>在上面的例子中满足条件的这些可调用对象对应的类型被统称为<code>可调用类型</code>。在C++中可调用类型的定义方式五花八门，这样在我们试图使用统一的方式保存，或者传递一个可调用对象时会十分繁琐。现在，<code>C++11通过提供std::function 和 std::bind统一了可调用对象的各种操作</code></p><h1 id="可调用对象包装器"><a href="#可调用对象包装器" class="headerlink" title="可调用对象包装器"></a>可调用对象包装器</h1><p><code>std::function是可调用对象的包装器。它是一个类模板，可以容纳除了类(非静态)成员（函数）指针之外的所有可调用对象。通过指定它的模板参数，它可以用统一的方式处理函数、函数对象、函数指针，并允许保存和延迟执行它们。</code></p><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>std::function必须要包含<code>functional</code>的头文件，可调用对象包装器语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line">std::function&lt;返回值类型(参数类型列表)&gt;diy_name = 可调用对象;</span><br></pre></td></tr></table></figure><p>下面的实例代码中演示了可调用对象包装器的基本使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; + &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a - b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; a * b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//绑定普通函数</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;f1 = add;</span><br><span class="line"><span class="comment">//绑定静态成员函数</span></span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;f2 = T1::sub;</span><br><span class="line"><span class="comment">//绑定仿函数</span></span><br><span class="line">T2 t;</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;f3 = t;</span><br><span class="line"><span class="comment">//绑定可转换位函数指针的对象</span></span><br><span class="line">T2 t1;</span><br><span class="line">function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt;f4 = t1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数调用</span></span><br><span class="line"><span class="built_in">f1</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">f2</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">f3</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">f4</span>(<span class="number">9</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span> + <span class="number">3</span> = <span class="number">12</span></span><br><span class="line"><span class="number">9</span> - <span class="number">3</span> = <span class="number">6</span></span><br><span class="line"><span class="number">9</span> * <span class="number">3</span> = <span class="number">27</span></span><br><span class="line"><span class="number">9</span> * <span class="number">3</span> = <span class="number">27</span></span><br></pre></td></tr></table></figure><p><code>通过测试代码可以得到结论：std::function可以将可调用对象进行包装，得到一个统一的格式，包装完成得到的对象相当于一个函数指针，和函数指针的使用方式相同，通过包装器对象就可以完成对包装的函数的调用了。</code></p><h2 id="作为回调函数使用"><a href="#作为回调函数使用" class="headerlink" title="作为回调函数使用"></a>作为回调函数使用</h2><p>因为回调函数本身就是通过函数指针实现的，<code>使用对象包装器可以取代函数指针的作用</code>，来看一下下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//构造函数的参数是一个包装器对象</span></span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> function&lt;<span class="built_in">void</span>()&gt;&amp; f) : <span class="built_in">callback</span>(f) &#123;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">callback</span>();<span class="comment">//调用通过构造函数得到的函数指针</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">function&lt;<span class="type">void</span>()&gt;callback;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我是要成为海贼王的男人!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">B b;</span><br><span class="line"><span class="function">A <span class="title">a</span><span class="params">(b)</span></span>;<span class="comment">// 仿函数通过包装器对象进行包装</span></span><br><span class="line">a.<span class="built_in">notify</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面例子可以看出，使用对象包装器<code>std::function</code>可以非常方便的将仿函数转换为一个函数指针，通过进行函数指针的传递，在其他函数的合适的位置就可以调用这个包装好的仿函数了。</p><h1 id="绑定器"><a href="#绑定器" class="headerlink" title="绑定器"></a>绑定器</h1>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树part03</title>
      <link href="/posts/34208.html"/>
      <url>/posts/34208.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-110-平衡二叉树"><a href="#LeetCode-110-平衡二叉树" class="headerlink" title="LeetCode 110 平衡二叉树"></a>LeetCode 110 平衡二叉树</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/balanced-binary-tree">110.平衡二叉树</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>平衡二叉树是指该树所有节点的左右子树的高度相差不超过1。</strong> 既然要求左右子树的高度，那必然涉及到树的遍历，和<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">104.二叉树的最大深度</a>题目一样，要求求左右子树的高度，因此选择后序遍历。</p><p>接着就是我们最熟悉的递归三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 我们要只需要传入当前节点即可，返回值就返回子树的高度</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 递归过程中遇到了空节点表示终止</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 首先明确一点的是，我们采取的遍历方式是后序遍历，即左右中。再求出左右子树高度之后我们还需要判断左右子树的差值是否小于等于1，如果某一颗子树高度差没有满足要求（即高度差大于1），此时整棵树就已经不再是平衡二叉树了，通过-1标记该子树的高度。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);             <span class="comment">//左</span></span><br><span class="line"><span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line"><span class="comment">//如果左子树或者右子树有不满足的情况，后序就不需要判断了，一直向上层返回即可</span></span><br><span class="line"><span class="keyword">if</span>(leftHeight == <span class="number">-1</span> || rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> gapHeight = <span class="built_in">abs</span>(leftHeight-rightHeight);        <span class="comment">//右</span></span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"><span class="comment">//如果高度差大于1，这棵子树就不平衡，整棵树也不是平衡二叉树，标记-1</span></span><br><span class="line"><span class="keyword">if</span>(gapHeight &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    result = <span class="built_in">max</span>(leftHeight,rightHeight) + <span class="number">1</span>;       <span class="comment">//中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(node-&gt;left);         <span class="comment">//左</span></span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(leftHeight == <span class="number">-1</span> || rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> gapHeight = <span class="built_in">abs</span>(leftHeight-rightHeight);    <span class="comment">//右</span></span><br><span class="line">        <span class="type">int</span> result;</span><br><span class="line">        <span class="comment">//如果高度差大于1，这棵子树就不平衡，整棵树也不是平衡二叉树，标记-1</span></span><br><span class="line">        <span class="keyword">if</span>(gapHeight &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            result = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            result = <span class="built_in">max</span>(leftHeight,rightHeight) + <span class="number">1</span>;   <span class="comment">//中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果其中有子树被标记-1，那就不是一颗平衡二叉树</span></span><br><span class="line">        <span class="type">bool</span> ret = (<span class="built_in">getHeight</span>(root) == <span class="number">-1</span> ? <span class="literal">false</span> : <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-257-二叉树的所有路径"><a href="#LeetCode-257-二叉树的所有路径" class="headerlink" title="LeetCode 257 二叉树的所有路径"></a>LeetCode 257 二叉树的所有路径</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/binary-tree-paths">257.二叉树的所有路径</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题目要求从根节点到叶子的路径，所以需要前序遍历，这样才方便让父节点指向孩子节点，找到对应的路径。在这道题目中将第一次涉及到回溯，因为我们要把路径记录下来，需要回溯来回退一个路径再进入另一个路径。</p><p>接着就是递归三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 传入当前的节点，记录每一条路径path，和存放所有结果的结果集result，不需要返回值</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node,vector&lt;<span class="type">int</span>&gt;&amp; path,vector&lt;string&gt;&amp; result)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 只有到了叶节点才记录了一条完整的路径path，此时才能返回到上一层</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">//终止处理逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 因为是前序遍历，先处理中间节点，在处理左右节点。我们每次遍历中间节点时，要将该节点的值放进path中，然后就是递归和回溯的过程。我们一直向下查找的过程就是递归的过程，当我们找到叶子节点后，表明我们得到了一条完整的路径</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时还没完，递归完，要做回溯啊，因为path 不能一直加入节点，它还要删节点，然后才能加入新的节点。那么回溯要怎么回溯呢，一些同学会这么写，如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur-&gt;left) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, path, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;right) &#123;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, path, result);</span><br><span class="line">&#125;</span><br><span class="line">path.<span class="built_in">pop_back</span>();</span><br></pre></td></tr></table></figure><p>这个回溯就有很大的问题，我们知道，<strong>回溯和递归是一一对应的，有一个递归，就要有一个回溯</strong>，这么写的话相当于把递归和回溯拆开了， 一个在花括号里，一个在花括号外。**所以回溯要和递归永远在一起，世界上最遥远的距离是你在花括号里，而我在花括号外！**那么代码应该这么写：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node-&gt;left) &#123;            <span class="comment">//左</span></span><br><span class="line">    <span class="built_in">traversal</span>(node-&gt;left,path,result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();        <span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;right) &#123;            <span class="comment">//右</span></span><br><span class="line">    <span class="built_in">traversal</span>(node-&gt;right,path,result);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();        <span class="comment">//回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* node,vector&lt;<span class="type">int</span>&gt;&amp; path,vector&lt;string&gt;&amp; result)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先加入节点再判断左右孩子是否为空</span></span><br><span class="line">        <span class="comment">//这样判断到叶节点的时候，先加入再判断为空返回</span></span><br><span class="line">        <span class="comment">//如果反过来，叶子节点就不会加入到path里，而是直接返回了</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(node-&gt;val);      <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            string sPath;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; path.<span class="built_in">size</span>()<span class="number">-1</span>;i++) &#123;</span><br><span class="line">                sPath += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">                sPath += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sPath += <span class="built_in">to_string</span>(path[path.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(sPath);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left) &#123;            <span class="comment">//左</span></span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;left,path,result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();        <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right) &#123;            <span class="comment">//右</span></span><br><span class="line">            <span class="built_in">traversal</span>(node-&gt;right,path,result);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();        <span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line">        vector&lt;string&gt;result;</span><br><span class="line">        <span class="built_in">traversal</span>(root,path,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-404-左叶子之和"><a href="#LeetCode-404-左叶子之和" class="headerlink" title="LeetCode 404 左叶子之和"></a>LeetCode 404 左叶子之和</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/sum-of-left-leaves">404.左叶子之和</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>还是一样的套路，确定遍历方式并且编写递归三要素。首先要明确的一点是，**判断当前节点是不是左叶子是无法判断的，必须要通过节点的父节点来判断其左孩子是不是左叶子。**如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，可以写出如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;left-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    左叶子节点处理逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们要通过递归函数的返回值来累加求取左叶子数值之和，递归的遍历顺序为<strong>中序遍历</strong>。接着来看看递归三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong>  因为只需要遍历，不需要保存数值，所以参数传入节点即可，此外，我们还需要返回子树内左叶子值之和</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getLeaves</span><span class="params">(TreeNode* node)</span> </span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 我们一路向”左”找到最”左”的节点。即使当前节点是左叶子节点，但是自己是无法判断自己是否是左叶子的，当向上层回溯的时候（即处理中间节点），我们就可以通过<code>if(node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right)</code>判断刚才的节点是否为左叶子节点。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftValue = <span class="built_in">getLeaves</span>(node-&gt;left);                          <span class="comment">//左</span></span><br><span class="line"><span class="keyword">if</span>(node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right) &#123;     <span class="comment">//中</span></span><br><span class="line">    leftValue = node-&gt;left-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> rightValue = <span class="built_in">getLeaves</span>(node-&gt;right);                        <span class="comment">//右</span></span><br><span class="line"><span class="keyword">return</span> leftValue + rightValue;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLeaves</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftValue = <span class="built_in">getLeaves</span>(node-&gt;left);                          <span class="comment">//左</span></span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left &amp;&amp; !node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right) &#123;     <span class="comment">//中</span></span><br><span class="line">            leftValue = node-&gt;left-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> rightValue = <span class="built_in">getLeaves</span>(node-&gt;right);                        <span class="comment">//右</span></span><br><span class="line">        <span class="keyword">return</span> leftValue + rightValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> leftSum = <span class="built_in">getLeaves</span>(root);</span><br><span class="line">        <span class="keyword">return</span> leftSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-222-完全二叉树的节点个数"><a href="#LeetCode-222-完全二叉树的节点个数" class="headerlink" title="LeetCode 222 完全二叉树的节点个数"></a>LeetCode 222 完全二叉树的节点个数</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/count-complete-tree-nodes">222.完全二叉树的节点个数</a></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>没啥好说的，就是通过树的遍历来统计节点个数，可以是前序遍历、中序遍历、后序遍历或层序遍历</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt;que;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            result += size;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">traversal</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftNum = <span class="built_in">traversal</span>(node-&gt;left);        <span class="comment">//左</span></span><br><span class="line">        <span class="type">int</span> rightNum = <span class="built_in">traversal</span>(node-&gt;right);      <span class="comment">//右</span></span><br><span class="line">        <span class="type">int</span> num = leftNum + rightNum + <span class="number">1</span>;           <span class="comment">//中</span></span><br><span class="line">        <span class="keyword">return</span> num;                   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> num = <span class="built_in">traversal</span>(root);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于范围的for循环</title>
      <link href="/posts/7467.html"/>
      <url>/posts/7467.html</url>
      
        <content type="html"><![CDATA[<h1 id="for循环新语法"><a href="#for循环新语法" class="headerlink" title="for循环新语法"></a>for循环新语法</h1><p>在C++98&#x2F;03中普通的for循环，语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式 <span class="number">1</span>; 表达式 <span class="number">2</span>; 表达式 <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++11基于范围的for循环，语法格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>declaration</code>表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。<code>expression</code>是要遍历的对象，它可以是<code>表达式、容器、数组、初始化列表</code>等。接着我们通过一个示例来看看新的for循环的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ret&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : ret) &#123;</span><br><span class="line">cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，<code>是将容器中遍历的当前元素拷贝到了声明变量it中，因此无法对容器中的元素进行写操作，如果需要在遍历过程中修改元素的值，需要使用引用</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;ret&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;遍历之前的容器元素：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : ret) &#123;</span><br><span class="line">cout &lt;&lt; it++ &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;遍历修改之后的容元素：&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : ret) &#123;</span><br><span class="line">cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">遍历之前的容器元素：<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br><span class="line">遍历修改之后的容元素：<span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>如果我们在遍历过程中只允许读数据，不允许修改数据，可以使用<code>const</code>进行修饰，在定义的时候建议使用<code>const auto&amp;</code>，这样相对于<code>const auto</code>效率要更高一些。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; it : ret) &#123;</span><br><span class="line">    cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h1><h2 id="关系型容器"><a href="#关系型容器" class="headerlink" title="关系型容器"></a>关系型容器</h2><p>使用基于范围的for循环有一些需要注意的细节，先来看一下对关系型容器map的遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;m&#123; &#123;<span class="number">1</span>,<span class="string">&quot;lucy&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;lily&quot;</span>&#125;,&#123;<span class="number">3</span>,<span class="string">&quot;tom&quot;</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;,name: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : m) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; it.first &lt;&lt; <span class="string">&quot;,name: &quot;</span> &lt;&lt; it.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中使用两种方式对map进行了遍历，通过对比有两点需要注意的事项：</p><ol><li><code>使用普通的for循环（基于迭代器）遍历关联性容器，auto自动推导出的是一个迭代器类型</code>，需要使用迭代器的方式取出元素中的键值对（和指针的方法相同）：<ul><li>it-&gt;first</li><li>it-&gt;second</li></ul></li><li><code>使用基于范围的for循环遍历关联性容器，auto自动推导出的类型是容器中的value_type</code>，相当于一个数组（std::pair）对象，提取键值对的方式如下：<ul><li>it.first</li><li>it.second</li></ul></li></ol><h2 id="元素只读"><a href="#元素只读" class="headerlink" title="元素只读"></a>元素只读</h2><p>刚才的案例可知，在for循环内部声明一个<code>变量的引用</code>就可以在遍历过程中修改表达式中元素的值，但这并不适用于所有情况。<code>对应set容器来说，内部元素都是只读的（这是由容器的特性决定的），因此在for循环中auto&amp;会被视为const auto &amp;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;st&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : st) &#123;</span><br><span class="line">cout &lt;&lt; it++ &lt;&lt; endl;    <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，<code>在遍历关联型容器时也会出现同样的问题，基于范围的for循环中，虽然可以得到一个std::pair引用，但是我们是不能修改里边的first值的，也就是key值。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;m&#123; &#123;<span class="number">1</span>,<span class="string">&quot;lucy&quot;</span>&#125;,&#123;<span class="number">2</span>,<span class="string">&quot;lily&quot;</span>&#125;,&#123;<span class="number">3</span>,<span class="string">&quot;tom&quot;</span>&#125; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : m) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; it.first++ &lt;&lt; <span class="string">&quot;,name: &quot;</span> &lt;&lt; it.second &lt;&lt; endl;<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问次数"><a href="#访问次数" class="headerlink" title="访问次数"></a>访问次数</h2><p>基于范围的for循环遍历的对象可以是一个表达式或者容器&#x2F;数组等。假设我们对一个容器遍历，遍历过程中for循环对这个容器的访问频率是一次还是多次呢？我们通过下面的例子验证一下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">getRange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;get vector range...&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it : <span class="built_in">getRange</span>()) &#123;</span><br><span class="line">cout &lt;&lt; it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get vector range...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>从上面的结果可以看出，不论基于范围的for循环迭代了多少次，函数getRange()只在第一次迭代之前被调用，得到这个容器对象之后就不会再去重新获取这个对象了。</p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树part02</title>
      <link href="/posts/17441.html"/>
      <url>/posts/17441.html</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-226-翻转二叉树"><a href="#LeetCode-226-翻转二叉树" class="headerlink" title="LeetCode 226 翻转二叉树"></a>LeetCode 226 翻转二叉树</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/invert-binary-tree">226.翻转二叉树</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们发现要翻转二叉树，其实就是把每个节点的左右子树（孩子）进行交换即可，关键在于遍历顺序，<strong>我们应该选择哪一种顺序进行遍历呢？</strong></p><p>这道题目<strong>前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次！建议拿纸画一画，就理解了</strong></p><p>那么层序遍历可以吗</p><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>接着我们根据递归三要素来写递归代码：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 我们只需要传入节点的指针，不需要其他参数了。返回值的话其实也不需要，但是题目中给出的要返回root节点的指针，可以直接使用题目定义好的函数，所以就函数的返回类型为TreeNode。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件</strong></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 因为是前序遍历，所以先进行交换左右孩子节点，然后交换左右子树（孩子），继续向下遍历</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(root-&gt;left, root-&gt;right);</span><br><span class="line"><span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line"><span class="built_in">invertTree</span>(root-&gt;right);</span><br></pre></td></tr></table></figure></li></ol><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>上一篇文章中给出了前中后序迭代方式的写法，所以本题可以很轻松的写出迭代法的代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="递归法-1"><a href="#递归法-1" class="headerlink" title="递归法"></a>递归法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代法-1"><a href="#迭代法-1" class="headerlink" title="迭代法"></a>迭代法</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(node-&gt;left,node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt;que;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">swap</span>(node-&gt;left, node-&gt;right);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-101-对称二叉树"><a href="#LeetCode-101-对称二叉树" class="headerlink" title="LeetCode 101 对称二叉树"></a>LeetCode 101 对称二叉树</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/symmetric-tree">101.对称二叉树</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>我们要比较的是两个子树的内侧节点和外侧节点是否对称。例如下图，我们用两个指针分别指向左右子树的节点2，然后递归比较2号节点的左孩子和右孩子（q1和q2指针），再比较2号节点的右孩子和左孩子（t1和t2指针）</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong> 我们要比较的是当前节点的左右子树是否对称，我们需要访问该节点左右孩子，因此，我们要将两个根节点作为参数传入。返回值自然是bool类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left,TreeNode* right)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 要比较两个节点的值是否相同，首先要比较的是两个节点是否为空的情况弄清楚。当然，节点为空的情况有</p><ul><li>左节点为空，右节点为空，不对称，返回false；</li><li>左节点不为空，右节点为空，不对称，返回false；</li><li>左右都为空，对称，返回true；</li></ul><p> 此时已经排除节点为空的情况了，只需要判断该节点值是否相等即可</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断当前节点是否有缺失的情况</span></span><br><span class="line"><span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//再判断当前节点值是否相等</span></span><br><span class="line"><span class="keyword">if</span>(left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p> 最后的一种情况就是左右节点不为空，且数值相同的情况，也是我们接下来要重点处理的逻辑</p></li><li><p><strong>确定单层递归的逻辑：</strong> 单层递归的逻辑就是处理 左右节点都不为空，且数值相同的情况。</p><ul><li>比较二叉树外侧是否对称：传入的是左节点的左孩子，右节点的右孩子。</li><li>比较内侧是否对称，传入左节点的右孩子，右节点的左孩子。</li><li>如果左右都对称就返回true ，有一侧不对称就返回false。</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果都符合要求，就可以继续向下遍历</span></span><br><span class="line"><span class="type">bool</span> ret1 = <span class="built_in">compare</span>(left-&gt;left,right-&gt;right);</span><br><span class="line"><span class="type">bool</span> ret2 = <span class="built_in">compare</span>(left-&gt;right,right-&gt;left);</span><br><span class="line"><span class="type">bool</span> isRet = ret1 &amp;&amp; ret2;</span><br><span class="line"><span class="keyword">return</span> isRet;</span><br></pre></td></tr></table></figure></li></ol><p>这道题目用了回溯的思想，属于比较有难度的一类方法，回溯法会在后续内容有介绍。</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left,TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断当前节点是否有缺失的情况</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//再判断当前节点值是否相等</span></span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果都符合要求，就可以继续向下遍历</span></span><br><span class="line">        <span class="type">bool</span> ret1 = <span class="built_in">compare</span>(left-&gt;left,right-&gt;right);</span><br><span class="line">        <span class="type">bool</span> ret2 = <span class="built_in">compare</span>(left-&gt;right,right-&gt;left);</span><br><span class="line">        <span class="type">bool</span> isRet = ret1 &amp;&amp; ret2;</span><br><span class="line">        <span class="keyword">return</span> isRet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> result = <span class="built_in">compare</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-104-二叉树的最大深度"><a href="#LeetCode-104-二叉树的最大深度" class="headerlink" title="LeetCode 104 二叉树的最大深度"></a>LeetCode 104 二叉树的最大深度</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">104.二叉树的最大深度</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>这道题目我打算用层序遍历和递归法两种思路求解</p><h3 id="层序遍历-1"><a href="#层序遍历-1" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>没什么说的，在上一小节的层序遍历的代码模板中稍微修改一下即可</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>本题可以使用前序（中左右），也可以使用后序遍历（左右中），使用前序求的就是深度，使用后序求的是高度。</p><ul><li>二叉树节点的深度：指从根节点到<strong>该节点</strong>的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</li><li>二叉树节点的高度：指从该节点到<strong>叶子节点</strong>的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）</li></ul><p><strong>而根节点的高度就是二叉树的最大深度</strong>，所以本题中我们通过后序求的根节点高度来求的二叉树最大深度。</p><p>依旧是我们熟悉的递归三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong>  因为只需要遍历，不需要保存数值，所以参数传入节点即可，此外，我们还需要返回当前子树的高度</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 如果节点为空，就返回0，表示以该节点为根节点的子树高度为0</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 后序遍历是左右中的顺序，所以在单层递归的逻辑，先分别遍历左右孩子（左右子树），再取中间节点的数值。当然，别忘了定义变量接收左右子树返回的高度</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);</span><br><span class="line"><span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);</span><br><span class="line"><span class="type">int</span> depth = <span class="built_in">max</span>(leftDepth,rightDepth) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> depth;</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><h3 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);</span><br><span class="line">        <span class="type">int</span> depth = <span class="built_in">max</span>(leftDepth,rightDepth) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="built_in">getDepth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="层序遍历-2"><a href="#层序遍历-2" class="headerlink" title="层序遍历"></a>层序遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt;que;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> depth;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-111-二叉树的最小深度"><a href="#LeetCode-111-二叉树的最小深度" class="headerlink" title="LeetCode 111 二叉树的最小深度"></a>LeetCode 111 二叉树的最小深度</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree">111.二叉树的最小深度</a></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>和<a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree">104.二叉树的最大深度</a>题目类似，都可以采用层序遍历或者递归方法进行求解。</p><h3 id="递归-2"><a href="#递归-2" class="headerlink" title="递归"></a>递归</h3><p>依然是熟悉的递归三要素：</p><ol><li><p><strong>确定递归函数的参数和返回值：</strong>  因为只需要遍历，不需要保存数值，所以参数传入节点即可。我们还需要返回</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>确定终止条件：</strong> 如果节点为空，就返回0，表示以该节点为根节点的子树高度为0</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>确定单层递归的逻辑：</strong> 后序遍历是左右中的顺序，所以在单层递归的逻辑，先分别遍历左右孩子（左右子树），再取中间节点的数值。当然，别忘了定义变量接收左右子树返回的高度</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);</span><br><span class="line"><span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);</span><br><span class="line"><span class="type">int</span> depth = <span class="built_in">min</span>(leftDepth,rightDepth) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> depth;</span><br></pre></td></tr></table></figure></li></ol><p>是不是很简单，但是当我们运行的时候就会发现代码逻辑出错了。本题还有一个误区，在处理节点的过程中，最大深度很容易理解，最小深度就不那么好理解，如图：</p><p>如果按照上述代码求解的话，没有左孩子的分支会被记为最短深度，这显然是不合理的。所以，我么应该分成如下情况进行分析：</p><ul><li>如果左子树为空，右子树不为空，说明最小深度是<code>1+右子树深度</code></li><li>反之，如果右子树为空，左子树不为空，说明最小深度是<code>1+左子树深度</code></li><li>如果左右子树都不为空，返回<code>左右子树深度最小值+1</code></li></ul><p>因此，递归三要素最后一要素的代码逻辑修改如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);</span><br><span class="line"><span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);</span><br><span class="line"><span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> depth = <span class="built_in">min</span>(leftDepth,rightDepth) + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> depth;</span><br></pre></td></tr></table></figure><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><h3 id="递归-3"><a href="#递归-3" class="headerlink" title="递归"></a>递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getDepth</span><span class="params">(TreeNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="built_in">getDepth</span>(node-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightDepth = <span class="built_in">getDepth</span>(node-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">nullptr</span> &amp;&amp; node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left != <span class="literal">nullptr</span> &amp;&amp; node-&gt;right == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftDepth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> depth = <span class="built_in">min</span>(leftDepth,rightDepth) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> depth = <span class="built_in">getDepth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt;que;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) &#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                    flag++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) &#123;</span><br><span class="line">                    que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">                    flag++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//没有左右孩子</span></span><br><span class="line">                <span class="keyword">if</span>(flag == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列表初始化</title>
      <link href="/posts/43211.html"/>
      <url>/posts/43211.html</url>
      
        <content type="html"><![CDATA[<h1 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h1><p>在C++98&#x2F;03中初始化数据方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">double</span> salary;</span><br><span class="line">&#125;huang&#123; <span class="number">1</span>,<span class="number">3000</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组初始化</span></span><br><span class="line"><span class="type">int</span> array[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span> &#125;;</span><br></pre></td></tr></table></figure><p>而在C++11中，列表初始化的方式变得更灵活了，下面来看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> num) : <span class="built_in">m_num</span>(num) &#123;&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> num, string name) : <span class="built_in">m_num</span>(num), <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line">string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用初始化列表初始化对象</span></span><br><span class="line"><span class="function">Person <span class="title">t1</span><span class="params">(<span class="number">500</span>)</span></span>;</span><br><span class="line">Person t2 = <span class="number">520</span>;</span><br><span class="line">Person t3 = &#123; <span class="number">520</span> &#125;;</span><br><span class="line">Person t4&#123; <span class="number">520</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用初始化列表初始化数组</span></span><br><span class="line">    <span class="type">int</span> a1 = &#123; <span class="number">1314</span> &#125;;</span><br><span class="line"><span class="type">int</span> a2&#123; <span class="number">1314</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr2[]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面解释一下上面代码的各种初始化方式：</p><ul><li><code>t1</code>: 最中规中距的初始化方式，也是最常用的方式，通过有参构造进行对象的初始化</li><li><code>t2</code>: 因为提供的拷贝构造函数是公共的，因此会发生隐式类型转换。编译器会先看Person类有没有带整形的构造函数，如果提供了，那么编译器在执行期间会自动地将520构造成Person对象，再把这个Person对象赋值成t2</li><li><code>t3</code>和<code>t4</code>: 使用了C++11的初始化方式来初始化对象，效果和t1的方式是相同的。</li></ul><p>既然使用列表初始化可以对普通类型以及对象进行直接初始化，那么在使用 new 操作符创建新对象的时候可以使用列表初始化进行对象的初始化吗？答案是肯定的，来看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">520</span> &#125;;</span><br><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span>&#123; <span class="number">52.1314</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li><code>指针p</code>: 指向一个new操作符返回的内存，通过列表初始化将内存数据初始化为520</li><li><code>数组array</code>: 在堆上动态分配了一块内存，通过列表初始化的方式直接完成了多个元素的初始化。</li><li><code>变量b</code>: 对匿名对象使用列表初始之后，再进行拷贝初始化。</li></ul><p><code>上述这么多初始化方式并不需要每个都记住，我们只需要记住那些最常用的方式即可，那什么是最常用的呢？那就要靠自己多看代码了</code></p><h1 id="列表初始化细节"><a href="#列表初始化细节" class="headerlink" title="列表初始化细节"></a>列表初始化细节</h1><h2 id="聚合体"><a href="#聚合体" class="headerlink" title="聚合体"></a>聚合体</h2><p>什么是聚合体？聚合体要满足以下五个条件：</p><ul><li>无用户定义的构造函数</li><li>无私有或保护的非静态数据成员</li><li>无基类</li><li>无虚函数</li><li>类中不能有使用{}和&#x3D;直接初始化的非静态数据成员（c++14以后支持）</li></ul><p>在C++11中，列表初始化的范围被大大增强了，但有一些模糊的概念也随之而来，在前面的例子可以得知，列表初始化可以用于自定义类型的初始化，但是对于一个自定义类型，列表初始化可能有两种执行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;a = &#123; <span class="number">123</span>, <span class="number">321</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">T2</span>(<span class="type">int</span>,<span class="type">int</span>) : <span class="built_in">x</span>(<span class="number">10</span>), <span class="built_in">y</span>(<span class="number">20</span>) &#123;&#125;</span><br><span class="line">&#125;b = &#123; <span class="number">123</span>,<span class="number">321</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a.x: &quot;</span> &lt;&lt; a.x &lt;&lt; <span class="string">&quot;, a.y: &quot;</span> &lt;&lt; a.y &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b.x: &quot;</span> &lt;&lt; b.x &lt;&lt; <span class="string">&quot;, b.y: &quot;</span> &lt;&lt; b.y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.x: <span class="number">123</span>, a.y: <span class="number">321</span></span><br><span class="line">b.x: <span class="number">10</span>, b.y: <span class="number">20</span></span><br></pre></td></tr></table></figure><p>上述的两个程序都是用列表初始化的方式对对象进行了初始化，但是得到结果却不同，对象b并没有被初始化列表中的数据初始化，这是为什么呢？这是因为：</p><ul><li><code>对象a是对一个自定义的聚合类型进行初始化，它将以拷贝的形式使用初始化列表中的数据来初始化T1结构体中的域成员</code></li><li><code>结构体T2自定义了一个构造函数，因此实际的初始化是通过这个构造函数完成的。</code></li></ul><p>现在是不是有些混乱了，同样都是自定义类型并且都是在创建对象的时候都使用了列表初始化来初始化对象，为什么在类内部对对象的初始化方式却不一样呢？<code>这是因为，如果使用列表初始化对对象初始化时，还需要判断这个对象对应的类型是不是一个聚合体，如果是聚合类，那么初始化列表中的数据就会拷贝到对象中；反之，如果不是聚合类，那么就不能通过初始化列表进行初始化</code></p><p>那么，使用列表初始化时，对于什么样的类型C++会认为它是一个聚合体呢？</p><ul><li><p>普通数组本身可以看做是一个聚合类型</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">double</span> y[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">&#123;<span class="number">1.23</span>, <span class="number">2.34</span>, <span class="number">3.45</span>&#125;,</span><br><span class="line">&#123;<span class="number">4.56</span>, <span class="number">5.67</span>, <span class="number">6.78</span>&#125;,</span><br><span class="line">&#123;<span class="number">7.89</span>, <span class="number">8.91</span>, <span class="number">9.99</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> carry[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">std::string sarry[] = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;nihao&quot;</span>, <span class="string">&quot;shijie&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>我们通过这个例子可以得出一个结论：<code>如果初始化列表初始化的变量是一个聚合体类型，那么就可以直接把&#123;&#125;写在变量后面，例如上述代码可写成 int x[]&#123;1,2,3&#125;；如果是非聚合类型，那么就要给它提供构造函数进行初始化</code></p></li><li><p>满足聚合体四个定义的类（class、struct、union）可以被看做是一个聚合类型。</p><ul><li><p>无用户定义的构造函数</p></li><li><p>无私有或保护的非静态数据成员</p><p><code>场景1：类中有私有成员，无法使用列表初始化进行初始化</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;a &#123; <span class="number">123</span>, <span class="number">321</span>, <span class="number">2</span> &#125;;<span class="comment">//报错，类中有私有成员, 无法使用初始化列表初始化</span></span><br></pre></td></tr></table></figure><p><code>场景2：类中的非静态成员可以通过列表初始化进行初始化，但它不能初始化静态数据成员</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line">&#125;a &#123; <span class="number">123</span>, <span class="number">321</span>, <span class="number">2</span> &#125;;<span class="comment">//报错，报错信息：初始值设定项太多</span></span><br></pre></td></tr></table></figure><p><code>结构体中的静态变量 z 不能使用列表初始化进行初始化，它的初始化遵循静态成员的初始化方式（可使用全局初始化）</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line">&#125;a &#123; <span class="number">123</span>, <span class="number">321</span> &#125;;    <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T1::z = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>无基类</p></li><li><p>无虚函数（virtual）</p></li><li><p>类中不能有使用<code>&#123;&#125;</code>和<code>=</code>直接初始化的非静态数据成员（c++14以后支持）。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T3</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">int</span> z[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">T3 <span class="title">t</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, &#123; <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125;)</span></span>;<span class="comment">//报错，C++11不支持，C++14支持</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="非聚合体"><a href="#非聚合体" class="headerlink" title="非聚合体"></a>非聚合体</h2><p><code>对于聚合类型的类可以直接使用列表初始化进行对象的初始化，</code>如果不满足聚合条件还想使用列表初始化其实也是可以的，<code>需要在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化:</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//注意在构造函数中使用初始化列表</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> num,string name) : <span class="built_in">m_num</span>(num), <span class="built_in">m_name</span>(name) &#123;&#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line">string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p&#123; <span class="number">9527</span>,<span class="string">&quot;huang&quot;</span> &#125;;<span class="comment">// ok</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，需要额外注意的是<code>聚合类型的定义并非递归的</code>，也就是说<code>当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型</code>，比如下面的这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span> &#123;</span><br><span class="line">T1 t1;</span><br><span class="line"><span class="type">long</span> x1;</span><br><span class="line"><span class="type">double</span> y1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">T2 t2&#123; &#123;&#125;,<span class="number">520</span>,<span class="number">3.14</span> &#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，T1并发一个聚合类型，因为它有private修饰的非静态成员变量。尽管T2有一个非聚合类型的非静态成员t1，T2依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化。</p><p>最后强调一下t2对象的初始化过程，对于非聚合类型的成员t1做初始化的时候，可以直接写一对空的大括号{}，这相当于调用是T1的无参构造函数。</p><h1 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h1><p>如果想要像STL一样有任意长度初始化的能力，可以使用<code>std::initializer_list</code>这个轻量级的类模板来实现。</p><p>先来介绍一下这个类模板的一些特点：</p><ul><li>它是一个轻量级的容器类型，内部定义了迭代器<code>iterator</code>等容器必须的概念，<code>遍历时得到的迭代器是只读的</code></li><li>对于<code>std::initializer_list&lt;T&gt;</code>而言，它可以接收任意长度的初始化列表，但是<code>要求元素必须是同种类型T</code></li><li>在<code>std::initializer_list</code>内部有三个成员接口：<code>size(), begin(), end()</code></li><li><code>std::initializer_list</code>对象只能被整体初始化或者赋值。</li></ul><h2 id="作为普通函数参数"><a href="#作为普通函数参数" class="headerlink" title="作为普通函数参数"></a>作为普通函数参数</h2><p>如果想要自定义一个函数并且接收任意个数的参数（可变参数），只需要将函数参数指定为<code>std::initializer_list</code>，使用初始化列表<code>&#123; &#125;</code>作为实参进行数据传递即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt;list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it = list.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; it != list.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *(it) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">523</span>,<span class="number">7</span> &#125;);    <span class="comment">//输出：1 2 3 8 523 7</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::initializer_list的效率是非常高的，它的内部并不负责保存初始化列表中元素的拷贝，仅仅存储了初始化列表中元素的引用。</code></p><h2 id="作为构造函数参数"><a href="#作为构造函数参数" class="headerlink" title="作为构造函数参数"></a>作为构造函数参数</h2><p>自定义的类如果在构造对象的时候想要接收任意个数的实参，可以给构造函数指定为<code>std::initializer_list</code>类型，在自定义类的内部还是使用容器来存储接收的多个实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>(initializer_list&lt;string&gt;list) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *(it) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">m_name.<span class="built_in">push_back</span>(*(it));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;string&gt;m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(&#123; <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;lucy&quot;</span>, <span class="string">&quot;tom&quot;</span> &#125;)</span></span>;  <span class="comment">//输出：jack lucy tom</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树part01</title>
      <link href="/posts/17441.html"/>
      <url>/posts/17441.html</url>
      
        <content type="html"><![CDATA[<p><strong>注：因篇幅有限，因此本篇文章不会对二叉树的种类、存储方式展开说明</strong></p><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的遍历</li></ol><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p>以下是分别是前、中、后序遍历的方式：</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>大家可以对着下面的图理解：</p><img src="https://img.imgdd.com/168ebe15-2e9b-4a50-8119-6897f45707a7.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。之前我们讲栈与队列的时候，就说过<strong>栈其实就是递归的一种实现结构</strong>，也就说<strong>前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的</strong>。而<strong>广度优先遍历的实现一般使用队列来实现</strong>，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><h2 id="二叉树的定义方式"><a href="#二叉树的定义方式" class="headerlink" title="二叉树的定义方式"></a>二叉树的定义方式</h2><p>二叉树有两种存储方式顺序存储和链式存储，顺序存储就是用数组来存，我们大多数情况下都是采用链式存储，这里给出链式存储的二叉树节点的定义方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><p><strong>题目链接：</strong></p><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal">144.二叉树的前序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal">145.二叉树的后序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal">94.二叉树的中序遍历</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很多同学可能会有“一入递归深似海，从此回不来”的情况，这主要是对递归不成体系，没有方法论，每次写递归算法，都是靠玄学来写代码，代码能不能编过都靠运气。</p><p>这里会帮助大家确定递归算法的三个要素。<strong>每次写递归，就按照这三个要素来写</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件</strong></li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><p>接下来以前序遍历举个例子：</p><ol><li><strong>确定递归函数的参数和返回值。</strong> 因为要打印出当前遍历到的节点值，因此需要传入<code>vector</code>来存放节点值，此外，为了获取节点值还要将指向节点的指针<code>TreeNode* cur</code>传入，除此之外就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>确定终止条件。</strong> 当前遍历的节点为空，那么本层递归就要结束了，直接return</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>确定单层递归的逻。</strong> 前序遍历是中左右的顺序，所以在单层递归的逻辑，先取中间节点的数值，再分别遍历左右孩子（左右子树）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val);        <span class="comment">// 中</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;left, vec);      <span class="comment">// 左</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;right, vec);     <span class="comment">// 右</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();              <span class="comment">//中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">//右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">//左（空节点不如栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,vec);           <span class="comment">//左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,vec);          <span class="comment">//右</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);            <span class="comment">//中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="built_in">traversal</span>(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,vec);           <span class="comment">//左</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);            <span class="comment">//中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,vec);          <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="built_in">traversal</span>(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><p>大家可以使用迭代法，再重新解决上一小节三道leetcode上的题目</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal">144.二叉树的前序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal">145.二叉树的后序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal">94.二叉树的中序遍历</a></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了。</p><h4 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="前序遍历（迭代法）"></a>前序遍历（迭代法）</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么<strong>先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</strong></p><p><strong>为什么要先加入右孩子，再加入左孩子呢？</strong> 因为这样出栈的时候才是中左右的顺序。</p><img src="https://img.imgdd.com/368b3bae-62ff-4d89-a4a5-fc7e8bfbe3b7.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>可写出如下代码（注意空节点不入栈）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();              <span class="comment">//中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">//右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">//左（空节点不如栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后序遍历（迭代法）"><a href="#后序遍历（迭代法）" class="headerlink" title="后序遍历（迭代法）"></a>后序遍历（迭代法）</h4><p>再来看后序遍历，前序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下前序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><img src="https://img.imgdd.com/3020a86a-bf69-4cc4-9466-0a3870597f28.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>可写出如下代码（注意空节点不入栈）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="comment">//相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());    <span class="comment">//将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中序遍历（迭代法）"><a href="#中序遍历（迭代法）" class="headerlink" title="中序遍历（迭代法）"></a>中序遍历（迭代法）</h4><p>既然后序遍历可以在前序遍历的基础上调换代码的执行顺序实现，那么中序遍历是不是也可以呢？答案是不行</p><p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。此处先给出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">//一路向左找到最底层节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);           <span class="comment">//将访问的节点入栈</span></span><br><span class="line">                cur = cur-&gt;left;       </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();         <span class="comment">//这个时候栈顶的数据就是要处理的数据</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后给出模拟过程：</p><img src="https://img.imgdd.com/bf2663b4-f915-443c-9159-5ee3e663284a.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><h2 id="二叉树的层序遍历（迭代法）"><a href="#二叉树的层序遍历（迭代法）" class="headerlink" title="二叉树的层序遍历（迭代法）"></a>二叉树的层序遍历（迭代法）</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。<strong>需要借用一个辅助数据结构即队列来实现</strong>，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p><p>这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。模拟如下：</p><img src="https://img.imgdd.com/d4630294-0cd4-4094-9da0-a26d9146741e.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>最后的结果是以二维数组的形式保存，那我们怎么控制每一行的结束呢？相信大家从上图的模拟也能知道，我们可以在处理每一层节点之前设置一个固定的<code>size</code>，当<code>size=0</code>是就表明当前已经处理完一行数据</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt;que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">//这里一定要使用固定大小的size，不要使用que.size()</span></span><br><span class="line">            <span class="comment">//因为会不断加入节点的左右孩子导致队列大小不断变化</span></span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;vec;         <span class="comment">//保存每一层的值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="comment">//加入左右节点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;      </span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>委托构造函数和继承构造函数</title>
      <link href="/posts/33535.html"/>
      <url>/posts/33535.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-委托构造函数"><a href="#1-委托构造函数" class="headerlink" title="1.委托构造函数"></a>1.委托构造函数</h1><p><code>委托构造函数允许使用同一个类中的一个构造函数调用其他的构造函数，从而简化相关变量的初始化</code>。下面通过一个例子说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;<span class="comment">// 冗余代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;<span class="comment">// 冗余代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;<span class="comment">// 冗余代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_max;</span><br><span class="line"><span class="type">int</span> m_min;</span><br><span class="line"><span class="type">int</span> m_mid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">&quot;, middle: &quot;</span> &lt;&lt; t.m_mid &lt;&lt; <span class="string">&quot;, max: &quot;</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面三个重载的构造函数中都出现重复的代码，在C++11以前，我们会把重复的代码放到一个函数里，然后调用；在C++11以后，加入了委托构造，我们就可以轻松地完成代码的优化了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) : <span class="built_in">Test</span>(max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid) : <span class="built_in">Test</span>(max,min) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_max;</span><br><span class="line"><span class="type">int</span> m_min;</span><br><span class="line"><span class="type">int</span> m_mid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">&quot;, middle: &quot;</span> &lt;&lt; t.m_mid &lt;&lt; <span class="string">&quot;, max: &quot;</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完代码之后，冗余的代码全部都没有了，并且<code>在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用</code>。在使用委托构造函数的时候还需要注意一些几个问题：</p><ul><li>这种链式的构造函数调用不能形成一个闭环，否则会在运行期间抛出异常</li><li>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) &#123;</span><br><span class="line"><span class="built_in">Test</span>(max);          <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid) &#123;</span><br><span class="line"><span class="built_in">Test</span>(max, min);     <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误, 使用了委托构造函数就不能再次m_max初始化了</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) : <span class="built_in">Test</span>(max), <span class="built_in">m_max</span>(max) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-继承构造函数"><a href="#2-继承构造函数" class="headerlink" title="2.继承构造函数"></a>2.继承构造函数</h1><p>C++11中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i) :<span class="built_in">Base</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">Base</span>(i, j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">Base</span>(i, j, k) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> &lt;&lt; c.m_j &lt;&lt; <span class="string">&quot;, string: &quot;</span> &lt;&lt; c.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过继承构造函数在子类中重新定义和基类一样的构造函数：通过使用<code>using 基类名::基类的构造函数名</code>（类名和构造函数名一样）来使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> &lt;&lt; c.m_j &lt;&lt; <span class="string">&quot;, string: &quot;</span> &lt;&lt; c.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在修改之后的子类中，没有添加任何构造函数，而是添加了<code>using Base::Base;</code>这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。</p><p>另外如果在子类中隐藏了父类中的同名函数，也可以通过using的方式在子类中使用基类中的这些父类函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base class: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, string str)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base class: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="keyword">using</span> Base::func;       <span class="comment">// 引入Base的func重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;child class: i&#x27;am huang&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">250</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">func</span>();</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">18</span>);</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">18</span>, <span class="string">&quot;huang&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child <span class="keyword">class</span>: i<span class="string">&#x27;am huang</span></span><br><span class="line"><span class="string">base class: i = 18</span></span><br><span class="line"><span class="string">base class: i = 18, str = huang</span></span><br></pre></td></tr></table></figure><p>子类中的<code>func()</code>函数隐藏了基类中的两个<code>func()</code>因此默认情况下通过子类对象只能调用无参的func()，在上面的子类代码中添加了<code>using Base::func;</code>之后，就可以通过子类对象直接调用父类中被隐藏的带参func()函数了。</p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>using的使用</title>
      <link href="/posts/55817.html"/>
      <url>/posts/55817.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义别名"><a href="#1-定义别名" class="headerlink" title="1.定义别名"></a>1.定义别名</h1><p>在C++中，可以通过<code>typedef</code>重定义一个类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 旧类型名 新类型名;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br></pre></td></tr></table></figure><p>被重定义的类型并不意味着一个新类型，而是给原来的类型起了一个别名。在C++11中规定一种新的方法，使用using来定义类型别名。语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 新类型名 = 旧类型名;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">unsigned</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure><p>通过<code>using</code>和<code>typedef</code>的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个函数指针，using的优势就能凸显出来了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用typedef定义函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*func_ptr)</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用using定义函数指针</span></span><br><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">double</span>);</span><br></pre></td></tr></table></figure><p>如果比较熟悉函数指针，就能看出func_ptr是一个别名，本质是函数指针，它指向返回值类型为int，参数分别为int和double类型的函数地址。如果使用using定义函数指针别名的写法看起来就非常直观了，<code>把别名的名字强制分离到了左边，而把别名对应的实际类型放在了右边，比较清晰，可读性比较好</code></p><h1 id="2-模板的别名"><a href="#2-模板的别名" class="headerlink" title="2.模板的别名"></a>2.模板的别名</h1><p>使用typedef重定义的时候在某些情况下会有一点限制，比如无法重定义一个模板。如果我们需要一个固定以int类型为key的map，它可以和很多类型的value值进行映射，如果使用typedef这样直接定义就非常麻烦:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, string&gt; m1;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m2;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, <span class="type">double</span>&gt; m3;</span><br></pre></td></tr></table></figure><p>如果我么们通过模板进行定义呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, T&gt; type;   <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>编译器会报错，<strong>因为typename不支持给模板定义别名</strong>，这个简单的需求仅通过typedef很难办到，需要添加一个外敷类。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 定义外敷类</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyMap</span> &#123;</span><br><span class="line">    <span class="keyword">typedef</span> map&lt;<span class="type">int</span>, T&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    MyMap&lt;string&gt;::type m;</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;luffy&quot;</span>));</span><br><span class="line">    m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;ace&quot;</span>));</span><br><span class="line"></span><br><span class="line">    MyMap&lt;<span class="type">int</span>&gt;::type m1;</span><br><span class="line">    m<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">1</span>, <span class="number">100</span>);</span><br><span class="line">    m<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">2</span>, <span class="number">200</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上边的例子可以直观的感觉到，需求简单但是实现起来并不容易。在C++11中，可以直接使用<code>using</code>来为模板定义别名，可以写成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> mymap = map&lt;<span class="type">int</span>, T&gt;;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定义别名，它是map&lt;int,T&gt;类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> mymap = map&lt;<span class="type">int</span>, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mymap&lt;string&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;huang&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;nba&quot;</span>));</span><br><span class="line"></span><br><span class="line">mymap&lt;<span class="type">double</span>&gt;m1;</span><br><span class="line">m<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">3.14</span>));</span><br><span class="line">m<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">1.314</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>最后要强调的是：using语法和typedef一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。</code></p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列part01</title>
      <link href="/posts/34563.html"/>
      <url>/posts/34563.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-232-用栈实现队列"><a href="#LeetCode-232-用栈实现队列" class="headerlink" title="LeetCode 232 用栈实现队列"></a>LeetCode 232 用栈实现队列</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/implement-queue-using-stacks">232.用栈实现队列</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这是一道模拟题，不涉及到具体算法，考察的就是对栈和队列的掌握程度。</p><p>使用栈来模拟队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈<strong>一个输入栈，一个输出栈</strong>。</p><p>在push数据的时候，只要数据放进输入栈就好，但<strong>在pop的时候，操作就复杂一些，输出栈如果为空，就把输入栈内的数据全部导入进来，再从输出栈弹出数据，如果输出栈不为空，则直接从输出栈弹出数据就可以了。</strong></p><p>**那么如何判断队列为空呢？**如果进栈和出栈都为空的话，说明模拟的队列为空了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!in.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> temp = in.<span class="built_in">top</span>();</span><br><span class="line">                in.<span class="built_in">pop</span>();</span><br><span class="line">                out.<span class="built_in">push</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> number = out.<span class="built_in">top</span>();</span><br><span class="line">        out.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        out.<span class="built_in">push</span>(number);</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.<span class="built_in">empty</span>() &amp;&amp; out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;in;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;out;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-225-用队列实现栈"><a href="#LeetCode-225-用队列实现栈" class="headerlink" title="LeetCode 225 用队列实现栈"></a>LeetCode 225 用队列实现栈</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/implement-stack-using-queues">225.用队列实现栈</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>大家可能会像上一题一样，定义一个输入队列，一个输出队列就可以模拟栈的功能，仔细想一下还真不行！</p><p>**队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。**所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。但是，我们依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，另一个队列完全用来备份的！</p><p>队列中最后进入的元素一定要最先出来，这样才能符合栈的<strong>后进先出</strong>特性。此时，<strong>问题就转化为如何取出队列的队尾元素？<strong>为了实现这一点，我们需要</strong>使用另一个队列来备份前n-1个元素，而队尾的元素（第n个元素）就是要出队的元素</strong>。将队尾元素出队后，再将备份队列中的元素重新导入到原队列中。为了控制队列中的元素个数，我们还需要定义一个size变量来记录队列中的元素数量。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;in;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;in_tem;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.<span class="built_in">push</span>(x);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(size != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> number = in.<span class="built_in">front</span>();</span><br><span class="line">            in.<span class="built_in">pop</span>();</span><br><span class="line">            in_tem.<span class="built_in">push</span>(number);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp = in.<span class="built_in">front</span>();</span><br><span class="line">        in.<span class="built_in">pop</span>();</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!in_tem.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> number = in_tem.<span class="built_in">front</span>();</span><br><span class="line">            in_tem.<span class="built_in">pop</span>();</span><br><span class="line">            in.<span class="built_in">push</span>(number);</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        in.<span class="built_in">push</span>(number);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-20-有效的括号"><a href="#LeetCode-20-有效的括号" class="headerlink" title="LeetCode 20 有效的括号"></a>LeetCode 20 有效的括号</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/valid-parentheses">20.有效的括号</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>很经典的栈的应用题，大家不管是学习数据结构与算法或者是考研备考过程中或多或少都会接触到这类经典问题</p><p>由于栈结构的特殊性，它非常适合用于解决对称匹配类的题目。首先，我们需要弄清楚在字符串中括号不匹配的几种情况。</p><ul><li>匹配不正确，即左右括号不匹配的情况，例如：<code>s=&quot;(]&quot;</code></li><li>左括号多，右括号少。表现在：当字符串s遍历完之后，栈不为空。例如：<code>s=&quot;((()&quot;</code></li><li>左括号少，右括号多。表现在：此时栈为空，但是字符串s正遍历的是右括号。例如：<code>s=&quot;()))))&quot;</code></li><li>正确匹配，即字符串遍历完成，栈此时也为空，例如：<code>s=&quot;()[]&#123;&#125;&quot;</code></li></ul><p>还有一些技巧，<strong>在匹配左括号的时候，右括号先入栈</strong>，这样只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;st;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="comment">//第一种情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() != ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//第三种情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//第四种情况，即匹配的情况</span></span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二种情况</span></span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-1047-删除字符串中的所有相邻重复项"><a href="#LeetCode-1047-删除字符串中的所有相邻重复项" class="headerlink" title="LeetCode 1047 删除字符串中的所有相邻重复项"></a>LeetCode 1047 删除字符串中的所有相邻重复项</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string">1047.删除字符串中的所有相邻重复项</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>本题目和<code>20.有效的括号</code>题目思路类似，都是使用栈来解决的经典题目。不同的是，本题要匹配相邻元素，而非左右括号。</p><p>我们在删除相邻重复项的时候，其实就是要知道当前遍历的这个元素，与前一位是不是遍历过一样数值的元素，那么如何记录前面遍历过的元素呢？当然是使用栈来存放，栈的目的，就是存放遍历过的元素，当遍历当前的这个元素的时候，去栈里看一下我们是不是遍历过相同数值的相邻元素，然后再去做对应的消除操作。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string result;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.<span class="built_in">empty</span>() &amp;&amp; ch == st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> ch = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列part02</title>
      <link href="/posts/40546.html"/>
      <url>/posts/40546.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-150-逆波兰表达式求值"><a href="#LeetCode-150-逆波兰表达式求值" class="headerlink" title="LeetCode 150 逆波兰表达式求值"></a>LeetCode 150 逆波兰表达式求值</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation">150.逆波兰表达式求值</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>逆波兰表达式就是一种后缀表达式，所谓后缀就是指运算符写在操作数的后面</p><p>我们平常使用的算数式是一种中缀表达式，如<code>(1+2)*(3/4)</code>，该式的逆波兰表达式写成<code>12+34/*</code>。中后缀表达式的转换方法此处不做过多介绍，可以参考<a href="https://www.bilibili.com/video/BV1b7411N798/?p=29&share_source=copy_web&vd_source=0db260a29b428cc91330eced2669ad8a">王道计算机考研 数据结构</a></p><p>后缀表达式的计算：</p><ol><li>从左往右扫描下一个元素，知道处理完所有元素</li><li>若扫描到操作数则压入栈，并返回1；否则执行3</li><li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到1</li></ol><p><strong>注意，第三步中先出栈的式“右操作数”</strong> 动画演示还是参考上述视频</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(string s : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">&quot;+&quot;</span> || s == <span class="string">&quot;-&quot;</span> || s == <span class="string">&quot;*&quot;</span> || s == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num1 = st.<span class="built_in">top</span>();      <span class="comment">//右操作数</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num2 = st.<span class="built_in">top</span>();      <span class="comment">//左操作数</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(s == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoll</span>(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-347-前K个高频元素"><a href="#LeetCode-347-前K个高频元素" class="headerlink" title="LeetCode 347 前K个高频元素"></a>LeetCode 347 前K个高频元素</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/top-k-frequent-elements">347.前K个高频元素</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>两种思路，第一种是使用<strong>哈希表</strong>实现，第二种是使用<strong>优先队列</strong></p><h4 id="思路一：哈希表"><a href="#思路一：哈希表" class="headerlink" title="思路一：哈希表"></a>思路一：哈希表</h4><p>这道题目主要涉及到如下三块内容：</p><ol><li>要统计元素出现频率</li><li>对频率排序</li><li>找出前K个高频元素</li></ol><p>我们之前已经学习过哈希表了，相信大家在看到这个题目的时候最先想到一定是哈希表（unordered_map），pair中的第一个位置记录数组元素，第二个位置记录该数组元素出现的频率，然后根据频率大小进行排序。但是，**我们怎么对map里的元素进行排序呢？**有人想到sort库函数，但是sort库函数不能对map里的元素进行排序。</p><p>我们可以这样操作：我们使用unordered_map记录每个数字出现的频率之后，遍历哈希表，找到出现次数最多的那个频率maxTime，然后开始收集高频元素</p><ul><li>从maxTime开始，逐步递减频率</li><li>每次遍历哈希表，收集所有频率等于当前频率maxTime的元素</li><li>直到收集到k个元素为止</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : map) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it.second == maxTime) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(it.first);</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxTime--;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二：优先队列"><a href="#思路二：优先队列" class="headerlink" title="思路二：优先队列"></a>思路二：优先队列</h4><p>上述的哈希表方法是对整个数组进行排序，这样效率较低。那么，我们能否有一种方法只维护前K个有序序列就行了呢？当然可以，那就是优先队列！那么，什么是优先队列呢？要了解优先队列，我们首先需要理解堆的概念。</p><p><strong>堆是一颗完全二叉树，树中每个节点的值都不小于（或不大于）其左右孩子的值。<strong>如果父亲节点是大于等于左右孩子就是</strong>大根堆</strong>，小于等于左右孩子就是<strong>小根堆</strong>。大根堆就是指堆头是最大元素，小顶堆是指堆头是最小元素，除此之外，大家还需要了解构建堆的过程，因为篇幅有限，因此可以通过视频<a href="https://www.bilibili.com/video/BV1b7411N798/?p=96&share_source=copy_web&vd_source=0db260a29b428cc91330eced2669ad8a">王道计算机考研 数据结构</a>了解堆的构建过程。<strong>堆在算法在常用于处理Top-K问题，即前K个最大&#x2F;最小&#x2F;最频繁的元素</strong></p><p>优先级队列其实就是<strong>一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？缺省情况下priority_queue利用大根堆完成对元素的排序，这个大根堆是以vector为表现形式的完全二叉树。</p><p>此时要思考一下，是使用小根堆呢，还是大根堆？有的人一想，题目要求前K个高频元素，那么果断用大根堆啊。那么问题来了，定义一个大小为k的大根堆，在每次移动更新大根堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p><img src="https://img.imgdd.com/a50b001d-26e8-42f2-8404-3be78bfe0761.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</p><img src="https://img.imgdd.com/ad86b9a0-8bfd-4b31-9715-10b23a7b0e81.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="思路一：哈希表-1"><a href="#思路一：哈希表-1" class="headerlink" title="思路一：哈希表"></a>思路一：哈希表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxTime = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ret;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map;      <span class="comment">// 元素 次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> number : nums) &#123;</span><br><span class="line">            map[number]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到出现的最大次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : map) &#123;</span><br><span class="line">            <span class="keyword">if</span>(it.second &gt; maxTime) &#123;</span><br><span class="line">                maxTime = it.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it : map) &#123;</span><br><span class="line">                <span class="keyword">if</span>(it.second == maxTime) &#123;</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(it.first);</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxTime--;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路二：优先队列-1"><a href="#思路二：优先队列-1" class="headerlink" title="思路二：优先队列"></a>思路二：优先队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt; rhs.second; <span class="comment">// 小顶堆，频率小的在上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计每个元素出现的频率</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> number : nums) &#123;</span><br><span class="line">            map[number]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义小顶堆，维护前k个频类最高的元素</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,mycomparison&gt;pri_que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>();it != map.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="keyword">if</span>(pri_que.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">result</span>(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            result[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-239-滑动窗口最大值"><a href="#LeetCode-239-滑动窗口最大值" class="headerlink" title="LeetCode 239 滑动窗口最大值"></a>LeetCode 239 滑动窗口最大值</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/sliding-window-maximum">239.滑动窗口最大值</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>有同学在学习了优先队列后，可能会想到使用大根堆存放滑动窗口中的k个数字，每次取出堆顶元素（最大值）即可。然而，这里会有一个问题：滑动窗口是动态变化的，而大根堆每次只能弹出最大值，无法移除其他元素。因此，当滑动窗口向右移动时，无法保证弹出的元素正好是大根堆的堆顶元素（最大元素），所以无法直接使用大根堆来解决问题。</p><p>此时我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。所以，它应该能实现如下功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.getMaxValue()就返回我们要的最大值。</p><p>但是，我们并没有这种现成的数据结构，只能通过自己定义一个队列进行实现。接着就是最重要的一个问题，那就是<strong>如何实现队列里的元素序列有序？顺序是单调递增还是单调递减？</strong></p><p><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。<strong>这个维护元素单调递减的队列就叫做</strong>单调队列</strong>，**不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。来看一下单调队列如何维护队列里的元素。</p><ol><li>先将前k个元素入队，当元素3入队时，发现队列中的最后一个元素1小于3，为了实现单调递减，我们将元素1出队（即deq.pop_front()）,接着下一个元素-1入队，发现队列最后一个元素3比自己大，符合单调递减顺序，于是继续入队。这样，在第一轮循环（第一次滑动窗口）结束时，我们就可以知道最大值是队列的队头元素3。</li></ol><img src="https://img.imgdd.com/6a0c41c9-ae60-46c4-a7a2-c34f3c0ad9a0.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><ol start="2"><li>接着，滑块继续向前移动，此时元素-3发现队列最后一个元素-1比自己大，符合单调递减顺序，于是继续入队。</li></ol><img src="https://img.imgdd.com/73fbac73-7f8e-4722-8a36-6c125759ddd1.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><ol start="3"><li>接着，滑动窗口继续向前移动，此时队列内的元素个数已经为k，我们需要执行pop操作，弹出队列头部的元素3，然后将元素5入队。入队时会发现队列中的最后一个元素-3小于5，于是将-3弹出；再比较队列中的最后一个元素-1，仍然小于5，于是将-1也弹出。</li></ol><img src="https://img.imgdd.com/ae95cbfe-4e75-4eca-b06f-b63965b56798.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>后续过程不再给出文字描述，直接看流程图</p><img src="https://img.imgdd.com/799850d8-8307-4647-901f-6a5771278796.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>下面代码就是我们自己设计的双向队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;que;      <span class="comment">//注意是deque而不是queue</span></span><br><span class="line">    <span class="comment">//每次弹出的时候，比较当前要弹出的数值value是否等于队列出口元素，如果相等则弹出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素数值，那么就将队列后端数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时，当前队列里的最大值就是队头第一个元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;que;      <span class="comment">//注意是deque而不是queue</span></span><br><span class="line">    <span class="comment">//每次弹出的时候，比较当前要弹出的数值value是否等于队列出口元素，如果相等则弹出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素数值，那么就将队列后端数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时，当前队列里的最大值就是队头第一个元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="comment">//先将前k个元素放进队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="comment">//滑动窗口移除最前面元素</span></span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]);</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(k)</li></ul><p>这部分的代码比较抽象，还是需要大家多在草稿纸上模拟其过程才能更好的理解</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>大家貌似对单调队列 都有一些疑惑，首先要明确的是，题解中单调队列里的pop和push接口，仅适用于本题。单调队列不是一成不变的，而是不同场景不同写法，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。不要以为本题中的单调队列实现就是固定的写法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板的优化</title>
      <link href="/posts/12430.html"/>
      <url>/posts/12430.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-模板的右尖括号"><a href="#1-模板的右尖括号" class="headerlink" title="1.模板的右尖括号"></a>1.模板的右尖括号</h1><p>泛型编程中，模板实例化是一个非常繁琐的地方，那就是连续的<code>两个右尖括号（&gt;&gt;）</code>会被编译器解析成右移操作，而不是模板参数表的结束，在C++11以前需要在<code>&gt;&gt;</code>之间加上一个空格<code>&gt; &gt;</code>。C++11之后就不需要再加上空格，改进了编译器的解析规则，尽可能的将多个右尖括号解析成模板参数结束符。</p><h1 id="2-默认模板参数"><a href="#2-默认模板参数" class="headerlink" title="2.默认模板参数"></a>2.默认模板参数</h1><p>在C++11以前，类模板是可以有默认的模板参数，但是不支持函数的默认模板参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>, T t = <span class="number">520</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">void</span> <span class="built_in">print</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;current value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test&lt;&gt;t;</span><br><span class="line">t.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">Test&lt;<span class="type">int</span>, <span class="number">1024</span>&gt;t1;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>在C++11中添加了默认模板参数的支持：</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T </span>= <span class="type">long</span>, <span class="keyword">typename</span> U = <span class="type">int</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">mytest</span>(T t = <span class="string">&#x27;A&#x27;</span>, U u = <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t: &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot;, u: &quot;</span> &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">mytest</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// 自动推导，根据传递的实参 mytest&lt;char,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;int,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;char,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;int,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;char,int&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>();<span class="comment">// 没有显示指定类型，没有传递实参，使用默认类型 mytest&lt;long,int&gt;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面例子可以得出结论：<code>当所有模板参数都有默认参数时，函数模板调用相当于调用普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板类名后跟随&lt;&gt;进行实例化</code></p><p><code>此外，函数模板的默认模板参数在使用时和其他默认参数也有些不同，它没有必须写在参数表最后的限制。</code>当默认模板参数和模板参数自动推导同时使用时（优先级从高到低）：</p><ul><li>如果可以推导出参数类型则使用推导出的类型</li><li>如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数（默认的函数参数不能用于类型推导）</li><li>如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>final和override</title>
      <link href="/posts/12428.html"/>
      <url>/posts/12428.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-final"><a href="#1-final" class="headerlink" title="1.final"></a>1.final</h1><p>C++11的关键字<code>final</code>有两个用途。<code>第一，它阻止某个虚函数不能被重写；第二，它限制某个类不能被继承。</code>如果使用<code>final</code>修饰函数，<code>只能修饰虚函数</code>，并且<code>要把final关键字放到类或者函数后面</code></p><h2 id="1-1-修饰函数"><a href="#1-1-修饰函数" class="headerlink" title="1.1 修饰函数"></a>1.1 修饰函数</h2><p>如果将类方法标记为fianal，这意味着无法在子类中重写该方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用final关键字标记该方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> :<span class="keyword">public</span> Child &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//报错，此时不能再重写该虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-修饰类"><a href="#1-2-修饰类" class="headerlink" title="1.2 修饰类"></a>1.2 修饰类</h2><p>C++11中允许将类标记为final，直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用final关键字标记Child类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">final</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错，此时不能继承Child类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> :<span class="keyword">public</span> Child &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Child</code>类被<code>final</code>修饰过，因此<code>Child</code>类不允许有派生类，<code>GrandChild</code>类的继承是非法的</p><h1 id="2-override"><a href="#2-override" class="headerlink" title="2.override"></a>2.override</h1><p><code>override</code>关键字<code>确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，（起到检查的作用，让人一眼就能看出来该方法是重写父类中的方法）</code>这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> :<span class="keyword">public</span> Child &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//报错，因为override表明这是一个重写函数，但是父类中却没有这样的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test11</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串part01</title>
      <link href="/posts/22964.html"/>
      <url>/posts/22964.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-344-反转字符串"><a href="#LeetCode-344-反转字符串" class="headerlink" title="LeetCode 344 反转字符串"></a>LeetCode 344 反转字符串</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/reverse-string">344.反转字符串</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果使用C++、Java等语言进行编程时需要注意，虽然这些语言都提供了丰富的库函数，但我们当前的目的是进行算法练习，因此建议尽量避免直接使用库函数。毕竟，未来在面试时，面试官考察的不是你对库函数的熟悉程度，这一点希望大家能够注意。</p><p>我这里就介绍两种方法：</p><ol><li>首尾指针。定义两个指针，一个指针在字符串前面，一个指针在字符串后面，两个指针同时向中间移动，并交换元素</li><li>栈。栈具有先进后出的特性，我们只需要把元素全部入栈，然后再一次出栈就能实现字符串翻转</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>1.首尾指针法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseStr</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;left &lt;= right;left++,right--) &#123;</span><br><span class="line">            <span class="type">char</span> ch = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverseStr</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2.利用栈</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;st;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> ch = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            s[i++] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-541-反转字符串II"><a href="#LeetCode-541-反转字符串II" class="headerlink" title="LeetCode 541 反转字符串II"></a>LeetCode 541 反转字符串II</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/reverse-string-ii">541.反转字符串II</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题目不涉及到什么算法，只需要跟着题目的反转规则模拟即可</p><ol><li>从0开始遍历字符串，步长为2k</li><li>每一次遍历之后计算剩余长度remainLen，如果<code>remainLen &lt; k</code>，则将剩余字符全部反转。</li><li>如果<code>remainLen &lt; 2*k &amp;&amp; remainLen &gt;= k</code>时，则反转前k个字符</li><li>如果发生上述两种情况，表明剩余字符长度小于2k，那么在下一次遍历时就会自己退出循环</li><li>其他情况，即<code>remainLen &gt;= 2*k</code>，直接反转前k个字符</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> indexLen = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i += (<span class="number">2</span>*k)) &#123;</span><br><span class="line">            <span class="type">int</span> remainLen = indexLen - i;</span><br><span class="line">            <span class="keyword">if</span>(remainLen &lt; k) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i,s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(remainLen &lt; <span class="number">2</span>*k &amp;&amp; remainLen &gt;= k) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i,s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i,s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动类型推导</title>
      <link href="/posts/12429.html"/>
      <url>/posts/12429.html</url>
      
        <content type="html"><![CDATA[<h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>在C++11之前，auto和static是对应的，表示<strong>变量自动存储</strong>，但是非static的局部变量默认都是自动存储的，因此这个关键字变得非常鸡肋，但是，在C++11中他们被赋予了新的含义，使用这个关键字能够像别的语言一样<strong>自动推导出变量的实际类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> <span class="type">int</span> a = <span class="number">0</span>;<span class="comment">// C++11以前：显式声明为自动存储（默认就是auto，一般不写）</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b = <span class="number">0</span>;<span class="comment">// 静态存储，生命周期持续到程序结束</span></span><br><span class="line">a++;</span><br><span class="line">b++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;auto a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; static int b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>();<span class="comment">// auto a=1 static int b=1</span></span><br><span class="line"><span class="built_in">func</span>();<span class="comment">// auto a=1 static int b=2</span></span><br><span class="line"><span class="built_in">func</span>();<span class="comment">// auto a=1 static int b=3</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h2><p>从上面的案例能发现，在C++11以前，auto并不代表一种实际的数据类型，只是一个类型声明的“占位符”，auto并非在任意场景下都能够推导出变量的实际类型。**使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型。**使用语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> 变量名 = 变量值;</span><br></pre></td></tr></table></figure><p>下面举个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;<span class="comment">// x是int类型</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.1415</span>;<span class="comment">// y是double类型</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="string">&#x27;a&#x27;</span>;<span class="comment">// z是char类型</span></span><br><span class="line"><span class="keyword">auto</span> a;<span class="comment">// 报错，没有进行初始化</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">double</span> x;<span class="comment">// 报错，不能与任何其他类型组合（不能修改数据类型）</span></span><br></pre></td></tr></table></figure><p>auto还可以和指针、引用结合起来使用也可以带上const、volatile限定符，在不同的场景下有对应的推导规则，规则内容如下：</p><ul><li>当变量不是指针或引用类型时，推导结果中不会保留const、volatile关键字</li><li>当变量是指针或引用类型时，推导结果中会保留const、volatile关键字</li></ul><p>光是看上面的文字就觉得有些抽象，下面通过几个例子感受一下，第一个例子先介绍变量带指针和引用并使用auto进行类型推导：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">auto</span>* a = &amp;temp;<span class="comment">// &amp;temp: int* --&gt; auto* = int* --&gt; auto: int</span></span><br><span class="line"><span class="keyword">auto</span> b = &amp;temp;<span class="comment">// &amp;temp: int* --&gt; auto: int* </span></span><br><span class="line"><span class="keyword">auto</span>&amp; c = temp;<span class="comment">// auto: int</span></span><br><span class="line"><span class="keyword">auto</span> d = temp;<span class="comment">// auto: int</span></span><br></pre></td></tr></table></figure><p>第二个例子介绍的是带const限定的变量，并使用auto进行类型推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">250</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> a1 = tmp;<span class="comment">// auto: int</span></span><br><span class="line"><span class="keyword">auto</span> a2 = a1;<span class="comment">// a1: const int --&gt; auto: int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; a3 = tmp;<span class="comment">// a3: const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp; a4 = a3;<span class="comment">// a4: const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>* pt4 = &amp;a1;<span class="comment">// pt4: const int*</span></span><br></pre></td></tr></table></figure><ul><li>变量<code>a1</code>的数据类型为<code>const int</code>，因此auto关键字被推导为<code>int</code>类型</li><li>变量<code>a2</code>的数据类型为<code>int</code>，但是a2没有声明为指针或引用，因此<code>const</code>属性被去掉, <code>auto</code>被推导为<code>int</code></li><li>变量<code>a3</code>的数据类型为<code>const int&amp;</code>，a3被声明为引用，因此const属性被保留，<code>auto</code>关键字被推导为<code>int</code>类型</li><li>变量<code>a4</code>的数据类型为<code>const int&amp;</code>，a4被声明为引用，因此const属性被保留，<code>auto</code>关键字被推导为<code>const int</code>类型</li><li>变量<code>pt4</code>的数据类型为<code>const int*</code>，pt4被声明为指针，因此推导结果保留const，<code>auto</code>关键字被推导<code>const int</code>类型</li></ul><h2 id="auto的限制"><a href="#auto的限制" class="headerlink" title="auto的限制"></a>auto的限制</h2><p>auto关键字并不是万能的，在某些场景下不能完成类型推导</p><ol><li><p>不能作为函数的参数使用。因为只有在函数调用的时候才会给函数参数传递实参，但是auto要求必须要初始化赋值，因此，二者矛盾</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)</span> </span>&#123;      <span class="comment">//报错：此处不能使用auto</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不能用于类的非静态成员变量的初始化。因为类的非静态成员变量不属于类，它属于对象的，只有当这个类被创建出来后才能给该成员变量赋值。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> v1 = <span class="number">0</span>;<span class="comment">// 报错</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">auto</span> v2 = <span class="number">0</span>;<span class="comment">// 报错 类的静态非常量成员不允许在类内部直接初始化（基础语法）</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> v3 = <span class="number">10</span>;<span class="comment">// 正确</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>不能使用auto关键字定义数组</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> array[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> t1 = array;<span class="comment">// 正确 auto: int*</span></span><br><span class="line"><span class="keyword">auto</span> t2[] = array;<span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">auto</span> t3[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;<span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无法使用auto推导出模板参数</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Test&lt;<span class="type">double</span>&gt; t;</span><br><span class="line">Test&lt;<span class="keyword">auto</span>&gt; t1 = t;      <span class="comment">// 报错 无法推导出模板类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="auto的应用"><a href="#auto的应用" class="headerlink" title="auto的应用"></a>auto的应用</h2><ol><li><p><code>用于STL容器的遍历</code></p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;ace&quot;</span>));</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;sabo&quot;</span>));</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;luffy&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>用于泛型编程</code>，在使用模板的时候，大多数情况下我们不知道该定义什么类型的变量，例如：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> ret = A::<span class="built_in">get</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>&lt;T1&gt;();</span><br><span class="line"><span class="built_in">func</span>&lt;T2&gt;();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中定义了模板函数func，在函数内部调用类A的静态方法get()，但是我们不知道调用的是哪一个返回值的get()方法，因此返回值的类型不能确定，如果不使用auto，就需要再定义一个模板参数，并且在外部调用时手动指定get的返回值类型，具体代码如下：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;        <span class="comment">// 添加了模板参数B</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">B val = A::<span class="built_in">get</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">func</span>&lt;T1, <span class="type">int</span>&gt;();                 </span><br><span class="line"><span class="built_in">func</span>&lt;T2, string&gt;();              </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>在<strong>编译时期</strong>进行自动类型推导。引入decltype是因为auto并不适用于所有的自动类型推导场景，在某些特殊情况下auto用起来很不方便，甚至压根无法使用。语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br></pre></td></tr></table></figure><p>decltype的推导是在编译期完成的，**它只是用于表达式类型的推导，并不会计算表达式的值。**来看一组简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">100</span>;<span class="comment">// b-&gt;int</span></span><br><span class="line"><span class="keyword">decltype</span>(a + <span class="number">3.14</span>) c = <span class="number">3.14</span>;<span class="comment">// c-&gt;double</span></span><br></pre></td></tr></table></figure><h2 id="推导规则-1"><a href="#推导规则-1" class="headerlink" title="推导规则"></a>推导规则</h2><ol><li><p>表达式为<code>普通变量或普通表达式或类成员表达式</code>，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string text;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; y = x;<span class="comment">// y -&gt; const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(x) a = x;<span class="comment">// a -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(y) b = x;<span class="comment">// b -&gt; const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(Test::value) c = <span class="number">0</span>;<span class="comment">// c -&gt; const int</span></span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line"><span class="keyword">decltype</span>(t.text) d = <span class="string">&quot;hello&quot;</span>;<span class="comment">// d -&gt; string</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表达式是<code>函数调用</code>，则decltype推导的类型应和函数返回值类型一致</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;...&#125;;</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func_int</span><span class="params">()</span></span>;                 <span class="comment">// 返回值为 int</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func_int_r</span><span class="params">()</span></span>;              <span class="comment">// 返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">()</span></span>;            <span class="comment">// 返回值为 int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">func_cint</span><span class="params">()</span></span>;          <span class="comment">// 返回值为 const int</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">func_cint_r</span><span class="params">()</span></span>;       <span class="comment">// 返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">()</span></span>;     <span class="comment">// 返回值为 const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Test <span class="title">func_ctest</span><span class="params">()</span></span>;        <span class="comment">// 返回值为 const Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>()) a = <span class="number">0</span>;<span class="comment">// a: int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>()) b = n;<span class="comment">// b: int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) c = <span class="number">0</span>;<span class="comment">// c: int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint</span>())  d = <span class="number">0</span>;<span class="comment">// d: int   纯右值，此处忽略const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_r</span>())  e = n;<span class="comment">// e: const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) f = <span class="number">0</span>;<span class="comment">// f: const int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_ctest</span>()) g = <span class="built_in">Test</span>();<span class="comment">// g: const Test  纯右值，但是是类类型，可以保留const</span></span><br></pre></td></tr></table></figure><p>函数func_cint()返回的是一个<code>纯右值</code>，<code>对于纯右值而言，只有类类型可以携带const、volatile限定符</code>，除此之外需要忽略掉这两个限定符，因此推导出的变量d的类型为int而不是const int</p></li><li><p>表达式是一个<code>左值，或者被括号()包围</code>，使用decltype推导出的是表达式类型的引用（如果有const、volatile限定符不能忽略）</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string text;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> Test obj;</span><br><span class="line"><span class="comment">// 带有括号的表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(obj.num) a = <span class="number">0</span>;<span class="comment">// 规则一 a: int</span></span><br><span class="line"><span class="keyword">decltype</span>((obj.num)) b = a;<span class="comment">// 规则三 b: const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法表达式</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;<span class="comment">// 规则一 c: int 表达式n+m不能被取地址，是个右值</span></span><br><span class="line"><span class="keyword">decltype</span>(n = n + m) d = n;<span class="comment">// 规则三 d: int&amp;  n+m保存到n中，此时n是一个左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="decltype的应用"><a href="#decltype的应用" class="headerlink" title="decltype的应用"></a>decltype的应用</h2><p> decltype的应用多出现在泛型编程中，比如我们编写一个类模板，在里边添加遍历容器的函数，操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (m_it = t.<span class="built_in">begin</span>(); m_it != t.<span class="built_in">end</span>(); m_it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;valu: &quot;</span> &lt;&lt; *m_it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// T::iterator m_it; // error 这里不能确定迭代器类型</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;ls1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line"><span class="type">const</span> list&lt;<span class="type">int</span>&gt; ls2&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;<span class="comment">//常量容器 const_iterator</span></span><br><span class="line">Container&lt;list&lt;<span class="type">int</span>&gt;&gt;c1;</span><br><span class="line">Container&lt;<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&gt;c2;</span><br><span class="line">c<span class="number">1.</span><span class="built_in">print</span>(ls1);</span><br><span class="line">c<span class="number">2.</span><span class="built_in">print</span>(ls2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在程序第10行报错，迭代器有两种类型：<code>只读（T::const_iterator）</code>和<code>读写（T::iterator）</code>，我们虽然能知道T的类型（属于什么容器的迭代器），但是不知道迭代器的类型，所以会报错。有了<code>decltype</code>就可以完美的解决这个问题了，当T是一个 非const容器得到一个T::iterator，当T是一个const容器时就会得到一个 T::const_iterator。</p><h1 id="返回类型后置"><a href="#返回类型后置" class="headerlink" title="返回类型后置"></a>返回类型后置</h1><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型，比如下面这个场景：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//R-&gt;返回值类型, T-&gt;参数1类型, U-&gt;参数2类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">520</span>;</span><br><span class="line"><span class="type">double</span> y = <span class="number">13.14</span>;</span><br><span class="line"><span class="keyword">auto</span> z = <span class="built_in">add</span>&lt;<span class="keyword">decltype</span>(x + y), <span class="type">int</span>, <span class="type">double</span>&gt;(x, y);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;z = &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在调用函数<code>add</code>时，显示指定了返回值类型<code>decltype(x + y)</code>，但是解决方案有点过于理想化，因为对于调用者来说，是不知道函数内部执行了什么样的处理动作的。因此，如果要想解决这个问题就得直接在<code>add</code>函数身上做文章，先来看第一种写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R,<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="title">decltype</span><span class="params">(t+u)</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是问题又来了，编译器这几行代码报错，因为decltype中的t和u都是形参，直接这样写相当于变量还没有定义就直接用上了，这时候变量还不存在。<code>在C++11中增加了返回类型后置语法，说明白一点就是将decltype和auto结合起来完成返回类型的推导</code>，其语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 符号 -&gt; 后边跟随的是函数返回值的类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)</span> -&gt; <span class="title">decltype</span><span class="params">(参数表达式)</span></span></span><br></pre></td></tr></table></figure><p>通过对上述返回类型后置语法代码的分析，得到结论：<code>auto会追踪decltype()推导出的类型</code>。因此上边的add()函数可以做如下的修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//R-&gt;返回值类型, T-&gt;参数1类型, U-&gt;参数2类型</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回类型后置的好处在于，在指定返回值类型时就可以使用函数形参。</p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表part02</title>
      <link href="/posts/55019.html"/>
      <url>/posts/55019.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-454-四数相加II"><a href="#LeetCode-454-四数相加II" class="headerlink" title="LeetCode 454 四数相加II"></a>LeetCode 454 四数相加II</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/4sum-ii">454.四数相加II</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为这是四个独立的数组，因此，只需要找到<code>A[i]+B[j]+C[k]+D[l]=0</code>即可，无需考虑是否有重复的四个元素相加为0。</p><ul><li>首先，将四个数组分成两部分，A数组和B数组作为一组，C数组和D数组作为另一组。</li><li>接下俩，通过遍历A数组和B数组的所有元素，计算每一对<code>A[i]+B[j]</code>的和，并将其存入哈希表中，哈希表的key是该元素组合的和，value是该和出现的次数。</li><li>然后，再遍历C数组和D数组，计算每一对<code>C[k]+D[l]</code>的和，查找哈希表中是否存在<code>0-(C[k]+D[l])</code>这个键。如果存在，就将该键对应的值（即出现次数）累加到结果中。</li></ul><p>当然，我们也可以A、B和C一组，D一组，不过这样就是三重for循环，时间复杂度O(n3)，因此，为了降低时间复杂度，我们还是分成两组进行求解</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                map[i + j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                <span class="keyword">if</span>(map.<span class="built_in">find</span>(<span class="number">0</span> - (i + j)) != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    count += map[<span class="number">0</span> - (i + j)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-383-赎金信"><a href="#LeetCode-383-赎金信" class="headerlink" title="LeetCode 383 赎金信"></a>LeetCode 383 赎金信</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/ransom-note">383.赎金信</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题目和昨天的<code>242.有效的字母异位词</code>题目很相似，也可以通过使用数组哈希的方式进行查询。</p><p>当然，这道题目也能用map，但是<strong>使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。所以在能使用数组哈希的时候尽量使用数组</strong></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> letter[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : magazine) &#123;</span><br><span class="line">            letter[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : ransomNote) &#123;</span><br><span class="line">            letter[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : letter) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-15-三数之和"><a href="#LeetCode-15-三数之和" class="headerlink" title="LeetCode 15 三数之和"></a>LeetCode 15 三数之和</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/3sum">15.三数之和</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这道题目咋一看不是和<code>454.四数相加II</code>题目类似吗，然后使用哈希的解法一顿操作。其实，这道题目并不适合使用哈希法来解，这是因为题目要求<strong>不可以包含重复的三元组</strong>，因此，使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。就拿题目示例1的数据举个例子。</p><img src="https://img.imgdd.com/4c71ff50-efcf-4e28-bf31-22accd0b9df4.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>假设此时下标1和下标2的元素和1已加入哈希表中，然后遍历下标0，发现符合题目要求，将[-1,0,1]加入结果中。接着继续遍历，当遍历到下标4时，发现再次符合要求，便把[-1,0,1]加入结果中。这样就会导致三元组重复出现，违背了题目要求。当然，这道题目也是能使用哈希表来求解，但是去重的过程不好处理，有很多小细节，此处就不再继续赘述。</p><h4 id="双指针求解"><a href="#双指针求解" class="headerlink" title="双指针求解"></a>双指针求解</h4><p>**那么这题该怎么求解呢？**可以使用双指针进行求解。我们拿数组<code>nums=[-4,-1,-1,-1,0,1,2,2]</code>来举例。</p><img src="https://img.imgdd.com/f855bf88-3491-4ffb-8aeb-2e561c3d2c29.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>首先将数组排序，排好序之后用i标记下标0，同时定义一个下标left在i+1的位置上，定义下标right在数组结尾的位置上。此时，我们就将该问题就转变成<code>nums[i]+nums[left]+nums[right]==0</code>问题，<strong>但是我们如何确定left和right指针的移动呢？</strong></p><ul><li>如果<code>nums[i]+nums[left]+nums[right]&lt;0</code>就说明，此时三数之和小了，需要就left指针向右移动，这样才会让三数之和变大</li><li>反之，如果<code>nums[i]+nums[left]+nums[right]&gt;0</code>就说明，此时三数之和大了，需要就right指针向左移动，这样才会让三数之和变小</li><li>如果<code>nums[i]+nums[left]+nums[right]==0</code>就说明此时的nums[i]、nums[left]和nums[right]这三个数正是我们需要的，加入到结果数组中，并且left向右移动，right向左移动</li></ul><p>于是就有了初版的代码，大家可以根据代码流程在草稿纸模拟nums数组求解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="去重逻辑"><a href="#去重逻辑" class="headerlink" title="去重逻辑"></a>去重逻辑</h4><p>上面代码似乎没什么问题，很合理对吧？但是，还有一个很关键的问题，那就是<strong>去重问题</strong>。我们再通过nums来模拟一遍。</p><p>假设此时下标1和下标2的元素和1已加入哈希表中，然后遍历下标0，发现符合题目要求，将[-1,0,1]加入结果集中。接着继续遍历，当遍历到下标4时，发现再次符合要求，便把[-1,0,1]加入结果集中。这样就会导致三元组重复出现，违背了题目要求。</p><img src="https://img.imgdd.com/4dc24a93-30d8-4ea3-8e32-6297114ebe15.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>说到去重，其实主要考虑三个数的去重，即nums[i]，nums[left]和nums[right]。假设nums[i]重复了怎么办，很简单，既然nums[i]是nums里遍历的元素，那么应该直接跳过去。**但这里又有一个问题，是判断nums[i]与nums[i+1]是否相同，还是判断nums[i]与nums[i-1] 是否相同。**有同学可能想，这不都一样吗。其实不一样！如果我们选择前者写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123; </span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此时<code>nums=[-1,-1,2]</code>那不就把整个情况都pass掉了，显然这是不合理的，<strong>我们要做的是不能有重复的三元组，但三元组内的元素是可以重复的！</strong>。因此，我们还是这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nums[left]和nums[right]的去重逻辑就简单很多了，直接给出代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left<span class="number">+1</span>]) left++;</span><br><span class="line"><span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right<span class="number">-1</span>]) right--;</span><br></pre></td></tr></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left<span class="number">+1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-18-四数之和"><a href="#LeetCode-18-四数之和" class="headerlink" title="LeetCode 18 四数之和"></a>LeetCode 18 四数之和</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/4sum">18.四数之和</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>与<code>15.三数之和</code>题目思路类似，都是使用双指针法, 基本解法就是在<code>15.三数之和</code>的基础上再套一层for循环。不过有一些细节需要注意：</p><ul><li>不要判断<code>nums[k]&gt;target</code>就返回了，三数之和可以通过<code>nums[i]&gt;0</code>就返回，是因为0已经是确定的数了，四数之和这道题目 target是任意值。比如：<code>nums= [-4, -3, -2, -1],target=-10</code>，不能因为-4&gt;-10而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[k]&gt;target &amp;&amp; (nums[k]&gt;=0 || target&gt;=0)</code>就可以了。</li><li>四数之和的双指针解法是两层for循环<code>nums[k]+nums[i]</code>为确定值，依然是循环内有left和right下标作为双指针，找出<code>nums[k]+nums[i]+nums[left]+nums[right]==target</code>的情况，</li><li>注意数组是否会溢出</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; nums.<span class="built_in">size</span>();k++) &#123;</span><br><span class="line">            <span class="comment">//-6,-2,...     target: -8</span></span><br><span class="line">            <span class="keyword">if</span>(nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//k去重</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = k + <span class="number">1</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//i去重</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span>((<span class="type">long</span>)nums[k] + nums[i] + nums[left] + nums[right] &lt; target) left++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)nums[k] + nums[i] + nums[left] + nums[right] &gt; target) right--;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">//left和right去重</span></span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量表达式修饰符-constexpr</title>
      <link href="/posts/63765.html"/>
      <url>/posts/63765.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-constexpr"><a href="#1-constexpr" class="headerlink" title="1.constexpr"></a>1.constexpr</h2><h3 id="1-1-const"><a href="#1-1-const" class="headerlink" title="1.1 const"></a>1.1 const</h3><p>在C++11之前只有const关键字，从功能上来说它有双重语义：<strong>变量只读、修饰常量</strong>，通过一个例子体会一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义两个变量</span></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> a2 = <span class="number">250</span>;</span><br><span class="line"><span class="comment">//定义常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> count = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; b = a1;</span><br><span class="line">b = a2;<span class="comment">//错误</span></span><br><span class="line">a1 = <span class="number">1314</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//输出1314</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> array[count];<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> array[a1];<span class="comment">//报错 </span></span><br><span class="line"><span class="type">int</span> array[num];<span class="comment">//报错 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数<code>void func(const int num)</code>的参数<code>num</code>表示<strong>该变量只读，但不是常量</strong>。因此，以<code>int array[num];</code>方式定义数组，编译器会报错，提示<code>num不作为常量使用</code></li><li><code>const int count = 24</code>中的<code>const</code>却是一个常量，因此可以使用这个常量来定义一个静态数组。</li><li>b是一个常量的引用，因此它初始化之后就不能被修改，因此<code>b = a2</code>会报错</li><li>引用b是只读的，并不能保证它的值不会被改变，也就是说它不是常量</li></ul><h3 id="1-2-constexpt"><a href="#1-2-constexpt" class="headerlink" title="1.2 constexpt"></a>1.2 constexpt</h3><p>在C++11中添加了一个新的关键字<code>constexpr</code>，这个关键字是用来修饰常量表达式的。所谓<strong>常量表达式，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。</strong></p><p>C++程序从编写完毕到执行分为四个阶段：<strong>预处理、 编译、汇编和链接</strong>。需要额外强调的是，常量表达式和非常量表达式的计算时机不同，<strong>非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段</strong>，这极大提高了程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p><strong>那么编译器如何识别表达式是常量表达式还是变量表达式呢？<strong>在C++11中添加了<code>constexpr</code>关键字之后就可以在程序中使用它来修饰常量表达式，用来提高程序的执行效率。在使用中建议将const和constexpr的功能区分开，即</strong>凡是表达“只读”语义的场景都使用const，表达“常量”语义的场景都使用constexpr。</strong></p><p>在C++11之前，<code>const</code>和<code>constexpr</code>是等价的，都可以在程序编译阶段计算出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> m = <span class="built_in">f</span>();  <span class="comment">// 不是常量表达式，m的值只有在运行时才会获取。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=i<span class="number">+1</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> j=i<span class="number">+1</span>;    <span class="comment">// 是一个常量表达式</span></span><br></pre></td></tr></table></figure><p>但是在C++11之后，对于<strong>内置数据类型</strong>，推荐使用<code>constexpr</code>修饰，这样编译器在程序的编译阶段就能计算出常量的结果。但如果是<strong>自定义数据类型</strong>（<code>struct</code>和<code>class</code>），不能直接使用<code>constexpr</code>修饰</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器提示 constexpr在此处无效</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要修饰自定义数据类型，可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span> &#123;</span><br><span class="line"><span class="type">int</span> num1;</span><br><span class="line"><span class="type">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> T t&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;<span class="comment">//定义一个常量的结构体对象，并在声明时初始化</span></span><br><span class="line">t.num1 = <span class="number">10</span>;<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-常量表达式函数"><a href="#2-常量表达式函数" class="headerlink" title="2.常量表达式函数"></a>2.常量表达式函数</h2><p>可以使用<code>constexpr</code>修饰函数的返回值，这种函数被称作<strong>常量表达式函数</strong>，这些函数主要包括以下几种：<strong>普通函数&#x2F;类成员函数、类的构造函数、模板函数。</strong></p><h3 id="2-1修饰函数"><a href="#2-1修饰函数" class="headerlink" title="2.1修饰函数"></a>2.1修饰函数</h3><p><code>constexpr</code>并不能修饰任意函数的返回值，使得这些函数都能成为常量表达式函数，必须满足以下条件：</p><ol><li>函数必须要有返回值，并且return返回的表达式必须是常量表达式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误 没有返回值（报错信息：constexpr函数&quot;func1&quot;不能生成常量表达式）</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误 返回值不是常量表达式（报错信息：表达式的计算机过不是常数）</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数在使用之前，必须要有对应的定义语句</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ret = <span class="built_in">func3</span>();<span class="comment">//报错，因为在使用之前只有声明没有定义</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>整个函数的函数体中，不能出现非常量表达式之外的语句（using指令、typedef语句以及static_assert断言、return语句除外）。因此，常量表达式函数是一类功能非常简单的函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误 for循环是一个非法操作</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> mytype = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">constexpr</span> mytype a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">constexpr</span> mytype b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> mytype c = a * b;</span><br><span class="line"><span class="keyword">return</span> c - (a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 以上三条规则不仅对应普通函数适用，对应类的成员函数也是适用的：</p><h3 id="2-2-修饰模板函数"><a href="#2-2-修饰模板函数" class="headerlink" title="2.2 修饰模板函数"></a>2.2 修饰模板函数</h3><p>C++11 语法中，<code>constexpr</code>可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。<strong>如果constexpr修饰的模板函数实例化结果不满足常量表达式函数的要求，则constexpr会被自动忽略，即该函数就等同于一个普通函数。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">display</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* name;<span class="comment">//注意此处不能使用string</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> p &#123;<span class="string">&quot;Lina&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> ret = <span class="built_in">display</span>(p);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量表达式函数</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">display</span>(<span class="number">250</span>);</span><br><span class="line">cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> p1 &#123; <span class="string">&quot;Mike&quot;</span>, <span class="number">19</span> &#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> ret2 = <span class="built_in">display</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; ret<span class="number">2.</span>name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; ret<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>struct Person ret = display(p);</code>由于参数p是变量，因此，返回值的类型就不是常量表达式，也不满足常量表达式函数的要求，此时<code>constexpr</code>是无效的</li><li><code>constexpr int ret1 = display(250);</code>由于参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li><li><code>constexpr struct Person ret2 = display(p1);</code>由于参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li></ul><h3 id="2-3-修饰构造函数"><a href="#2-3-修饰构造函数" class="headerlink" title="2.3 修饰构造函数"></a>2.3 修饰构造函数</h3><p>如果要使用<code>constexpr</code>来修饰一个构造函数，那么这个<strong>构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Person</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">int</span> age)</span> :name(p), age(age) &#123;</span>&#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> <span class="built_in">p1</span>(<span class="string">&quot;luffy&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;luffy&#x27;s name: &quot;</span> &lt;&lt; p<span class="number">1.</span>name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; p<span class="number">1.</span>age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表part01</title>
      <link href="/posts/40691.html"/>
      <url>/posts/40691.html</url>
      
        <content type="html"><![CDATA[<h2 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h2><p><strong>用来快速判断一个元素是否出现集合里的情况</strong>，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map（映射）</li></ul><p>在C++中，set和map分别提供了以下三种数据结构：</p><table><thead><tr><th align="center">集合</th><th align="center">底层实现</th><th align="center">是否有序</th><th align="center">数值是否可以重复</th><th align="center">能否更改数值</th><th align="center">查询效率</th><th align="center">增删效率</th></tr></thead><tbody><tr><td align="center">std::set</td><td align="center">红黑树</td><td align="center">有序</td><td align="center">否</td><td align="center">否</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::multiset</td><td align="center">红黑树</td><td align="center">有序</td><td align="center">是</td><td align="center">否</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::unordered_set</td><td align="center">哈希表</td><td align="center">无序</td><td align="center">否</td><td align="center">否</td><td align="center">O(1)</td><td align="center">O(1)</td></tr></tbody></table><p>std::set和std::multiset底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><table><thead><tr><th align="center">映射</th><th align="center">底层实现</th><th align="center">是否有序</th><th align="center">数值是否可以重复</th><th align="center">能否更改数值</th><th align="center">查询效率</th><th align="center">增删效率</th></tr></thead><tbody><tr><td align="center">std::map</td><td align="center">红黑树</td><td align="center">key有序</td><td align="center">key不可重复</td><td align="center">key不可修改</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::multimap</td><td align="center">红黑树</td><td align="center">key有序</td><td align="center">key可重复是</td><td align="center">key不可修改</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::unordered_map</td><td align="center">哈希表</td><td align="center">key无序</td><td align="center">key不可重复</td><td align="center">key不可修改</td><td align="center">O(1)</td><td align="center">O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p><h2 id="三种哈希结构的使用场景"><a href="#三种哈希结构的使用场景" class="headerlink" title="三种哈希结构的使用场景"></a>三种哈希结构的使用场景</h2><ol><li><p>若数据范围有限（如元素值较小或数组长度固定），优先使用数组哈希（通过元素值直接映射下标），存储高效且访问速度快；</p></li><li><p>若数据范围较大或元素值分布稀疏，使用哈希集合（如 std::unordered_set） 可避免空间浪费；</p></li><li><p>若需统计元素出现频次，则需采用哈希映射（如 std::unordered_map） 记录键值对，兼顾存在性检查和次数统计。</p></li></ol><h2 id="LeetCode-242-有效的字母异位词"><a href="#LeetCode-242-有效的字母异位词" class="headerlink" title="LeetCode 242 有效的字母异位词"></a>LeetCode 242 有效的字母异位词</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/valid-anagram">242.有效的字母异位词</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题可以使用数组哈希的方式进行查询。我们通过定义一个数组来记录字符串s中的出现次数，**那么我们应该定义多大空间的数组呢？**显然，我们要记录字符串s中每一个字符出现的次数，因此我们需要开辟一个空间大小为26的数组letter。需要把字符映射到数组也就是哈希表的索引下标上，**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**我们在遍历字符串s的时候，只需要将<code>s[i]-&#39;a&#39;</code>所在的元素进行<code>+1</code>操作即可。</p><img src="https://img.imgdd.com/f431153a-58af-4ae0-9f12-265b1b23339e.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>遍历完字符串s之后，我们再遍历字符串t，不同的是我们要对t中出现的字符映射哈希表索引上的数值进行<code>-1</code>的操作。</p><img src="https://img.imgdd.com/0ce71d0a-0d08-46f3-b131-a096bfff1256.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>最后，对letter数组进行遍历，<strong>如果数组中有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，返回false。</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compareStr</span><span class="params">(string s,string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> letter[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//第一次遍历字符串s，记录s中每个字符出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            letter[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次遍历字符串t</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : t) &#123;</span><br><span class="line">            letter[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后遍历letter数组，如果有非0，表示出现非公共字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> count : letter) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="built_in">compareStr</span>(s,t);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-349-两个数组的交集"><a href="#LeetCode-349-两个数组的交集" class="headerlink" title="LeetCode 349 两个数组的交集"></a>LeetCode 349 两个数组的交集</h2><p>**题目链接：**<a href="https://leetcode.cn/problems/intersection-of-two-arrays">https://leetcode.cn/problems/intersection-of-two-arrays</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题目，因为数组的长度范围是 1-1000，而每一个元素的数组是0-1000，很明显这题不能像上一题一样使用数组作为哈希表的结构</p><p>我们此时可以使用unorder_set的哈希结构求解两个范围较大的数组的交集。</p><ul><li>首先将nums1的元素存入哈希集合temp，该哈希集合会自动去重</li><li>然后遍历nums2，检查每个元素是否存在哈希集合temp中，若存在加入结果集result</li><li>注意，结果集result也要使用unorder_set结构，因为nums2可能会出现重复的元素，避免这些重复元素再次加入到结果集内</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放结果</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;result;           </span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;<span class="built_in">temp</span>(nums<span class="number">1.</span><span class="built_in">begin</span>(),nums<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> number : nums2) &#123;</span><br><span class="line">            <span class="comment">//每次从nums2中取出一个元素后，在哈希表中查找是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="built_in">find</span>(number) != temp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result.<span class="built_in">insert</span>(number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-202-快乐数"><a href="#LeetCode-202-快乐数" class="headerlink" title="LeetCode 202 快乐数"></a>LeetCode 202 快乐数</h2><p>**题目链接：**<a href="https://leetcode.cn/problems/happy-number">https://leetcode.cn/problems/happy-number</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目中说过会出现无限循环的情况，**那么无限循环的情况会是什么呢？**如果仔细思考能够发现，如果某一个数重复出现，那不就表明它接下来的计算还会得出已经出现过的结果。例如：<code>4-&gt;16-&gt;37-&gt;58-&gt;89-&gt;145-&gt;42-&gt;20-&gt;4-&gt;16-&gt;...</code></p><p>因此，为了判断是否出现重复出现数字的情况，我们可以使用unordered_set结构进行判断</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n%<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-1-两数之和"><a href="#LeetCode-1-两数之和" class="headerlink" title="LeetCode 1 两数之和"></a>LeetCode 1 两数之和</h2><p>**题目链接：**<a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum\</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这道题目我们使用unordered_map，key保存的是元素值，value保存的是当前元素值在数组中的下标。</p><p>遍历数组时，对于每个元素nums[i]，计算目标差值gap，然后在哈希表中查找是否存在这个差值，如果能找到，表明有另一个数可以和其相加得到target，此时返回当前数的索引和匹配值的索引；否则，否则将当前元素及其索引存入哈希表以便后续查找，确保只需一次遍历即可找到解。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="comment">//元素 下标</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map;    </span><br><span class="line">        map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[<span class="number">0</span>],<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="type">int</span> gap = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(gap);</span><br><span class="line">            <span class="keyword">if</span>(iter != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(i);</span><br><span class="line">                result.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针空值类型</title>
      <link href="/posts/22516.html"/>
      <url>/posts/22516.html</url>
      
        <content type="html"><![CDATA[<p>在C++程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为<strong>NULL</strong>，避免产生野指针。在C++98&#x2F;03标准中，将一个指针初始化为空有两种方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* p2 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>在底层NULL的源码定义是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在C中，NULL会被强制转换重<code>void*</code>类型，但是在C++中，是不允许一个<code>void*</code>类型的指针隐式转换为其他类型的指针，因此，为了兼容以前的设计，C++就把NULL定义成字面量0。但是，<strong>C++中将NULL定义为字面值常量0</strong>在某些场景下并不能很好的工作，例如，函数重载时，<strong>NULL和0无法区分</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(char* p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(int p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">250</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码打印结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br></pre></td></tr></table></figure><p>从打印结果可以看出，虽然调用<code>func(NULL)</code>，但最终还是调用<code>void func(int p)</code>，其实，这个原因正是因为C++把NULL定义成字面量0，因此，函数重载的是<code>void func(int p)</code></p><p>出于兼容性的考虑，C++11标准并没有对NULL的宏定义做任何修改，而是另其炉灶，引入了一个新的关键字nullptr。nullptr的实际型别是nullptrr_t，<strong>并且nullptr专用于初始化空类型指针，任意类型的指针变量都可以使用nullptr来初始化（包括自定义类型）。也可以将nullptr隐式转换成int*、char*以及double*指针类型</strong>。使用nullptr可以很完美的解决上边提到的函数重载问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(char* p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(int p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* ptr1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span>* ptr2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">double</span>* ptr3 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span>* ptr4 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++里不允许void*隐式类型转换成其他类型的指针</span></span><br><span class="line"><span class="type">int</span>* ptr5 = (<span class="type">int</span>*)ptr4;</span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">250</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试代码结果打印</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br></pre></td></tr></table></figure><p>通过输出的结果可以看出，<strong>nullptr无法隐式转换为整形，但是可以隐式匹配指针类型。在 C++11标准下，相比NULL和0，推荐大家都是用nullptr来初始化空指针。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>原始字面量</title>
      <link href="/posts/3774.html"/>
      <url>/posts/3774.html</url>
      
        <content type="html"><![CDATA[<p>在C++11中添加了<strong>定义原始字符串的字面量</strong>，定义方式为<code>R &quot;xxx(原始字符串)xxx&quot;</code>，其中（）两边的字符串可以省略。原始字面量R<strong>可以直接表示字符串的实际含义，而不需要而外的转义字符进行转义</strong></p><p>例如，当我们要打印一个路径时，由于路径字符串中常常包含一些特殊字符，传统方法通常需要使用转义字符’&#39;来处理。但如果使用原始字符串字面量，就可以轻松解决这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;D:\hello\world\test.text&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    string str1 = <span class="string">&quot;D:\\hello\\world\\test.text&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    string str2 = <span class="string">R&quot;hello(D:\hello\world\test.text)world&quot;;</span></span><br><span class="line"><span class="string">    cout &lt;&lt; &quot;str2: &quot; &lt;&lt; str2 &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:helloworld    est.text</span><br><span class="line">D:\hello\world\test.text</span><br><span class="line">D:\hello\world\test.text</span><br></pre></td></tr></table></figure><ul><li>第一条语句中，\h和\w转义失败，对应地字符串会原样输出</li><li>第二条语句中，第一个反斜杠是对第二个反斜杠的转义，最终才能得到一个没有特殊含义的普通字符\</li><li>第三条语句中，使用了原始字面量R()中的内容来描述路径的原始字符串，因此无需做任何处理</li></ul><p>在C++11之前如果一个字符串分别写到了不同的行里边，需要加连接符，这种方式不仅繁琐，还破坏了表达式的原始含义，如果使用原始字面量就变得简单很多，很强直观，可读性强。我们再用过一个输出HTML标签的例子体会一下原始字面量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">R&quot;(&lt;html&gt;</span></span><br><span class="line"><span class="string">                    &lt;head&gt;</span></span><br><span class="line"><span class="string">                        &lt;title&gt;</span></span><br><span class="line"><span class="string">                            海贼王</span></span><br><span class="line"><span class="string">                        &lt;/title&gt;</span></span><br><span class="line"><span class="string">                    &lt;/head&gt;</span></span><br><span class="line"><span class="string">                    &lt;body&gt;</span></span><br><span class="line"><span class="string">                        &lt;p&gt;</span></span><br><span class="line"><span class="string">                            我是要成为海贼王的男人!!!</span></span><br><span class="line"><span class="string">                        &lt;/p&gt;</span></span><br><span class="line"><span class="string">                    &lt;/body&gt;</span></span><br><span class="line"><span class="string">                 &lt;/html&gt;)&quot;</span>;</span><br><span class="line">    cout &lt;&lt;  str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">str: &lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">            &lt;title&gt;</span><br><span class="line">                海贼王</span><br><span class="line">            &lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                我是要成为海贼王的男人!!!</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>最后强调一个细节：<strong>在R “xxx()xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且</strong>加的字符串必须在括号两边同时出现(两边出现的字符一模一样)</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str2 = <span class="string">R&quot;hello(D:\hello\world\test.text)hello&quot;</span>;      <span class="comment">//正确</span></span><br><span class="line">string str3 = <span class="string">R&quot;hello(D:\hello\world\test.text)world&quot;;      //错误</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录算法训练营第四天</title>
      <link href="/posts/23629.html"/>
      <url>/posts/23629.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-24-两两交换链表中的节点"><a href="#LeetCode-24-两两交换链表中的节点" class="headerlink" title="LeetCode 24 两两交换链表中的节点"></a>LeetCode 24 两两交换链表中的节点</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs">24.两两交换链表中的节点</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题就是正常的<strong>模拟</strong>，建议使用虚拟头结点。做题分析的时候一定要画图，因为这道题目涉及多个指针操作，相互指向。</p><ol><li>初始时，我们让cur指向虚拟头结点，然后进行如下步骤就可以交换相邻两个节点。在交换过程中，cur指向当前节点，cur-&gt;next指向当前需要交换的第一个节点（temp），而temp-&gt;next则是第二个节点（p）。通过调整指针，完成交换。</li></ol><img src="https://img.imgdd.com/c5182e60-ee9a-4bec-986c-b4074a0689f5.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><ol start="2"><li><p>接下来我们要更新cur的值，每次交换完成后，cur要指向交换后的第二个节点，即原来的第一个节点。这样就可以继续交换接下来的节点。</p></li><li><p>最后，就是要确定循环停止的终止条件。终止条件需要确保链表中还有足够的节点进行交换。当cur-&gt;next &#x3D;&#x3D; nullptr时，意味着已经没有更多的节点；当cur-&gt;next-&gt;next &#x3D;&#x3D; nullptr时，意味着剩下的节点不足两节点进行交换。</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            ListNode* p = temp-&gt;next;</span><br><span class="line">            <span class="comment">//开始交换</span></span><br><span class="line">            cur-&gt;next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = temp;</span><br><span class="line">            cur = temp;         <span class="comment">//cur = cur-&gt;next-&gt;next;</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-19-删除链表的倒数第N个节点"><a href="#LeetCode-19-删除链表的倒数第N个节点" class="headerlink" title="LeetCode 19 删除链表的倒数第N个节点"></a>LeetCode 19 删除链表的倒数第N个节点</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">19.删除链表的倒数第N个节点</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p>删除链表倒数第N个节点，可以将该问题转化成如何找到链表倒数第N个节点</p></li><li><p>我们可以通过快慢指针的方法找到链表倒数第N个节点。先让fast指针向前移动n+1步，使得fast和slow之间相隔n+1个节点，为什么是n+1呢？因为这样同时移动的时候slow指针才能指向待删除节点的前一个节点（方便进行删除操作）</p></li><li><p>fast指针和slow指针同时移动，直到fast指向末尾，然后删除slow指向的下一个节点</p></li></ol><img src="https://img.imgdd.com/9bb3bfa4-1fe0-4e0e-8eca-57b0f9175820.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-面试题-02-07-链表相交"><a href="#LeetCode-面试题-02-07-链表相交" class="headerlink" title="LeetCode 面试题 02.07 链表相交"></a>LeetCode 面试题 02.07 链表相交</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci">面试题 02.07.链表相交</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><p>分别遍历链表A和链表B，统计它们的长度lenA和lenB,目的是为了后续对齐两个链表的遍历起点。</p></li><li><p>对齐两个链表的遍历起点。假设 lenA &gt; lenB，让指向链表A的指针curA先移动lenA-lenB 步。这样，两个链表末尾剩余节点数相等，此时就能同步遍历比较</p></li></ol><img src="https://img.imgdd.com/cf81ee82-d505-4d1a-8ae3-4eba1f74327a.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><ol start="3"><li>从对齐后的位置开始，同时移动curA和curB，逐个比较它们指向的节点是否相同。如果 curA&#x3D;&#x3D;curB，说明找到了相交节点，直接返回该节点。</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算A链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算B链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">//统一使curA指向最长的链表</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> gapLen = lenA - lenB;</span><br><span class="line">        <span class="keyword">while</span>(gapLen--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-142-环形链表"><a href="#LeetCode-142-环形链表" class="headerlink" title="LeetCode 142 环形链表"></a>LeetCode 142 环形链表</h2><p><strong>题目连接:</strong> <a href="">142.环形链表</a></p><h3 id="判断环"><a href="#判断环" class="headerlink" title="判断环"></a>判断环</h3><p>通过快慢指针法，分别fast指针和slow指针，从头结点开始触发，<strong>fast指针每次移动两个节点，slow指针每次移动一个节点</strong>，如果fast和slow指针在途中相遇，说明这个链表有环。<strong>有环的话为什么一定在环内相遇呢？</strong></p><p>这是因为，fast指针一定会先于slow指针先进入环，如果链表存在环，此时该问题就会变成高中物理的追击问题</p><h3 id="寻找环的入口"><a href="#寻找环的入口" class="headerlink" title="寻找环的入口"></a>寻找环的入口</h3><p><strong>如果有环，那么我们如何找到环的入口？</strong> 假设从头结点到环的入口的距离是x，入口到相遇点的距离是y，相遇点再到环形入口的距离是z</p><img src="https://img.imgdd.com/337c4450-40bf-40c1-9c77-bb01d092a737.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>相遇时，slow指针走过了<code>x+y</code>的距离，fast指针走过了<code>x+y+n(y+z)</code>的距离，n表示fast指针在环内走了n圈才和slow指针相遇。我们通过<code>t=x/v</code>将两者联系起来，即<code>(x+y)/1=[x+y+n(y+z)]/2</code>,花间可得<code>x=(n-1)(y+z)+z</code></p><img src="https://img.imgdd.com/eba2a7f3-b264-4106-8459-7f41f0938820.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>注意最后的式子n一定大于等于1，因为fast指针<strong>至少</strong>要多走一圈才能追上并和slow相遇。当<code>n=1</code>时，<code>x=z</code>表明fast指针在环里走了一圈之后就和slow指针相遇。这就意味着，<strong>从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点，那么当这两个指针相遇的时候就是环形入口的节点。</strong></p><p>**如果n大于1会是什么情况？**我们假设令<code>n=3</code>，代入式子可得<code>x=2(y+z)+z</code>。可以发现<code>2(y+z)</code>就表示两圈圆，所以可得出结论，fast指针在环里走了两圈之后和slow指针在入口相遇。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="comment">//保证链表是个环</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="comment">//快慢指针相遇，此时同时从相遇点开始同时进行移动</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                ListNode* index1 = head;</span><br><span class="line">                ListNode* index2 = fast;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录算法训练营第三天</title>
      <link href="/posts/43916.html"/>
      <url>/posts/43916.html</url>
      
        <content type="html"><![CDATA[<h2 id="链表基础"><a href="#链表基础" class="headerlink" title="链表基础"></a>链表基础</h2><p>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向nullptr，链表的入口节点称为链表的头结点（head）</p><img src="https://img.imgdd.com/7242fb8d-3d84-424f-bf77-c7228f6cf73b.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><h2 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a>链表的类型</h2><ol><li>单链表（Singly Linked List）：每个节点只包含一个指针，指向下一个节点。</li><li>双链表（Doubly Linked List）：每个节点包含两个指针，一个指向前一个节点，另一个指向下一个节点。</li><li>循环链表（Circular Linked List）：链表的最后一个节点的指针域指向第一个节点，形成一个环。</li></ol><img src="https://img.imgdd.com/7687a501-6da3-4b2a-a2f5-22322da64105.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;"/><h2 id="LeetCode-203-移除链表元素"><a href="#LeetCode-203-移除链表元素" class="headerlink" title="LeetCode 203 移除链表元素"></a>LeetCode 203 移除链表元素</h2><h3 id="虚拟头结点"><a href="#虚拟头结点" class="headerlink" title="虚拟头结点"></a>虚拟头结点</h3><p>虚拟头结点是一个在链表头部添加的额外节点，它不存储任何数据，只起到辅助作用。虚拟头结点的引入可以使得链表的操作得到统一。</p><ul><li>无论是在链表的开头、中间还是末尾插入或删除节点，我们都可以使用相同的逻辑进行操作</li><li>虚拟头节点还能够解决空链表的情况。如果链表为空且没有虚拟头节点，我们需要对空链表和非空链表进行不同的处理。然而，通过添加虚拟头节点，链表的头部始终存在，我们可以统一对链表进行处理，无论链表是否为空。</li></ul><p>可能大家光是看文字可能没有什么感觉，但是到了做题的时候，你就会发现虚拟头节点会给你带来很多便利</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* p = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* q = p-&gt;next;</span><br><span class="line">                p-&gt;next = q-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-707-设计链表"><a href="#LeetCode-707-设计链表" class="headerlink" title="LeetCode 707 设计链表"></a>LeetCode 707 设计链表</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/design-linked-list">707.设计链表</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line">MyLinkedList* obj = <span class="keyword">new</span> <span class="built_in">MyLinkedList</span>();</span><br><span class="line"><span class="type">int</span> param_1 = obj-&gt;<span class="built_in">get</span>(index);</span><br><span class="line">obj-&gt;<span class="built_in">addAtHead</span>(val);</span><br><span class="line">obj-&gt;<span class="built_in">addAtTail</span>(val);</span><br><span class="line">obj-&gt;<span class="built_in">addAtIndex</span>(index,val);</span><br><span class="line">obj-&gt;<span class="built_in">deleteAtIndex</span>(index);</span><br></pre></td></tr></table></figure><ul><li>第一句代码通过new创建了一个MyLinkedList类型的对象obj，然后对obj执行增删改查操作。因此，在MyLinkedList的方法中，必然会创建一个新的链表。</li><li>我们还需要一个变量记录链表内的元素个数。因为在我们进行增、删、改、查之前要对输入的下标的合法性进行检查，所以有必要记录链表内的元素个数</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkNode* next;</span><br><span class="line">        <span class="built_in">LinkNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">LinkNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkNode</span>();</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断下标是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* curNode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        curNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next  = curNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* curNode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        LinkNode* p = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = curNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* curNode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = curNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        _size--;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkNode* _dummyHead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-206-反转链表"><a href="#LeetCode-206-反转链表" class="headerlink" title="LeetCode 206 反转链表"></a>LeetCode 206 反转链表</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/design-linked-list">206.反转链表</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们一下就能想到，如果我们再开辟一块内存空间，然后重新遍历一遍链表不就能实现链表元素的反转吗？但是这大大浪费了内存空间，也违背了我们刷题学习算法的初衷。</p><p>其实，我们直接把链表指针进行反转，就能实现反转链表，那么如何进行反转呢？</p><p>首先，我们定义一个p指针指向头节点，然后定义一个q指针，初始化为nullptr。我们只需要令p-&gt;next&#x3D;q，q&#x3D;p就能实现翻转操作，那么此时如何令p指针向前走呢？</p><p>这是，我们就需要提前定义一个temp指针保存p指针的下一个节点，这样，p指针就能找到它的下一个节点了。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//标记p的下一个节点</span></span><br><span class="line">            ListNode* temp = p-&gt;next;       </span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            q = p;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head = q;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组part02</title>
      <link href="/posts/29031.html"/>
      <url>/posts/29031.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-209-长度最小的子数组"><a href="#LeetCode-209-长度最小的子数组" class="headerlink" title="LeetCode 209 长度最小的子数组"></a>LeetCode 209 长度最小的子数组</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/minimum-size-subarray-sum">209.长度最小的子数组</a></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>定义left和right两个指针，两指针同向移动且不会回头，指针需要通过判断区间[left,right]是否合法来决定指针的走向，收缩的本质即去掉不再需要的元素（也就是先固定右指针，判断条件是否可以收缩左指针范围）。因为在指针移动过程中，区间[left,right]很像一个滑动的窗口，故称为滑动窗口算法。滑动窗口的典型应用场景就是找数组中的子数组或字符串中的字串是否符合某一条件</p><p><strong>如果加入滑动窗口中有负数怎么办？</strong></p><p>如果滑动窗口中有负数，就无法直接使用滑动窗口算法，因为此时收缩窗口不一定使区间和减小，扩张窗口也不一定使区间和增大，导致窗口的调整变得不可控。若要覆盖所有情况，只能让左指针left逐个回退到right，这就退化成暴力搜索了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题中要想实现滑动窗口，我们就要明确如下三点：</p><ul><li>窗口内表示的是什么？</li><li>如何移动窗口起始位置</li><li>如何移动窗口终止位置</li></ul><p>对于第一点，我们可以从题目中明确知道区间内表示的是元素的总和；对于第二点，如果当前区间内的总和小于target，left指针固定，right指针一直向前移动；对于第三点，如果当前区间内的总和大于target，right指针固定，left指针向前移动。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>, sum = <span class="number">0</span>, subLen = <span class="number">0</span>, result = INT32_MAX;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sum += nums[right]; </span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                subLen = right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(subLen &lt; result) &#123;</span><br><span class="line">                    result = subLen;</span><br><span class="line">                &#125;</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result &lt; subLen ? result : subLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-59-螺旋数组II"><a href="#LeetCode-59-螺旋数组II" class="headerlink" title="LeetCode 59 螺旋数组II"></a>LeetCode 59 螺旋数组II</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/spiral-matrix-ii">59.螺旋数组II</a></p><p><strong>思路</strong></p><p>本题并不涉及什么算法，主要考察的是<strong>模拟遍历的过程</strong>，编写代码时要统一边界条件，这要我们写代码时才不会混乱</p><ol><li>首先要明确一点，我们在Day1的文章说过，遍历数组时通常会采用<strong>左闭右闭</strong>或<strong>左闭右开</strong>的形式，这题当然也不例外，假设我们遍历每一条边均采用左闭右开的原则，确保边界条件统一</li></ol><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul> <img src="https://img.imgdd.com/7eb60706-f824-4bb5-967b-fd4e412bd3c9.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;"/><ol start="2"><li><p>其次，我们按照<strong>由外到内</strong>的遍历顺序，每次向内侧遍历时，循环的终止条件会逐渐减少。因此，我们需要设置一个offset变量，通过n-offset来确定终止条件。</p></li><li><p>最后是循环次数。从上面的图可以看出，当n&#x3D;3时，遍历1次；当n&#x3D;4时，遍历2次。因此，可以得出结论，遍历次数为n&#x2F;2。当n为奇数时，中心位置需要单独处理。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">ret</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> loop = n/<span class="number">2</span>;         <span class="comment">//控制循环次数</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;         <span class="comment">//n-offset 控制每条边遍历次数</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop--) &#123;</span><br><span class="line">            <span class="type">int</span> i = startx;</span><br><span class="line">            <span class="type">int</span> j = starty;</span><br><span class="line">            <span class="comment">//遍历上行</span></span><br><span class="line">            <span class="keyword">for</span>(;j &lt; n - offset;j++) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历右列</span></span><br><span class="line">            <span class="keyword">for</span>(;i &lt; n - offset;i++) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历下行</span></span><br><span class="line">            <span class="keyword">for</span>(;j &gt; startx;j--) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历左列</span></span><br><span class="line">            <span class="keyword">for</span>(;i &gt; starty;i--) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果n是奇数，中间位置单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            ret[startx][starty] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组part01</title>
      <link href="/posts/24744.html"/>
      <url>/posts/24744.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-704-二分查找"><a href="#LeetCode-704-二分查找" class="headerlink" title="LeetCode 704 二分查找"></a>LeetCode 704 二分查找</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/binary-search">704.二分查找</a></p><p>二分查找的前提是<strong>数组为有序数组</strong>，同时强调<strong>数组中没有重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。这些都是二分法的前提条件。</p><p>二分法有两种定义方式：</p><ul><li><strong>左闭右闭 即 [left,right]</strong></li><li><strong>左闭右开 即 [left,right]</strong></li></ul><h3 id="二分查找第一种写法"><a href="#二分查找第一种写法" class="headerlink" title="二分查找第一种写法"></a>二分查找第一种写法</h3><ul><li>因为左闭右闭的特性，因此，当 left&#x3D;&#x3D;right 也是成立的，所以循环条件使用 left&lt;&#x3D;right</li><li>其次，当if (nums[middle] &gt; target) 时，right 要赋值为 middle-1，因为左闭右闭特性，right&#x3D;middle-1时，区间依旧合法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//左闭右闭区间，此处的right是nums.size()-1</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//注意此处是lef&lt;=right</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二分查找第二种写法"><a href="#二分查找第二种写法" class="headerlink" title="二分查找第二种写法"></a>二分查找第二种写法</h3><ul><li>因为左闭右开的特性，因此，当 left&#x3D;&#x3D;right 是没有意义的，所以循环条件使用 left&lt;right</li><li>其次，当if (nums[middle] &gt; target) 时，right 要赋值为 middle，因为左闭右开特性，right&#x3D;middle时，区间依旧合法；如果right&#x3D;middle-1，那么middle-1这个下标位置就被忽略。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//左闭右开区间</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-27-移动元素"><a href="#LeetCode-27-移动元素" class="headerlink" title="LeetCode 27 移动元素"></a>LeetCode 27 移动元素</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/remove-element">27.移动元素</a></p><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>快慢指针是指两个指针<strong>从同一侧开始遍历数组</strong>，将这两个指针分别定义为<strong>快指针（fast）和慢指针（slow）</strong>，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如快指针（fast）每次增长两个，慢指针（slow）每次增长一个。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过快指针判断当前值是否等于val来处理遍历逻辑。快指针(fast)、慢指针(slow)均从起点出发，slow标记我们应该放置非目标元素的位置，而fast则遍历整个数组来寻找非目标元素</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt;= nums.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val &amp;&amp; fast == slow) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[fast] == val) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-977-有序数组的平方"><a href="#LeetCode-977-有序数组的平方" class="headerlink" title="LeetCode 977 有序数组的平方"></a>LeetCode 977 有序数组的平方</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array">977.移动数组的平方</a></p><h3 id="首尾指针"><a href="#首尾指针" class="headerlink" title="首尾指针"></a>首尾指针</h3><p>头指针（head）和尾指针（tail）分别从数组首部和尾部向中间进行遍历，快速排序和前面的二分查找都是首位指针的具体应用场景</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>因为数组的非递减顺序特性，这是很重要的一点，正是有了这个特性，我们才能通过首尾指针从数组两端向中间遍历，然后每次比较两端元素的平方，选择较大的平方值填入结果数组的末尾</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">result</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, index = result.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pow</span>(nums[left],<span class="number">2</span>) &lt; <span class="built_in">pow</span>(nums[right],<span class="number">2</span>)) &#123;</span><br><span class="line">                result[index] = <span class="built_in">pow</span>(nums[right],<span class="number">2</span>);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[index] = <span class="built_in">pow</span>(nums[left],<span class="number">2</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
