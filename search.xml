<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>委托构造和继承构造函数</title>
      <link href="/posts/33535.html"/>
      <url>/posts/33535.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-委托构造函数"><a href="#1-委托构造函数" class="headerlink" title="1.委托构造函数"></a>1.委托构造函数</h1><p><code>委托构造函数允许使用同一个类中的一个构造函数调用其他的构造函数，从而简化相关变量的初始化</code>。下面通过一个例子说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;<span class="comment">// 冗余代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;<span class="comment">// 冗余代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;<span class="comment">// 冗余代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_max;</span><br><span class="line"><span class="type">int</span> m_min;</span><br><span class="line"><span class="type">int</span> m_mid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">&quot;, middle: &quot;</span> &lt;&lt; t.m_mid &lt;&lt; <span class="string">&quot;, max: &quot;</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面三个重载的构造函数中都出现重复的代码，在C++11以前，我们会把重复的代码放到一个函数里，然后调用；在C++11以后，加入了委托构造，我们就可以轻松地完成代码的优化了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) : <span class="built_in">Test</span>(max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid) : <span class="built_in">Test</span>(max,min) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_max;</span><br><span class="line"><span class="type">int</span> m_min;</span><br><span class="line"><span class="type">int</span> m_mid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">&quot;, middle: &quot;</span> &lt;&lt; t.m_mid &lt;&lt; <span class="string">&quot;, max: &quot;</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完代码之后，冗余的代码全部都没有了，并且<code>在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用</code>。在使用委托构造函数的时候还需要注意一些几个问题：</p><ul><li>这种链式的构造函数调用不能形成一个闭环，否则会在运行期间抛出异常</li><li>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) &#123;</span><br><span class="line"><span class="built_in">Test</span>(max);          <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid) &#123;</span><br><span class="line"><span class="built_in">Test</span>(max, min);     <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误, 使用了委托构造函数就不能再次m_max初始化了</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) : <span class="built_in">Test</span>(max), <span class="built_in">m_max</span>(max) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-继承构造函数"><a href="#2-继承构造函数" class="headerlink" title="2.继承构造函数"></a>2.继承构造函数</h1><p>C++11中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i) :<span class="built_in">Base</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">Base</span>(i, j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">Base</span>(i, j, k) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> &lt;&lt; c.m_j &lt;&lt; <span class="string">&quot;, string: &quot;</span> &lt;&lt; c.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过继承构造函数在子类中重新定义和基类一样的构造函数：通过使用<code>using 基类名::基类的构造函数名</code>（类名和构造函数名一样）来使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> &lt;&lt; c.m_j &lt;&lt; <span class="string">&quot;, string: &quot;</span> &lt;&lt; c.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在修改之后的子类中，没有添加任何构造函数，而是添加了<code>using Base::Base;</code>这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。</p><p>另外如果在子类中隐藏了父类中的同名函数，也可以通过using的方式在子类中使用基类中的这些父类函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base class: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, string str)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base class: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="keyword">using</span> Base::func;       <span class="comment">// 引入Base的func重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;child class: i&#x27;am huang&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">250</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">func</span>();</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">18</span>);</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">18</span>, <span class="string">&quot;huang&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child <span class="keyword">class</span>: i<span class="string">&#x27;am huang</span></span><br><span class="line"><span class="string">base class: i = 18</span></span><br><span class="line"><span class="string">base class: i = 18, str = huang</span></span><br></pre></td></tr></table></figure><p>子类中的<code>func()</code>函数隐藏了基类中的两个<code>func()</code>因此默认情况下通过子类对象只能调用无参的func()，在上面的子类代码中添加了<code>using Base::func;</code>之后，就可以通过子类对象直接调用父类中被隐藏的带参func()函数了。</p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>using的使用</title>
      <link href="/posts/55817.html"/>
      <url>/posts/55817.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义别名"><a href="#1-定义别名" class="headerlink" title="1.定义别名"></a>1.定义别名</h1><p>在C++中，可以通过<code>typedef</code>重定义一个类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 旧类型名 新类型名;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br></pre></td></tr></table></figure><p>被重定义的类型并不意味着一个新类型，而是给原来的类型起了一个别名。在C++11中规定一种新的方法，使用using来定义类型别名。语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 新类型名 = 旧类型名;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">unsigned</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure><p>通过<code>using</code>和<code>typedef</code>的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个函数指针，using的优势就能凸显出来了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用typedef定义函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*func_ptr)</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用using定义函数指针</span></span><br><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">double</span>);</span><br></pre></td></tr></table></figure><p>如果比较熟悉函数指针，就能看出func_ptr是一个别名，本质是函数指针，它指向返回值类型为int，参数分别为int和double类型的函数地址。如果使用using定义函数指针别名的写法看起来就非常直观了，<code>把别名的名字强制分离到了左边，而把别名对应的实际类型放在了右边，比较清晰，可读性比较好</code></p><h1 id="2-模板的别名"><a href="#2-模板的别名" class="headerlink" title="2.模板的别名"></a>2.模板的别名</h1><p>使用typedef重定义的时候在某些情况下会有一点限制，比如无法重定义一个模板。如果我们需要一个固定以int类型为key的map，它可以和很多类型的value值进行映射，如果使用typedef这样直接定义就非常麻烦:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, string&gt; m1;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m2;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, <span class="type">double</span>&gt; m3;</span><br></pre></td></tr></table></figure><p>如果我么们通过模板进行定义呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, T&gt;m;   <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>编译器会报错，因为typename不支持给模板定义别名，这个简单的需求仅通过typedef很难办到，需要添加一个外敷类（此处不展开说明）。在C++11中，可以使用<code>using</code>来为模板定义别名，可以写成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> mymap = map&lt;<span class="type">int</span>, T&gt;;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定义别名，它是map&lt;int,T&gt;类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> mymap = map&lt;<span class="type">int</span>, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mymap&lt;string&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;huang&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;nba&quot;</span>));</span><br><span class="line"></span><br><span class="line">mymap&lt;<span class="type">double</span>&gt;m1;</span><br><span class="line">m<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">3.14</span>));</span><br><span class="line">m<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">1.314</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>最后要强调的是：using语法和typedef一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。</code></p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动类型推导</title>
      <link href="/posts/12428.html"/>
      <url>/posts/12428.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-final"><a href="#1-final" class="headerlink" title="1.final"></a>1.final</h1><p>C++11的关键字<code>final</code>有两个用途。<code>第一，它阻止某个虚函数不能被重写；第二，它限制某个类不能被继承。</code>如果使用<code>final</code>修饰函数，<code>只能修饰虚函数</code>，并且<code>要把final关键字放到类或者函数后面</code></p><h2 id="1-1-修饰函数"><a href="#1-1-修饰函数" class="headerlink" title="1.1 修饰函数"></a>1.1 修饰函数</h2><p>如果将类方法标记为fianal，这意味着无法在子类中重写该方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用final关键字标记该方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> :<span class="keyword">public</span> Child &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//报错，此时不能再重写该虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-修饰类"><a href="#1-2-修饰类" class="headerlink" title="1.2 修饰类"></a>1.2 修饰类</h2><p>C++11中允许将类标记为final，直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用final关键字标记Child类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">final</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错，此时不能继承Child类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> :<span class="keyword">public</span> Child &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Child</code>类被<code>final</code>修饰过，因此<code>Child</code>类不允许有派生类，<code>GrandChild</code>类的继承是非法的</p><h1 id="2-override"><a href="#2-override" class="headerlink" title="2.override"></a>2.override</h1><p><code>override</code>关键字<code>确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，（起到检查的作用，让人一眼就能看出来该方法是重写父类中的方法）</code>这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> :<span class="keyword">public</span> Child &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//报错，因为override表明这是一个重写函数，但是父类中却没有这样的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test11</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动类型推导</title>
      <link href="/posts/12430.html"/>
      <url>/posts/12430.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-模板的右尖括号"><a href="#1-模板的右尖括号" class="headerlink" title="1.模板的右尖括号"></a>1.模板的右尖括号</h1><p>泛型编程中，模板实例化是一个非常繁琐的地方，那就是连续的<code>两个右尖括号（&gt;&gt;）</code>会被编译器解析成右移操作，而不是模板参数表的结束，在C++11以前需要在<code>&gt;&gt;</code>之间加上一个空格<code>&gt; &gt;</code>。C++11之后就不需要再加上空格，改进了编译器的解析规则，尽可能的将多个右尖括号解析成模板参数结束符。</p><h1 id="2-默认模板参数"><a href="#2-默认模板参数" class="headerlink" title="2.默认模板参数"></a>2.默认模板参数</h1><p>在C++11以前，类模板是可以有默认的模板参数，但是不支持函数的默认模板参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>, T t = <span class="number">520</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">void</span> <span class="built_in">print</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;current value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test&lt;&gt;t;</span><br><span class="line">t.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">Test&lt;<span class="type">int</span>, <span class="number">1024</span>&gt;t1;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>在C++11中添加了默认模板参数的支持：</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T </span>= <span class="type">long</span>, <span class="keyword">typename</span> U = <span class="type">int</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">mytest</span>(T t = <span class="string">&#x27;A&#x27;</span>, U u = <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t: &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot;, u: &quot;</span> &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">mytest</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// 自动推导，根据传递的实参 mytest&lt;char,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;int,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;char,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;int,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;char,int&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>();<span class="comment">// 没有显示指定类型，没有传递实参，使用默认类型 mytest&lt;long,int&gt;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面例子可以得出结论：<code>当所有模板参数都有默认参数时，函数模板调用相当于调用普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板类名后跟随&lt;&gt;进行实例化</code></p><p><code>此外，函数模板的默认模板参数在使用时和其他默认参数也有些不同，它没有必须写在参数表最后的限制。</code>当默认模板参数和模板参数自动推导同时使用时（优先级从高到低）：</p><ul><li>如果可以推导出参数类型则使用推导出的类型</li><li>如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数（默认的函数参数不能用于类型推导）</li><li>如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录算法训练营第五天</title>
      <link href="/posts/40691.html"/>
      <url>/posts/40691.html</url>
      
        <content type="html"><![CDATA[<h1 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h1><p><strong>用来快速判断一个元素是否出现集合里的情况</strong>，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map（映射）</li></ul><p>在C++中，set和map分别提供了以下三种数据结构：</p><table><thead><tr><th align="center">集合</th><th align="center">底层实现</th><th align="center">是否有序</th><th align="center">数值是否可以重复</th><th align="center">能否更改数值</th><th align="center">查询效率</th><th align="center">增删效率</th></tr></thead><tbody><tr><td align="center">std::set</td><td align="center">红黑树</td><td align="center">有序</td><td align="center">否</td><td align="center">否</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::multiset</td><td align="center">红黑树</td><td align="center">有序</td><td align="center">是</td><td align="center">否</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::unordered_set</td><td align="center">哈希表</td><td align="center">无序</td><td align="center">否</td><td align="center">否</td><td align="center">O(1)</td><td align="center">O(1)</td></tr></tbody></table><p>std::set和std::multiset底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><table><thead><tr><th align="center">映射</th><th align="center">底层实现</th><th align="center">是否有序</th><th align="center">数值是否可以重复</th><th align="center">能否更改数值</th><th align="center">查询效率</th><th align="center">增删效率</th></tr></thead><tbody><tr><td align="center">std::map</td><td align="center">红黑树</td><td align="center">key有序</td><td align="center">key不可重复</td><td align="center">key不可修改</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::multimap</td><td align="center">红黑树</td><td align="center">key有序</td><td align="center">key可重复是</td><td align="center">key不可修改</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::unordered_map</td><td align="center">哈希表</td><td align="center">key无序</td><td align="center">key不可重复</td><td align="center">key不可修改</td><td align="center">O(1)</td><td align="center">O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p><h1 id="三种哈希结构的使用场景"><a href="#三种哈希结构的使用场景" class="headerlink" title="三种哈希结构的使用场景"></a>三种哈希结构的使用场景</h1><ol><li><p>若数据范围有限（如元素值较小或数组长度固定），优先使用数组哈希（通过元素值直接映射下标），存储高效且访问速度快；</p></li><li><p>若数据范围较大或元素值分布稀疏，使用哈希集合（如 std::unordered_set） 可避免空间浪费；</p></li><li><p>若需统计元素出现频次，则需采用哈希映射（如 std::unordered_map） 记录键值对，兼顾存在性检查和次数统计。</p></li></ol><h1 id="LeetCode-242-有效的字母异位词"><a href="#LeetCode-242-有效的字母异位词" class="headerlink" title="LeetCode 242 有效的字母异位词"></a>LeetCode 242 有效的字母异位词</h1><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/valid-anagram">242.有效的字母异位词</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题可以使用数组哈希的方式进行查询。我们通过定义一个数组来记录字符串s中的出现次数，**那么我们应该定义多大空间的数组呢？**显然，我们要记录字符串s中每一个字符出现的次数，因此我们需要开辟一个空间大小为26的数组letter。需要把字符映射到数组也就是哈希表的索引下标上，**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**我们在遍历字符串s的时候，只需要将<code>s[i]-&#39;a&#39;</code>所在的元素进行<code>+1</code>操作即可。</p><img src="https://img.imgdd.com/f431153a-58af-4ae0-9f12-265b1b23339e.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>遍历完字符串s之后，我们再遍历字符串t，不同的是我们要对t中出现的字符映射哈希表索引上的数值进行<code>-1</code>的操作。</p><img src="https://img.imgdd.com/0ce71d0a-0d08-46f3-b131-a096bfff1256.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>最后，对letter数组进行遍历，<strong>如果数组中有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，返回false。</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compareStr</span><span class="params">(string s,string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> letter[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//第一次遍历字符串s，记录s中每个字符出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            letter[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次遍历字符串t</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : t) &#123;</span><br><span class="line">            letter[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后遍历letter数组，如果有非0，表示出现非公共字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> count : letter) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="built_in">compareStr</span>(s,t);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h1 id="LeetCode-349-两个数组的交集"><a href="#LeetCode-349-两个数组的交集" class="headerlink" title="LeetCode 349 两个数组的交集"></a>LeetCode 349 两个数组的交集</h1><p>**题目链接：**<a href="https://leetcode.cn/problems/intersection-of-two-arrays">https://leetcode.cn/problems/intersection-of-two-arrays</a></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这道题目，因为数组的长度范围是 1-1000，而每一个元素的数组是0-1000，很明显这题不能像上一题一样使用数组作为哈希表的结构</p><p>我们此时可以使用unorder_set的哈希结构求解两个范围较大的数组的交集。</p><ul><li>首先将nums1的元素存入哈希集合temp，该哈希集合会自动去重</li><li>然后遍历nums2，检查每个元素是否存在哈希集合temp中，若存在加入结果集result</li><li>注意，结果集result也要使用unorder_set结构，因为nums2可能会出现重复的元素，避免这些重复元素再次加入到结果集内</li></ul><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放结果</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;result;           </span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;<span class="built_in">temp</span>(nums<span class="number">1.</span><span class="built_in">begin</span>(),nums<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> number : nums2) &#123;</span><br><span class="line">            <span class="comment">//每次从nums2中取出一个元素后，在哈希表中查找是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="built_in">find</span>(number) != temp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result.<span class="built_in">insert</span>(number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-202-快乐数"><a href="#LeetCode-202-快乐数" class="headerlink" title="LeetCode 202 快乐数"></a>LeetCode 202 快乐数</h1><p>**题目链接：**<a href="https://leetcode.cn/problems/happy-number">https://leetcode.cn/problems/happy-number</a></p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>题目中说过会出现无限循环的情况，**那么无限循环的情况会是什么呢？**如果仔细思考能够发现，如果某一个数重复出现，那不就表明它接下来的计算还会得出已经出现过的结果。例如：<code>4-&gt;16-&gt;37-&gt;58-&gt;89-&gt;145-&gt;42-&gt;20-&gt;4-&gt;16-&gt;...</code></p><p>因此，为了判断是否出现重复出现数字的情况，我们可以使用unordered_set结构进行判断</p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n%<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-1-两数之和"><a href="#LeetCode-1-两数之和" class="headerlink" title="LeetCode 1 两数之和"></a>LeetCode 1 两数之和</h1><p>**题目链接：**<a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum\</a></p><h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h2><p>这道题目我们使用unordered_map，key保存的是元素值，value保存的是当前元素值在数组中的下标。</p><p>遍历数组时，对于每个元素nums[i]，计算目标差值gap，然后在哈希表中查找是否存在这个差值，如果能找到，表明有另一个数可以和其相加得到target，此时返回当前数的索引和匹配值的索引；否则，否则将当前元素及其索引存入哈希表以便后续查找，确保只需一次遍历即可找到解。</p><h2 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="comment">//元素 下标</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map;    </span><br><span class="line">        map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[<span class="number">0</span>],<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="type">int</span> gap = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(gap);</span><br><span class="line">            <span class="keyword">if</span>(iter != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(i);</span><br><span class="line">                result.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量表达式修饰符-constexpr</title>
      <link href="/posts/63765.html"/>
      <url>/posts/63765.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-constexpr"><a href="#1-constexpr" class="headerlink" title="1.constexpr"></a>1.constexpr</h2><h3 id="1-1-const"><a href="#1-1-const" class="headerlink" title="1.1 const"></a>1.1 const</h3><p>在C++11之前只有const关键字，从功能上来说它有双重语义：<strong>变量只读、修饰常量</strong>，通过一个例子体会一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义两个变量</span></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> a2 = <span class="number">250</span>;</span><br><span class="line"><span class="comment">//定义常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> count = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; b = a1;</span><br><span class="line">b = a2;<span class="comment">//错误</span></span><br><span class="line">a1 = <span class="number">1314</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//输出1314</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> array[count];<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> array[a1];<span class="comment">//报错 </span></span><br><span class="line"><span class="type">int</span> array[num];<span class="comment">//报错 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数<code>void func(const int num)</code>的参数<code>num</code>表示<strong>该变量只读，但不是常量</strong>。因此，以<code>int array[num];</code>方式定义数组，编译器会报错，提示<code>num不作为常量使用</code></li><li><code>const int count = 24</code>中的<code>const</code>却是一个常量，因此可以使用这个常量来定义一个静态数组。</li><li>b是一个常量的引用，因此它初始化之后就不能被修改，因此<code>b = a2</code>会报错</li><li>引用b是只读的，并不能保证它的值不会被改变，也就是说它不是常量</li></ul><h3 id="1-2-constexpt"><a href="#1-2-constexpt" class="headerlink" title="1.2 constexpt"></a>1.2 constexpt</h3><p>在C++11中添加了一个新的关键字<code>constexpr</code>，这个关键字是用来修饰常量表达式的。所谓<strong>常量表达式，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。</strong></p><p>C++程序从编写完毕到执行分为四个阶段：<strong>预处理、 编译、汇编和链接</strong>。需要额外强调的是，常量表达式和非常量表达式的计算时机不同，<strong>非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段</strong>，这极大提高了程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p><strong>那么编译器如何识别表达式是常量表达式还是变量表达式呢？<strong>在C++11中添加了<code>constexpr</code>关键字之后就可以在程序中使用它来修饰常量表达式，用来提高程序的执行效率。在使用中建议将const和constexpr的功能区分开，即</strong>凡是表达“只读”语义的场景都使用const，表达“常量”语义的场景都使用constexpr。</strong></p><p>在C++11之前，<code>const</code>和<code>constexpr</code>是等价的，都可以在程序编译阶段计算出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> m = <span class="built_in">f</span>();  <span class="comment">// 不是常量表达式，m的值只有在运行时才会获取。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=i<span class="number">+1</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> j=i<span class="number">+1</span>;    <span class="comment">// 是一个常量表达式</span></span><br></pre></td></tr></table></figure><p>但是在C++11之后，对于<strong>内置数据类型</strong>，推荐使用<code>constexpr</code>修饰，这样编译器在程序的编译阶段就能计算出常量的结果。但如果是<strong>自定义数据类型</strong>（<code>struct</code>和<code>class</code>），不能直接使用<code>constexpr</code>修饰</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器提示 constexpr在此处无效</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要修饰自定义数据类型，可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span> &#123;</span><br><span class="line"><span class="type">int</span> num1;</span><br><span class="line"><span class="type">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> T t&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;<span class="comment">//定义一个常量的结构体对象，并在声明时初始化</span></span><br><span class="line">t.num1 = <span class="number">10</span>;<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-常量表达式函数"><a href="#2-常量表达式函数" class="headerlink" title="2.常量表达式函数"></a>2.常量表达式函数</h2><p>可以使用<code>constexpr</code>修饰函数的返回值，这种函数被称作<strong>常量表达式函数</strong>，这些函数主要包括以下几种：<strong>普通函数&#x2F;类成员函数、类的构造函数、模板函数。</strong></p><h3 id="2-1修饰函数"><a href="#2-1修饰函数" class="headerlink" title="2.1修饰函数"></a>2.1修饰函数</h3><p><code>constexpr</code>并不能修饰任意函数的返回值，使得这些函数都能成为常量表达式函数，必须满足以下条件：</p><ol><li>函数必须要有返回值，并且return返回的表达式必须是常量表达式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误 没有返回值（报错信息：constexpr函数&quot;func1&quot;不能生成常量表达式）</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误 返回值不是常量表达式（报错信息：表达式的计算机过不是常数）</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数在使用之前，必须要有对应的定义语句</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ret = <span class="built_in">func3</span>();<span class="comment">//报错，因为在使用之前只有声明没有定义</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>整个函数的函数体中，不能出现非常量表达式之外的语句（using指令、typedef语句以及static_assert断言、return语句除外）。因此，常量表达式函数是一类功能非常简单的函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误 for循环是一个非法操作</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> mytype = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">constexpr</span> mytype a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">constexpr</span> mytype b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> mytype c = a * b;</span><br><span class="line"><span class="keyword">return</span> c - (a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 以上三条规则不仅对应普通函数适用，对应类的成员函数也是适用的：</p><h3 id="2-2-修饰模板函数"><a href="#2-2-修饰模板函数" class="headerlink" title="2.2 修饰模板函数"></a>2.2 修饰模板函数</h3><p>C++11 语法中，<code>constexpr</code>可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。<strong>如果constexpr修饰的模板函数实例化结果不满足常量表达式函数的要求，则constexpr会被自动忽略，即该函数就等同于一个普通函数。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">display</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* name;<span class="comment">//注意此处不能使用string</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> p &#123;<span class="string">&quot;Lina&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> ret = <span class="built_in">display</span>(p);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量表达式函数</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">display</span>(<span class="number">250</span>);</span><br><span class="line">cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> p1 &#123; <span class="string">&quot;Mike&quot;</span>, <span class="number">19</span> &#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> ret2 = <span class="built_in">display</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; ret<span class="number">2.</span>name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; ret<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>struct Person ret = display(p);</code>由于参数p是变量，因此，返回值的类型就不是常量表达式，也不满足常量表达式函数的要求，此时<code>constexpr</code>是无效的</li><li><code>constexpr int ret1 = display(250);</code>由于参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li><li><code>constexpr struct Person ret2 = display(p1);</code>由于参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li></ul><h3 id="2-3-修饰构造函数"><a href="#2-3-修饰构造函数" class="headerlink" title="2.3 修饰构造函数"></a>2.3 修饰构造函数</h3><p>如果要使用<code>constexpr</code>来修饰一个构造函数，那么这个<strong>构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Person</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">int</span> age)</span> :name(p), age(age) &#123;</span>&#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> <span class="built_in">p1</span>(<span class="string">&quot;luffy&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;luffy&#x27;s name: &quot;</span> &lt;&lt; p<span class="number">1.</span>name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; p<span class="number">1.</span>age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针控制类型</title>
      <link href="/posts/22516.html"/>
      <url>/posts/22516.html</url>
      
        <content type="html"><![CDATA[<p>在C++程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为<strong>NULL</strong>，避免产生野指针。在C++98&#x2F;03标准中，将一个指针初始化为空有两种方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* p2 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>在底层NULL的源码定义是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在C中，NULL会被强制转换重<code>void*</code>类型，但是在C++中，是不允许一个<code>void*</code>类型的指针隐式转换为其他类型的指针，因此，为了兼容以前的设计，C++就把NULL定义成字面量0。但是，<strong>C++中将NULL定义为字面值常量0</strong>在某些场景下并不能很好的工作，例如，函数重载时，<strong>NULL和0无法区分</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(char* p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(int p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">250</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码打印结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br></pre></td></tr></table></figure><p>从打印结果可以看出，虽然调用<code>func(NULL)</code>，但最终还是调用<code>void func(int p)</code>，其实，这个原因正是因为C++把NULL定义成字面量0，因此，函数重载的是<code>void func(int p)</code></p><p>出于兼容性的考虑，C++11标准并没有对NULL的宏定义做任何修改，而是另其炉灶，引入了一个新的关键字nullptr。<strong>nullptr专用于初始化空类型指针，不同类型的指针变量都可以使用nullptr来初始化</strong>。可以将nullptr隐式转换成int*、char*以及double*指针类型。使用nullptr也可以很完美的解决上边提到的函数重载问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(char* p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(int p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* ptr1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span>* ptr2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">double</span>* ptr3 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span>* ptr4 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++里不允许void*隐式类型转换成其他类型的指针</span></span><br><span class="line"><span class="type">int</span>* ptr5 = (<span class="type">int</span>*)ptr4;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int</span></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//char*</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">250</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试代码结果打印</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br></pre></td></tr></table></figure><p>通过输出的结果可以看出，<strong>nullptr无法隐式转换为整形，但是可以隐式匹配指针类型。在 C++11标准下，相比NULL和0，推荐大家都是用nullptr来初始化空指针。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动类型推导</title>
      <link href="/posts/12429.html"/>
      <url>/posts/12429.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-auto"><a href="#1-auto" class="headerlink" title="1.auto"></a>1.auto</h1><p>在C++11之前，auto和static是对应的，表示<strong>变量自动存储</strong>，但是非static的局部变量默认都是自动存储的，因此这个关键字变得非常鸡肋，但是，在C++11中他们被赋予了新的含义，使用这个关键字能够像别的语言一样<strong>自动推导出变量的实际类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> <span class="type">int</span> a = <span class="number">0</span>;<span class="comment">// C++11以前：显式声明为自动存储（默认就是auto，一般不写）</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b = <span class="number">0</span>;<span class="comment">// 静态存储，生命周期持续到程序结束</span></span><br><span class="line">a++;</span><br><span class="line">b++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;auto a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; static int b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>();<span class="comment">// auto a=1 static int b=1</span></span><br><span class="line"><span class="built_in">func</span>();<span class="comment">// auto a=1 static int b=2</span></span><br><span class="line"><span class="built_in">func</span>();<span class="comment">// auto a=1 static int b=3</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-1-推导规则"><a href="#1-1-推导规则" class="headerlink" title="1.1 推导规则"></a>1.1 推导规则</h2><p>从上面的案例能发现，在C++11以前，auto并不代表一种实际的数据类型，只是一个类型声明的“占位符”，auto并非在任意场景下都能够推导出变量的实际类型。**使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型。**使用语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> 变量名 = 变量值;</span><br></pre></td></tr></table></figure><p>下面举个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;<span class="comment">// x是int类型</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.1415</span>;<span class="comment">// y是double类型</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="string">&#x27;a&#x27;</span>;<span class="comment">// z是char类型</span></span><br><span class="line"><span class="keyword">auto</span> a;<span class="comment">// 报错，没有进行初始化</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">double</span> x;<span class="comment">// 报错，不能与任何其他类型组合（不能修改数据类型）</span></span><br></pre></td></tr></table></figure><p>auto还可以和指针、引用结合起来使用也可以带上const、volatile限定符，在不同的场景下有对应的推导规则，规则内容如下：</p><ul><li>当变量不是指针或引用类型时，推导结果中不会保留const、volatile关键字</li><li>当变量是指针或引用类型时，推导结果中会保留const、bolatile关键字</li></ul><p>光是看上面的文字就觉得有些抽象，下面通过几个例子感受一下，第一个例子先介绍变量带指针和引用并使用auto进行类型推导：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">auto</span>* a = &amp;temp;<span class="comment">// &amp;temp: int* --&gt; auto* = int* --&gt; auto: int</span></span><br><span class="line"><span class="keyword">auto</span> b = &amp;temp;<span class="comment">// &amp;temp: int* --&gt; auto: int* </span></span><br><span class="line"><span class="keyword">auto</span>&amp; c = temp;<span class="comment">// auto: int</span></span><br><span class="line"><span class="keyword">auto</span> d = temp;<span class="comment">// auto: int</span></span><br></pre></td></tr></table></figure><p>第二个例子介绍的是带const限定的变量，并使用auto进行类型推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">250</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> a1 = tmp;<span class="comment">// auto: int</span></span><br><span class="line"><span class="keyword">auto</span> a2 = a1;<span class="comment">// a1: const int --&gt; auto: int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; a3 = tmp;<span class="comment">// a3: const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp; a4 = a3;<span class="comment">// a4: const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>* pt4 = &amp;a1;<span class="comment">// pt4: const int*</span></span><br></pre></td></tr></table></figure><ul><li>变量<code>a1</code>的数据类型为<code>const int</code>，因此auto关键字被推导为<code>int</code>类型</li><li>变量<code>a2</code>的数据类型为<code>int</code>，但是a2没有声明为指针或引用，因此<code>const</code>属性被去掉, <code>auto</code>被推导为<code>int</code></li><li>变量<code>a3</code>的数据类型为<code>const int&amp;</code>，a3被声明为引用，因此const属性被保留，<code>auto</code>关键字被推导为<code>int</code>类型</li><li>变量<code>a4</code>的数据类型为<code>const int&amp;</code>，a4被声明为引用，因此const属性被保留，<code>auto</code>关键字被推导为<code>const int</code>类型</li><li>变量<code>pt4</code>的数据类型为<code>const int*</code>，pt4被声明为指针，因此推导结果保留const，<code>auto</code>关键字被推导<code>const int</code>类型</li></ul><h2 id="1-2-auto的限制"><a href="#1-2-auto的限制" class="headerlink" title="1.2 auto的限制"></a>1.2 auto的限制</h2><p>auto关键字并不是万能的，在某些场景下不能完成类型推导</p><ol><li>不能作为函数的参数使用。因为只有在函数调用的时候才会给函数参数传递实参，但是auto要求必须要初始化赋值，因此，二者矛盾</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)</span> </span>&#123;      <span class="comment">//报错：此处不能使用auto</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>不能用于类的非静态成员变量的初始化。因为类的非静态成员变量不属于类，它属于对象的，只有当这个类被创建出来后才能给该成员变量赋值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> v1 = <span class="number">0</span>;<span class="comment">// 报错</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">auto</span> v2 = <span class="number">0</span>;<span class="comment">// 报错 类的静态非常量成员不允许在类内部直接初始化（基础语法）</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> v3 = <span class="number">10</span>;<span class="comment">// 正确</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>不能使用auto关键字定义数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> array[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> t1 = array;<span class="comment">// 正确 auto: int*</span></span><br><span class="line"><span class="keyword">auto</span> t2[] = array;<span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">auto</span> t3[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;<span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>无法使用auto推导出模板参数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test&lt;<span class="type">double</span>&gt; t;</span><br><span class="line">    Test&lt;<span class="keyword">auto</span>&gt; t1 = t;      <span class="comment">// 报错 无法推导出模板类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-auto的应用"><a href="#1-3-auto的应用" class="headerlink" title="1.3 auto的应用"></a>1.3 auto的应用</h2><ol><li>用于STL容器的遍历</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;ace&quot;</span>));</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;sabo&quot;</span>));</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;luffy&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>用于泛型编程</code>，在使用模板的时候，大多数情况下我们不知道该定义什么类型的变量，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> ret = A::<span class="built_in">get</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>&lt;T1&gt;();</span><br><span class="line"><span class="built_in">func</span>&lt;T2&gt;();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中定义了模板函数func，在函数内部调用类A的静态方法get()，但是我们不知道调用的是哪一个返回值的get()方法，因此返回值的类型不能确定，如果不使用auto，就需要再定义一个模板参数，并且在外部调用时手动指定get的返回值类型，具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;        <span class="comment">// 添加了模板参数B</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B val = A::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;T1, <span class="type">int</span>&gt;();                 </span><br><span class="line">    <span class="built_in">func</span>&lt;T2, string&gt;();              </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-decltype"><a href="#2-decltype" class="headerlink" title="2.decltype"></a>2.decltype</h1><p>在<strong>编译时期</strong>进行自动类型推导。引入decltype是因为auto并不适用于所有的自动类型推导场景，在某些特殊情况下auto用起来很不方便，甚至压根无法使用。语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br></pre></td></tr></table></figure><p>decltype的推导是在编译期完成的，**它只是用于表达式类型的推导，并不会计算表达式的值。**来看一组简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">100</span>;<span class="comment">// b-&gt;int</span></span><br><span class="line"><span class="keyword">decltype</span>(a + <span class="number">3.14</span>) c = <span class="number">3.14</span>;<span class="comment">// c-&gt;double</span></span><br></pre></td></tr></table></figure><h2 id="2-1-推导规则"><a href="#2-1-推导规则" class="headerlink" title="2.1 推导规则"></a>2.1 推导规则</h2><ol><li>表达式为<code>普通变量或普通表达式或类成员表达式</code>，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string text;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; y = x;<span class="comment">// y -&gt; const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(x) a = x;<span class="comment">// a -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(y) b = x;<span class="comment">// b -&gt; const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(Test::value) c = <span class="number">0</span>;<span class="comment">// c -&gt; const int</span></span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line"><span class="keyword">decltype</span>(t.text) d = <span class="string">&quot;hello&quot;</span>;<span class="comment">// d -&gt; string</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>表达式是<code>函数调用</code>，则decltype推导的类型应和函数返回值类型一致</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;...&#125;;</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func_int</span><span class="params">()</span></span>;                 <span class="comment">// 返回值为 int</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func_int_r</span><span class="params">()</span></span>;              <span class="comment">// 返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">()</span></span>;            <span class="comment">// 返回值为 int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">func_cint</span><span class="params">()</span></span>;          <span class="comment">// 返回值为 const int</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">func_cint_r</span><span class="params">()</span></span>;       <span class="comment">// 返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">()</span></span>;     <span class="comment">// 返回值为 const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Test <span class="title">func_ctest</span><span class="params">()</span></span>;        <span class="comment">// 返回值为 const Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>()) a = <span class="number">0</span>;<span class="comment">// a: int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>()) b = n;<span class="comment">// b: int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) c = <span class="number">0</span>;<span class="comment">// c: int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint</span>())  d = <span class="number">0</span>;<span class="comment">// d: int   纯右值，此处忽略const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_r</span>())  e = n;<span class="comment">// e: const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) f = <span class="number">0</span>;<span class="comment">// f: const int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_ctest</span>()) g = <span class="built_in">Test</span>();<span class="comment">// g: const Test  纯右值，但是是类类型，可以保留const</span></span><br></pre></td></tr></table></figure><p>函数func_cint()返回的是一个<code>纯右值</code>，<code>对于纯右值而言，只有类类型可以携带const、volatile限定符</code>，除此之外需要忽略掉这两个限定符，因此推导出的变量d的类型为int而不是const int</p><ol start="3"><li>表达式是一个<code>左值，或者被括号()包围</code>，使用decltype推导出的是表达式类型的引用（如果有const、volatile限定符不能忽略）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string text;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> Test obj;</span><br><span class="line"><span class="comment">// 带有括号的表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(obj.num) a = <span class="number">0</span>;<span class="comment">// 规则一 a: int</span></span><br><span class="line"><span class="keyword">decltype</span>((obj.num)) b = a;<span class="comment">// 规则三 b: const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法表达式</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;<span class="comment">// c: int</span></span><br><span class="line"><span class="keyword">decltype</span>(n = n + m) d = n;<span class="comment">// d: int&amp;  n+m保存到n中，此时n是一个左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-decltype的应用"><a href="#2-2-decltype的应用" class="headerlink" title="2.2 decltype的应用"></a>2.2 decltype的应用</h2><p> decltype的应用多出现在泛型编程中，比如我们编写一个类模板，在里边添加遍历容器的函数，操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (m_it = t.<span class="built_in">begin</span>(); m_it != t.<span class="built_in">end</span>(); m_it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;valu: &quot;</span> &lt;&lt; *m_it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it; <span class="comment">// 这里不能确定迭代器类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;ls1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line"><span class="type">const</span> list&lt;<span class="type">int</span>&gt; ls2&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line">Container&lt;list&lt;<span class="type">int</span>&gt;&gt;c1;</span><br><span class="line">Container&lt;<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&gt;c2;</span><br><span class="line">c<span class="number">1.</span><span class="built_in">print</span>(ls1);</span><br><span class="line">c<span class="number">2.</span><span class="built_in">print</span>(ls2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>原始字面量</title>
      <link href="/posts/3774.html"/>
      <url>/posts/3774.html</url>
      
        <content type="html"><![CDATA[<p>在C++11中添加了<strong>定义原始字符串的字面量</strong>，定义方式为<code>R &quot;xxx(原始字符串)xxx&quot;</code>，其中（）两边的字符串可以省略。原始字面量R<strong>可以直接表示字符串的实际含义，而不需要而外的转义字符进行转义</strong></p><p>例如，当我们要打印一个路径时，由于路径字符串中常常包含一些特殊字符，传统方法通常需要使用转义字符’&#39;来处理。但如果使用原始字符串字面量，就可以轻松解决这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;D:\hello\world\test.text&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    string str1 = <span class="string">&quot;D:\\hello\\world\\test.text&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    string str2 = <span class="string">R&quot;hello(D:\hello\world\test.text)world&quot;;</span></span><br><span class="line"><span class="string">    cout &lt;&lt; &quot;str2: &quot; &lt;&lt; str2 &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:helloworld    est.text</span><br><span class="line">D:\hello\world\test.text</span><br><span class="line">D:\hello\world\test.text</span><br></pre></td></tr></table></figure><ul><li>第一条语句中，\h和\w转义失败，对应地字符串会原样输出</li><li>第二条语句中，第一个反斜杠是对第二个反斜杠的转义，最终才能得到一个没有特殊含义的普通字符\</li><li>第三条语句中，使用了原始字面量R()中的内容来描述路径的原始字符串，因此无需做任何处理</li></ul><p>在C++11之前如果一个字符串分别写到了不同的行里边，需要加连接符，这种方式不仅繁琐，还破坏了表达式的原始含义，如果使用原始字面量就变得简单很多，很强直观，可读性强。我们再用过一个输出HTML标签的例子体会一下原始字面量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">R&quot;(&lt;html&gt;</span></span><br><span class="line"><span class="string">                    &lt;head&gt;</span></span><br><span class="line"><span class="string">                        &lt;title&gt;</span></span><br><span class="line"><span class="string">                            海贼王</span></span><br><span class="line"><span class="string">                        &lt;/title&gt;</span></span><br><span class="line"><span class="string">                    &lt;/head&gt;</span></span><br><span class="line"><span class="string">                    &lt;body&gt;</span></span><br><span class="line"><span class="string">                        &lt;p&gt;</span></span><br><span class="line"><span class="string">                            我是要成为海贼王的男人!!!</span></span><br><span class="line"><span class="string">                        &lt;/p&gt;</span></span><br><span class="line"><span class="string">                    &lt;/body&gt;</span></span><br><span class="line"><span class="string">                 &lt;/html&gt;)&quot;</span>;</span><br><span class="line">    cout &lt;&lt;  str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">str: &lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">            &lt;title&gt;</span><br><span class="line">                海贼王</span><br><span class="line">            &lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                我是要成为海贼王的男人!!!</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>最后强调一个细节：<strong>在R “xxx()xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且</strong>加的字符串必须在括号两边同时出现(两边出现的字符一模一样)</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str2 = <span class="string">R&quot;hello(D:\hello\world\test.text)hello&quot;</span>;      <span class="comment">//正确</span></span><br><span class="line">string str3 = <span class="string">R&quot;hello(D:\hello\world\test.text)world&quot;;      //错误</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录算法训练营第四天</title>
      <link href="/posts/23629.html"/>
      <url>/posts/23629.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-24-两两交换链表中的节点"><a href="#LeetCode-24-两两交换链表中的节点" class="headerlink" title="LeetCode 24 两两交换链表中的节点"></a>LeetCode 24 两两交换链表中的节点</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs">24.两两交换链表中的节点</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题就是正常的<strong>模拟</strong>，建议使用虚拟头结点。做题分析的时候一定要画图，因为这道题目涉及多个指针操作，相互指向。</p><ol><li>初始时，我们让cur指向虚拟头结点，然后进行如下步骤就可以交换相邻两个节点。在交换过程中，cur指向当前节点，cur-&gt;next指向当前需要交换的第一个节点（temp），而temp-&gt;next则是第二个节点（p）。通过调整指针，完成交换。</li></ol><img src="https://img.imgdd.com/c5182e60-ee9a-4bec-986c-b4074a0689f5.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><ol start="2"><li><p>接下来我们要更新cur的值，每次交换完成后，cur要指向交换后的第二个节点，即原来的第一个节点。这样就可以继续交换接下来的节点。</p></li><li><p>最后，就是要确定循环停止的终止条件。终止条件需要确保链表中还有足够的节点进行交换。当cur-&gt;next &#x3D;&#x3D; nullptr时，意味着已经没有更多的节点；当cur-&gt;next-&gt;next &#x3D;&#x3D; nullptr时，意味着剩下的节点不足两节点进行交换。</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            ListNode* p = temp-&gt;next;</span><br><span class="line">            <span class="comment">//开始交换</span></span><br><span class="line">            cur-&gt;next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = temp;</span><br><span class="line">            cur = temp;         <span class="comment">//cur = cur-&gt;next-&gt;next;</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-19-删除链表的倒数第N个节点"><a href="#LeetCode-19-删除链表的倒数第N个节点" class="headerlink" title="LeetCode 19 删除链表的倒数第N个节点"></a>LeetCode 19 删除链表的倒数第N个节点</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">19.删除链表的倒数第N个节点</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p>删除链表倒数第N个节点，可以将该问题转化成如何找到链表倒数第N个节点</p></li><li><p>我们可以通过快慢指针的方法找到链表倒数第N个节点。先让fast指针向前移动n+1步，使得fast和slow之间相隔n+1个节点，为什么是n+1呢？因为这样同时移动的时候slow指针才能指向待删除节点的前一个节点（方便进行删除操作）</p></li><li><p>fast指针和slow指针同时移动，直到fast指向末尾，然后删除slow指向的下一个节点</p></li></ol><img src="https://img.imgdd.com/9bb3bfa4-1fe0-4e0e-8eca-57b0f9175820.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-面试题-02-07-链表相交"><a href="#LeetCode-面试题-02-07-链表相交" class="headerlink" title="LeetCode 面试题 02.07 链表相交"></a>LeetCode 面试题 02.07 链表相交</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci">面试题 02.07.链表相交</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><p>分别遍历链表A和链表B，统计它们的长度lenA和lenB,目的是为了后续对齐两个链表的遍历起点。</p></li><li><p>对齐两个链表的遍历起点。假设 lenA &gt; lenB，让指向链表A的指针curA先移动lenA-lenB 步。这样，两个链表末尾剩余节点数相等，此时就能同步遍历比较</p></li></ol><img src="https://img.imgdd.com/cf81ee82-d505-4d1a-8ae3-4eba1f74327a.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><ol start="3"><li>从对齐后的位置开始，同时移动curA和curB，逐个比较它们指向的节点是否相同。如果 curA&#x3D;&#x3D;curB，说明找到了相交节点，直接返回该节点。</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算A链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算B链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">//统一使curA指向最长的链表</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> gapLen = lenA - lenB;</span><br><span class="line">        <span class="keyword">while</span>(gapLen--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-142-环形链表"><a href="#LeetCode-142-环形链表" class="headerlink" title="LeetCode 142 环形链表"></a>LeetCode 142 环形链表</h2><p><strong>题目连接:</strong> <a href="">142.环形链表</a></p><h3 id="判断环"><a href="#判断环" class="headerlink" title="判断环"></a>判断环</h3><p>通过快慢指针法，分别fast指针和slow指针，从头结点开始触发，<strong>fast指针每次移动两个节点，slow指针每次移动一个节点</strong>，如果fast和slow指针在途中相遇，说明这个链表有环。<strong>有环的话为什么一定在环内相遇呢？</strong></p><p>这是因为，fast指针一定会先于slow指针先进入环，如果链表存在环，此时该问题就会变成高中物理的追击问题</p><h3 id="寻找环的入口"><a href="#寻找环的入口" class="headerlink" title="寻找环的入口"></a>寻找环的入口</h3><p><strong>如果有环，那么我们如何找到环的入口？</strong> 假设从头结点到环的入口的距离是x，入口到相遇点的距离是y，相遇点再到环形入口的距离是z</p><img src="https://img.imgdd.com/337c4450-40bf-40c1-9c77-bb01d092a737.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>相遇时，slow指针走过了<code>x+y</code>的距离，fast指针走过了<code>x+y+n(y+z)</code>的距离，n表示fast指针在环内走了n圈才和slow指针相遇。我们通过<code>t=x/v</code>将两者联系起来，即<code>(x+y)/1=[x+y+n(y+z)]/2</code>,花间可得<code>x=(n-1)(y+z)+z</code></p><img src="https://img.imgdd.com/eba2a7f3-b264-4106-8459-7f41f0938820.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>注意最后的式子n一定大于等于1，因为fast指针<strong>至少</strong>要多走一圈才能追上并和slow相遇。当<code>n=1</code>时，<code>x=z</code>表明fast指针在环里走了一圈之后就和slow指针相遇。这就意味着，<strong>从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点，那么当这两个指针相遇的时候就是环形入口的节点。</strong></p><p>**如果n大于1会是什么情况？**我们假设令<code>n=3</code>，代入式子可得<code>x=2(y+z)+z</code>。可以发现<code>2(y+z)</code>就表示两圈圆，所以可得出结论，fast指针在环里走了两圈之后和slow指针在入口相遇。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="comment">//保证链表是个环</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="comment">//快慢指针相遇，此时同时从相遇点开始同时进行移动</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                ListNode* index1 = head;</span><br><span class="line">                ListNode* index2 = fast;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录算法训练营第三天| 203.移除链表元素、707.设计链表、206.反转链表</title>
      <link href="/posts/43916.html"/>
      <url>/posts/43916.html</url>
      
        <content type="html"><![CDATA[<h2 id="链表基础"><a href="#链表基础" class="headerlink" title="链表基础"></a>链表基础</h2><p>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向nullptr，链表的入口节点称为链表的头结点（head）</p><img src="https://img.imgdd.com/7242fb8d-3d84-424f-bf77-c7228f6cf73b.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><!-- ![day3-1](https://img.imgdd.com/7242fb8d-3d84-424f-bf77-c7228f6cf73b.jpg) --><h2 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a>链表的类型</h2><ol><li>单链表（Singly Linked List）：每个节点只包含一个指针，指向下一个节点。</li><li>双链表（Doubly Linked List）：每个节点包含两个指针，一个指向前一个节点，另一个指向下一个节点。</li><li>循环链表（Circular Linked List）：链表的最后一个节点的指针域指向第一个节点，形成一个环。</li></ol><img src="https://img.imgdd.com/7687a501-6da3-4b2a-a2f5-22322da64105.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;"/><!-- ![day3-2](https://img.imgdd.com/7687a501-6da3-4b2a-a2f5-22322da64105.jpg) --><h2 id="LeetCode-203-移除链表元素"><a href="#LeetCode-203-移除链表元素" class="headerlink" title="LeetCode 203 移除链表元素"></a>LeetCode 203 移除链表元素</h2><h3 id="虚拟头结点"><a href="#虚拟头结点" class="headerlink" title="虚拟头结点"></a>虚拟头结点</h3><p>虚拟头结点是一个在链表头部添加的额外节点，它不存储任何数据，只起到辅助作用。虚拟头结点的引入可以使得链表的操作得到统一。</p><ul><li>无论是在链表的开头、中间还是末尾插入或删除节点，我们都可以使用相同的逻辑进行操作</li><li>虚拟头节点还能够解决空链表的情况。如果链表为空且没有虚拟头节点，我们需要对空链表和非空链表进行不同的处理。然而，通过添加虚拟头节点，链表的头部始终存在，我们可以统一对链表进行处理，无论链表是否为空。</li></ul><p>可能大家光是看文字可能没有什么感觉，但是到了做题的时候，你就会发现虚拟头节点会给你带来很多便利</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* p = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* q = p-&gt;next;</span><br><span class="line">                p-&gt;next = q-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-707-设计链表"><a href="#LeetCode-707-设计链表" class="headerlink" title="LeetCode 707 设计链表"></a>LeetCode 707 设计链表</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/design-linked-list">707.设计链表</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line">MyLinkedList* obj = <span class="keyword">new</span> <span class="built_in">MyLinkedList</span>();</span><br><span class="line"><span class="type">int</span> param_1 = obj-&gt;<span class="built_in">get</span>(index);</span><br><span class="line">obj-&gt;<span class="built_in">addAtHead</span>(val);</span><br><span class="line">obj-&gt;<span class="built_in">addAtTail</span>(val);</span><br><span class="line">obj-&gt;<span class="built_in">addAtIndex</span>(index,val);</span><br><span class="line">obj-&gt;<span class="built_in">deleteAtIndex</span>(index);</span><br></pre></td></tr></table></figure><ul><li>第一句代码通过new创建了一个MyLinkedList类型的对象obj，然后对obj执行增删改查操作。因此，在MyLinkedList的方法中，必然会创建一个新的链表。</li><li>我们还需要一个变量记录链表内的元素个数。因为在我们进行增、删、改、查之前要对输入的下标的合法性进行检查，所以有必要记录链表内的元素个数</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkNode* next;</span><br><span class="line">        <span class="built_in">LinkNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">LinkNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkNode</span>();</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断下标是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* curNode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        curNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next  = curNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* curNode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        LinkNode* p = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = curNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* curNode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = curNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        _size--;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkNode* _dummyHead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-206-反转链表"><a href="#LeetCode-206-反转链表" class="headerlink" title="LeetCode 206 反转链表"></a>LeetCode 206 反转链表</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/design-linked-list">206.反转链表</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们一下就能想到，如果我们再开辟一块内存空间，然后重新遍历一遍链表不就能实现链表元素的反转吗？但是这大大浪费了内存空间，也违背了我们刷题学习算法的初衷。</p><p>其实，我们直接把链表指针进行反转，就能实现反转链表，那么如何进行反转呢？</p><p>首先，我们定义一个p指针指向头节点，然后定义一个q指针，初始化为nullptr。我们只需要令p-&gt;next&#x3D;q，q&#x3D;p就能实现翻转操作，那么此时如何令p指针向前走呢？</p><p>这是，我们就需要提前定义一个temp指针保存p指针的下一个节点，这样，p指针就能找到它的下一个节点了。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//标记p的下一个节点</span></span><br><span class="line">            ListNode* temp = p-&gt;next;       </span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            q = p;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head = q;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录算法训练营第二天|209.长度最小的子数组、59.螺旋矩阵II</title>
      <link href="/posts/29031.html"/>
      <url>/posts/29031.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-209-长度最小的子数组"><a href="#LeetCode-209-长度最小的子数组" class="headerlink" title="LeetCode 209 长度最小的子数组"></a>LeetCode 209 长度最小的子数组</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/minimum-size-subarray-sum">209.长度最小的子数组</a></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>定义left和right两个指针，两指针同向移动且不会回头，指针需要通过判断区间[left,right]是否合法来决定指针的走向，收缩的本质即去掉不再需要的元素（也就是先固定右指针，判断条件是否可以收缩左指针范围）。因为在指针移动过程中，区间[left,right]很像一个滑动的窗口，故称为滑动窗口算法。滑动窗口的典型应用场景就是找数组中的子数组或字符串中的字串是否符合某一条件</p><p><strong>如果加入滑动窗口中有负数怎么办？</strong></p><p>如果滑动窗口中有负数，就无法直接使用滑动窗口算法，因为此时收缩窗口不一定使区间和减小，扩张窗口也不一定使区间和增大，导致窗口的调整变得不可控。若要覆盖所有情况，只能让左指针left逐个回退到right，这就退化成暴力搜索了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题中要想实现滑动窗口，我们就要明确如下三点：</p><ul><li>窗口内表示的是什么？</li><li>如何移动窗口起始位置</li><li>如何移动窗口终止位置</li></ul><p>对于第一点，我们可以从题目中明确知道区间内表示的是元素的总和；对于第二点，如果当前区间内的总和小于target，left指针固定，right指针一直向前移动；对于第三点，如果当前区间内的总和大于target，right指针固定，left指针向前移动。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>, sum = <span class="number">0</span>, subLen = <span class="number">0</span>, result = INT32_MAX;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sum += nums[right]; </span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                subLen = right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(subLen &lt; result) &#123;</span><br><span class="line">                    result = subLen;</span><br><span class="line">                &#125;</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result &lt; subLen ? result : subLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-59-螺旋数组II"><a href="#LeetCode-59-螺旋数组II" class="headerlink" title="LeetCode 59 螺旋数组II"></a>LeetCode 59 螺旋数组II</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/spiral-matrix-ii">59.螺旋数组II</a></p><p><strong>思路</strong></p><p>本题并不涉及什么算法，主要考察的是<strong>模拟遍历的过程</strong>，编写代码时要统一边界条件，这要我们写代码时才不会混乱</p><ol><li>首先要明确一点，我们在Day1的文章说过，遍历数组时通常会采用<strong>左闭右闭</strong>或<strong>左闭右开</strong>的形式，这题当然也不例外，假设我们遍历每一条边均采用左闭右开的原则，确保边界条件统一</li></ol><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul> <img src="https://img.imgdd.com/7eb60706-f824-4bb5-967b-fd4e412bd3c9.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;"/><ol start="2"><li><p>其次，我们按照<strong>由外到内</strong>的遍历顺序，每次向内侧遍历时，循环的终止条件会逐渐减少。因此，我们需要设置一个offset变量，通过n-offset来确定终止条件。</p></li><li><p>最后是循环次数。从上面的图可以看出，当n&#x3D;3时，遍历1次；当n&#x3D;4时，遍历2次。因此，可以得出结论，遍历次数为n&#x2F;2。当n为奇数时，中心位置需要单独处理。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">ret</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> loop = n/<span class="number">2</span>;         <span class="comment">//控制循环次数</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;         <span class="comment">//n-offset 控制每条边遍历次数</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop--) &#123;</span><br><span class="line">            <span class="type">int</span> i = startx;</span><br><span class="line">            <span class="type">int</span> j = starty;</span><br><span class="line">            <span class="comment">//遍历上行</span></span><br><span class="line">            <span class="keyword">for</span>(;j &lt; n - offset;j++) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历右列</span></span><br><span class="line">            <span class="keyword">for</span>(;i &lt; n - offset;i++) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历下行</span></span><br><span class="line">            <span class="keyword">for</span>(;j &gt; startx;j--) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历左列</span></span><br><span class="line">            <span class="keyword">for</span>(;i &gt; starty;i--) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果n是奇数，中间位置单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            ret[startx][starty] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录算法训练营第一天| 704.二分查找、27.移除元素、977.有序数组的平方</title>
      <link href="/posts/24744.html"/>
      <url>/posts/24744.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-704-二分查找"><a href="#LeetCode-704-二分查找" class="headerlink" title="LeetCode 704 二分查找"></a>LeetCode 704 二分查找</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/binary-search">704.二分查找</a></p><p>二分查找的前提是<strong>数组为有序数组</strong>，同时强调<strong>数组中没有重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。这些都是二分法的前提条件。</p><p>二分法有两种定义方式：</p><ul><li><strong>左闭右闭 即 [left,right]</strong></li><li><strong>左闭右开 即 [left,right]</strong></li></ul><h3 id="二分查找第一种写法"><a href="#二分查找第一种写法" class="headerlink" title="二分查找第一种写法"></a>二分查找第一种写法</h3><ul><li>因为左闭右闭的特性，因此，当 left&#x3D;&#x3D;right 也是成立的，所以循环条件使用 left&lt;&#x3D;right</li><li>其次，当if (nums[middle] &gt; target) 时，right 要赋值为 middle-1，因为左闭右闭特性，right&#x3D;middle-1时，区间依旧合法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//左闭右闭区间，此处的right是nums.size()-1</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//注意此处是lef&lt;=right</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二分查找第二种写法"><a href="#二分查找第二种写法" class="headerlink" title="二分查找第二种写法"></a>二分查找第二种写法</h3><ul><li>因为左闭右开的特性，因此，当 left&#x3D;&#x3D;right 是没有意义的，所以循环条件使用 left&lt;right</li><li>其次，当if (nums[middle] &gt; target) 时，right 要赋值为 middle，因为左闭右开特性，right&#x3D;middle时，区间依旧合法；如果right&#x3D;middle-1，那么middle-1这个下标位置就被忽略。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//左闭右开区间</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-27-移动元素"><a href="#LeetCode-27-移动元素" class="headerlink" title="LeetCode 27 移动元素"></a>LeetCode 27 移动元素</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/remove-element">27.移动元素</a></p><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>快慢指针是指两个指针<strong>从同一侧开始遍历数组</strong>，将这两个指针分别定义为<strong>快指针（fast）和慢指针（slow）</strong>，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如快指针（fast）每次增长两个，慢指针（slow）每次增长一个。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过快指针判断当前值是否等于val来处理遍历逻辑。快指针(fast)、慢指针(slow)均从起点出发，slow标记我们应该放置非目标元素的位置，而fast则遍历整个数组来寻找非目标元素</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt;= nums.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val &amp;&amp; fast == slow) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[fast] == val) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-977-有序数组的平方"><a href="#LeetCode-977-有序数组的平方" class="headerlink" title="LeetCode 977 有序数组的平方"></a>LeetCode 977 有序数组的平方</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array">977.移动数组的平方</a></p><h3 id="首尾指针"><a href="#首尾指针" class="headerlink" title="首尾指针"></a>首尾指针</h3><p>头指针（head）和尾指针（tail）分别从数组首部和尾部向中间进行遍历，快速排序和前面的二分查找都是首位指针的具体应用场景</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>因为数组的非递减顺序特性，这是很重要的一点，正是有了这个特性，我们才能通过首尾指针从数组两端向中间遍历，然后每次比较两端元素的平方，选择较大的平方值填入结果数组的末尾</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">result</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, index = result.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pow</span>(nums[left],<span class="number">2</span>) &lt; <span class="built_in">pow</span>(nums[right],<span class="number">2</span>)) &#123;</span><br><span class="line">                result[index] = <span class="built_in">pow</span>(nums[right],<span class="number">2</span>);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[index] = <span class="built_in">pow</span>(nums[left],<span class="number">2</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
