<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>列表初始化</title>
      <link href="/posts/43211.html"/>
      <url>/posts/43211.html</url>
      
        <content type="html"><![CDATA[<h1 id="同一初始化"><a href="#同一初始化" class="headerlink" title="同一初始化"></a>同一初始化</h1><p>在C++98&#x2F;03中初始化数据方式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象初始化</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> id;</span><br><span class="line"><span class="type">double</span> salary;</span><br><span class="line">&#125;huang&#123; <span class="number">1</span>,<span class="number">3000</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组初始化</span></span><br><span class="line"><span class="type">int</span> array[] = &#123; <span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span> &#125;;</span><br></pre></td></tr></table></figure><p>而在C++11中，列表初始化的方式变得更灵活了，下面来看代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> num) : <span class="built_in">m_num</span>(num) &#123;&#125;</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> num, string name) : <span class="built_in">m_num</span>(num), <span class="built_in">m_name</span>(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line">string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//使用初始化列表初始化对象</span></span><br><span class="line"><span class="function">Person <span class="title">t1</span><span class="params">(<span class="number">500</span>)</span></span>;</span><br><span class="line">Person t2 = <span class="number">520</span>;</span><br><span class="line">Person t3 = &#123; <span class="number">520</span> &#125;;</span><br><span class="line">Person t4&#123; <span class="number">520</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用初始化列表初始化数组</span></span><br><span class="line">    <span class="type">int</span> a1 = &#123; <span class="number">1314</span> &#125;;</span><br><span class="line"><span class="type">int</span> a2&#123; <span class="number">1314</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr1[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">int</span> arr2[]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面解释一下上面代码的各种初始化方式：</p><ul><li><code>t1</code>: 最中规中距的初始化方式，也是最常用的方式，通过有参构造进行对象的初始化</li><li><code>t2</code>: 因为提供的拷贝构造函数是公共的，因此会发生隐式类型转换。编译器会先看Person类有没有带整形的构造函数，如果提供了，那么编译器在执行期间会自动地将520构造成Person对象，再把这个Person对象赋值成t2</li><li><code>t3</code>和<code>t4</code>: 使用了C++11的初始化方式来初始化对象，效果和t1的方式是相同的。</li></ul><p>既然使用列表初始化可以对普通类型以及对象进行直接初始化，那么在使用 new 操作符创建新对象的时候可以使用列表初始化进行对象的初始化吗？答案是肯定的，来看下面的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>&#123; <span class="number">520</span> &#125;;</span><br><span class="line"><span class="type">int</span>* array = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span>&#123; <span class="number">52.1314</span> &#125;;</span><br></pre></td></tr></table></figure><ul><li><code>指针p</code>: 指向一个new操作符返回的内存，通过列表初始化将内存数据初始化为520</li><li><code>数组array</code>: 在堆上动态分配了一块内存，通过列表初始化的方式直接完成了多个元素的初始化。</li><li><code>变量b</code>: 对匿名对象使用列表初始之后，再进行拷贝初始化。</li></ul><p><code>上述这么多初始化方式并不需要每个都记住，我们只需要记住那些最常用的方式即可，那什么是最常用的呢？那就要靠自己多看代码了</code></p><h1 id="列表初始化细节"><a href="#列表初始化细节" class="headerlink" title="列表初始化细节"></a>列表初始化细节</h1><h2 id="聚合体"><a href="#聚合体" class="headerlink" title="聚合体"></a>聚合体</h2><p>什么是聚合体？聚合体要满足以下五个条件：</p><ul><li>无用户定义的构造函数</li><li>无私有或保护的非静态数据成员</li><li>无基类</li><li>无虚函数</li><li>类中不能有使用{}和&#x3D;直接初始化的非静态数据成员（c++14以后支持）</li></ul><p>在C++11中，列表初始化的范围被大大增强了，但有一些模糊的概念也随之而来，在前面的例子可以得知，列表初始化可以用于自定义类型的初始化，但是对于一个自定义类型，列表初始化可能有两种执行结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;a = &#123; <span class="number">123</span>, <span class="number">321</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line"><span class="built_in">T2</span>(<span class="type">int</span>,<span class="type">int</span>) : <span class="built_in">x</span>(<span class="number">10</span>), <span class="built_in">y</span>(<span class="number">20</span>) &#123;&#125;</span><br><span class="line">&#125;b = &#123; <span class="number">123</span>,<span class="number">321</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a.x: &quot;</span> &lt;&lt; a.x &lt;&lt; <span class="string">&quot;, a.y: &quot;</span> &lt;&lt; a.y &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b.x: &quot;</span> &lt;&lt; b.x &lt;&lt; <span class="string">&quot;, b.y: &quot;</span> &lt;&lt; b.y &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序执行结果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.x: <span class="number">123</span>, a.y: <span class="number">321</span></span><br><span class="line">b.x: <span class="number">10</span>, b.y: <span class="number">20</span></span><br></pre></td></tr></table></figure><p>上述的两个程序都是用列表初始化的方式对对象进行了初始化，但是得到结果却不同，对象b并没有被初始化列表中的数据初始化，这是为什么呢？这是因为：</p><ul><li><code>对象a是对一个自定义的聚合类型进行初始化，它将以拷贝的形式使用初始化列表中的数据来初始化T1结构体中的域成员</code></li><li><code>结构体T2自定义了一个构造函数，因此实际的初始化是通过这个构造函数完成的。</code></li></ul><p>现在是不是有些混乱了，同样都是自定义类型并且都是在创建对象的时候都使用了列表初始化来初始化对象，为什么在类内部对对象的初始化方式却不一样呢？<code>这是因为，如果使用列表初始化对对象初始化时，还需要判断这个对象对应的类型是不是一个聚合体，如果是聚合类，那么初始化列表中的数据就会拷贝到对象中；反之，如果不是聚合类，那么就不能通过初始化列表进行初始化</code></p><p>那么，使用列表初始化时，对于什么样的类型C++会认为它是一个聚合体呢？</p><ul><li>普通数组本身可以看做是一个聚合类型</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">double</span> y[<span class="number">3</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1.23</span>, <span class="number">2.34</span>, <span class="number">3.45</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4.56</span>, <span class="number">5.67</span>, <span class="number">6.78</span>&#125;,</span><br><span class="line">    &#123;<span class="number">7.89</span>, <span class="number">8.91</span>, <span class="number">9.99</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> carry[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">std::string sarry[] = &#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;nihao&quot;</span>, <span class="string">&quot;shijie&quot;</span>&#125;;</span><br></pre></td></tr></table></figure><p>我们通过这个例子可以得出一个结论：<code>如果初始化列表初始化的变量是一个聚合体类型，那么就可以直接把&#123;&#125;写在变量后面，例如上述代码可写成 int x[]&#123;1,2,3&#125;；如果是非聚合类型，那么就要给它提供构造函数进行初始化</code></p><ul><li><p>满足聚合体四个定义的类（class、struct、union）可以被看做是一个聚合类型。</p><ul><li><p>无用户定义的构造函数</p></li><li><p>无私有或保护的非静态数据成员</p><p><code>场景1：类中有私有成员，无法使用列表初始化进行初始化</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> z;</span><br><span class="line">&#125;a &#123; <span class="number">123</span>, <span class="number">321</span>, <span class="number">2</span> &#125;;<span class="comment">//报错，类中有私有成员, 无法使用初始化列表初始化</span></span><br></pre></td></tr></table></figure><p><code>场景2：类中的非静态成员可以通过列表初始化进行初始化，但它不能初始化静态数据成员</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line">&#125;a &#123; <span class="number">123</span>, <span class="number">321</span>, <span class="number">2</span> &#125;;<span class="comment">//报错，报错信息：初始值设定项太多</span></span><br></pre></td></tr></table></figure><p><code>结构体中的静态变量 z 不能使用列表初始化进行初始化，它的初始化遵循静态成员的初始化方式（可使用全局初始化）</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> z;</span><br><span class="line">&#125;a &#123; <span class="number">123</span>, <span class="number">321</span> &#125;;    <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T1::z = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>无基类</p></li><li><p>无虚函数（virtual）</p></li><li><p>类中不能有使用<code>&#123;&#125;</code>和<code>=</code>直接初始化的非静态数据成员（c++14以后支持）。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T3</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">3.14</span>;</span><br><span class="line">    <span class="type">int</span> z[<span class="number">3</span>]&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">T3 <span class="title">t</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, &#123; <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125;)</span></span>;<span class="comment">//报错，C++11不支持，C++14支持</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="非聚合体"><a href="#非聚合体" class="headerlink" title="非聚合体"></a>非聚合体</h2><p>对于聚合类型的类可以直接使用列表初始化进行对象的初始化，如果不满足聚合条件还想使用列表初始化其实也是可以的，<code>需要在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化:</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//注意在构造函数中使用初始化列表</span></span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> num,string name) : <span class="built_in">m_num</span>(num), <span class="built_in">m_name</span>(name) &#123;&#125;   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line">string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Person p&#123; <span class="number">9527</span>,<span class="string">&quot;huang&quot;</span> &#125;;<span class="comment">// ok</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，需要额外注意的是<code>聚合类型的定义并非递归的</code>，也就是说<code>当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型</code>，比如下面的这个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T1</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">double</span> y;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T2</span> &#123;</span><br><span class="line">T1 t1;</span><br><span class="line"><span class="type">long</span> x1;</span><br><span class="line"><span class="type">double</span> y1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">T2 t2&#123; &#123;&#125;,<span class="number">520</span>,<span class="number">3.14</span> &#125;;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，T1并发一个聚合类型，因为它有private修饰的非静态成员变量。尽管T2有一个非聚合类型的非静态成员t1，T2依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化。</p><p>最后强调一下t2对象的初始化过程，对于非聚合类型的成员t1做初始化的时候，可以直接写一对空的大括号{}，这相当于调用是T1的无参构造函数。</p><h1 id="std-initializer-list"><a href="#std-initializer-list" class="headerlink" title="std::initializer_list"></a>std::initializer_list</h1><p>如果想要像STL一样有任意长度初始化的能力，可以使用<code>std::initializer_list</code>这个轻量级的类模板来实现。</p><p>先来介绍一下这个类模板的一些特点：</p><ul><li>它是一个轻量级的容器类型，内部定义了迭代器<code>iterator</code>等容器必须的概念，<code>遍历时得到的迭代器是只读的</code></li><li>对于<code>std::initializer_list&lt;T&gt;</code>而言，它可以接收任意长度的初始化列表，但是<code>要求元素必须是同种类型T</code></li><li>在<code>std::initializer_list</code>内部有三个成员接口：<code>size(), begin(), end()</code></li><li><code>std::initializer_list</code>对象只能被整体初始化或者赋值。</li></ul><h2 id="作为普通函数参数"><a href="#作为普通函数参数" class="headerlink" title="作为普通函数参数"></a>作为普通函数参数</h2><p>如果想要自定义一个函数并且接收任意个数的参数（可变参数），只需要将函数参数指定为<code>std::initializer_list</code>，使用初始化列表<code>&#123; &#125;</code>作为实参进行数据传递即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(initializer_list&lt;<span class="type">int</span>&gt;list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> it = list.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; it != list.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *(it) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>(&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">523</span>,<span class="number">7</span> &#125;);    <span class="comment">//输出：1 2 3 8 523 7</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::initializer_list的效率是非常高的，它的内部并不负责保存初始化列表中元素的拷贝，仅仅存储了初始化列表中元素的引用。</code></p><h2 id="作为构造函数参数"><a href="#作为构造函数参数" class="headerlink" title="作为构造函数参数"></a>作为构造函数参数</h2><p>自定义的类如果在构造对象的时候想要接收任意个数的实参，可以给构造函数指定为<code>std::initializer_list</code>类型，在自定义类的内部还是使用容器来存储接收的多个实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>(initializer_list&lt;string&gt;list) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; *(it) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">m_name.<span class="built_in">push_back</span>(*(it));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;string&gt;m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(&#123; <span class="string">&quot;jack&quot;</span>, <span class="string">&quot;lucy&quot;</span>, <span class="string">&quot;tom&quot;</span> &#125;)</span></span>;  <span class="comment">//输出：jack lucy tom</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树part01</title>
      <link href="/posts/17441.html"/>
      <url>/posts/17441.html</url>
      
        <content type="html"><![CDATA[<p><strong>注：因篇幅有限，因此本篇文章不会对二叉树的种类、存储方式展开说明</strong></p><h2 id="二叉树的遍历方式"><a href="#二叉树的遍历方式" class="headerlink" title="二叉树的遍历方式"></a>二叉树的遍历方式</h2><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。</li><li>广度优先遍历：一层一层的遍历</li></ol><p>那么从深度优先遍历和广度优先遍历进一步拓展，才有如下遍历方式：</p><ul><li>深度优先遍历<ul><li>前序遍历（递归法，迭代法）</li><li>中序遍历（递归法，迭代法）</li><li>后序遍历（递归法，迭代法）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代法）</li></ul></li></ul><p>以下是分别是前、中、后序遍历的方式：</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><p>大家可以对着下面的图理解：</p><img src="https://img.imgdd.com/168ebe15-2e9b-4a50-8119-6897f45707a7.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。之前我们讲栈与队列的时候，就说过<strong>栈其实就是递归的一种实现结构</strong>，也就说<strong>前中后序遍历的逻辑其实都是可以借助栈使用递归的方式来实现的</strong>。而<strong>广度优先遍历的实现一般使用队列来实现</strong>，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。</p><h2 id="二叉树的定义方式"><a href="#二叉树的定义方式" class="headerlink" title="二叉树的定义方式"></a>二叉树的定义方式</h2><p>二叉树有两种存储方式顺序存储和链式存储，顺序存储就是用数组来存，我们大多数情况下都是采用链式存储，这里给出链式存储的二叉树节点的定义方式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树的递归遍历"><a href="#二叉树的递归遍历" class="headerlink" title="二叉树的递归遍历"></a>二叉树的递归遍历</h2><p><strong>题目链接：</strong></p><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal">144.二叉树的前序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal">145.二叉树的后序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal">94.二叉树的中序遍历</a></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>很多同学可能会有“一入递归深似海，从此回不来”的情况，这主要是对递归不成体系，没有方法论，每次写递归算法，都是靠玄学来写代码，代码能不能编过都靠运气。</p><p>这里会帮助大家确定递归算法的三个要素。<strong>每次写递归，就按照这三个要素来写</strong></p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数，并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件</strong></li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><p>接下来以前序遍历举个例子：</p><ol><li><strong>确定递归函数的参数和返回值。</strong> 因为要打印出当前遍历到的节点值，因此需要传入<code>vector</code>来存放节点值，此外，为了获取节点值还要将指向节点的指针<code>TreeNode* cur</code>传入，除此之外就不需要再处理什么数据了也不需要有返回值，所以递归函数返回类型就是void，代码如下：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>确定终止条件。</strong> 当前遍历的节点为空，那么本层递归就要结束了，直接return</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>确定单层递归的逻。</strong> 前序遍历是中左右的顺序，所以在单层递归的逻辑，先取中节点的数值，再分别遍历左右孩子（左右子树）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(cur-&gt;val);        <span class="comment">// 中</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;left, vec);      <span class="comment">// 左</span></span><br><span class="line"><span class="built_in">traversal</span>(cur-&gt;right, vec);     <span class="comment">// 右</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();              <span class="comment">//中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">//右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">//左（空节点不如栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,vec);           <span class="comment">//左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,vec);          <span class="comment">//右</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);            <span class="comment">//中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="built_in">traversal</span>(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,vec);           <span class="comment">//左</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);            <span class="comment">//中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,vec);          <span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="built_in">traversal</span>(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="二叉树的迭代遍历"><a href="#二叉树的迭代遍历" class="headerlink" title="二叉树的迭代遍历"></a>二叉树的迭代遍历</h2><p>大家可以使用迭代法，再重新解决上一小节三道leetcode上的题目</p><ul><li><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal">144.二叉树的前序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal">145.二叉树的后序遍历</a></li><li><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal">94.二叉树的中序遍历</a></li></ul><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p><strong>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。此时大家应该知道我们用栈也可以是实现二叉树的前后中序遍历了。</p><h4 id="前序遍历（迭代法）"><a href="#前序遍历（迭代法）" class="headerlink" title="前序遍历（迭代法）"></a>前序遍历（迭代法）</h4><p>前序遍历是中左右，每次先处理的是中间节点，那么<strong>先将根节点放入栈中，然后将右孩子加入栈，再加入左孩子。</strong></p><p><strong>为什么要先加入右孩子，再加入左孩子呢？</strong> 因为这样出栈的时候才是中左右的顺序。</p><img src="https://img.imgdd.com/368b3bae-62ff-4d89-a4a5-fc7e8bfbe3b7.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>可写出如下代码（注意空节点不入栈）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();              <span class="comment">//中</span></span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);   <span class="comment">//右（空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);     <span class="comment">//左（空节点不如栈）</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后序遍历（迭代法）"><a href="#后序遍历（迭代法）" class="headerlink" title="后序遍历（迭代法）"></a>后序遍历（迭代法）</h4><p>再来看后序遍历，前序遍历是中左右，后序遍历是左右中，那么我们只需要调整一下前序遍历的代码顺序，就变成中右左的遍历顺序，然后在反转result数组，输出的结果顺序就是左右中了，如下图：</p><img src="https://img.imgdd.com/3020a86a-bf69-4cc4-9466-0a3870597f28.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>可写出如下代码（注意空节点不入栈）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="comment">//相对于前序遍历，这更改一下入栈顺序 （空节点不入栈）</span></span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());    <span class="comment">//将结果反转之后就是左右中的顺序了</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中序遍历（迭代法）"><a href="#中序遍历（迭代法）" class="headerlink" title="中序遍历（迭代法）"></a>中序遍历（迭代法）</h4><p>既然后序遍历可以在前序遍历的基础上调换代码的执行顺序实现，那么中序遍历是不是也可以呢？答案是不行</p><p>分析一下为什么刚刚写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，<strong>因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。</strong></p><p>那么再看看中序遍历，中序遍历是左中右，先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进result数组中），这就造成了<strong>处理顺序和访问顺序是不一致的。</strong></p><p>那么在使用迭代法写中序遍历，就需要借用指针的遍历来帮助访问节点，栈则用来处理节点上的元素。此处先给出代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt;st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">//一路向左找到最底层节点</span></span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);           <span class="comment">//将访问的节点入栈</span></span><br><span class="line">                cur = cur-&gt;left;       </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();         <span class="comment">//这个时候栈顶的数据就是要处理的数据</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后给出模拟过程：</p><img src="https://img.imgdd.com/bf2663b4-f915-443c-9159-5ee3e663284a.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><h2 id="二叉树的层序遍历（迭代法）"><a href="#二叉树的层序遍历（迭代法）" class="headerlink" title="二叉树的层序遍历（迭代法）"></a>二叉树的层序遍历（迭代法）</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。这种遍历的方式和我们之前讲过的都不太一样。<strong>需要借用一个辅助数据结构即队列来实现</strong>，队列先进先出，符合一层一层遍历的逻辑，而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。</p><p>这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。模拟如下：</p><img src="https://img.imgdd.com/d4630294-0cd4-4094-9da0-a26d9146741e.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>最后的结果是以二维数组的形式保存，那我们怎么控制每一行的结束呢？相信大家从上图的模拟也能知道，我们可以在处理每一层节点之前设置一个固定的<code>size</code>，当<code>size=0</code>是就表明当前已经处理完一行数据</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt;que;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">//这里一定要使用固定大小的size，不要使用que.size()</span></span><br><span class="line">            <span class="comment">//因为会不断加入节点的左右孩子导致队列大小不断变化</span></span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt;vec;         <span class="comment">//保存每一层的值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="comment">//加入左右节点</span></span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;      </span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列part01</title>
      <link href="/posts/34563.html"/>
      <url>/posts/34563.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-232-用栈实现队列"><a href="#LeetCode-232-用栈实现队列" class="headerlink" title="LeetCode 232 用栈实现队列"></a>LeetCode 232 用栈实现队列</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/implement-queue-using-stacks">232.用栈实现队列</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这是一道模拟题，不涉及到具体算法，考察的就是对栈和队列的掌握程度。</p><p>使用栈来模拟队列的行为，如果仅仅用一个栈，是一定不行的，所以需要两个栈<strong>一个输入栈，一个输出栈</strong>。</p><p>在push数据的时候，只要数据放进输入栈就好，但<strong>在pop的时候，操作就复杂一些，输出栈如果为空，就把输入栈内的数据全部导入进来，再从输出栈弹出数据，如果输出栈不为空，则直接从输出栈弹出数据就可以了。</strong></p><p>**那么如何判断队列为空呢？**如果进栈和出栈都为空的话，说明模拟的队列为空了。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(out.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!in.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">int</span> temp = in.<span class="built_in">top</span>();</span><br><span class="line">                in.<span class="built_in">pop</span>();</span><br><span class="line">                out.<span class="built_in">push</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> number = out.<span class="built_in">top</span>();</span><br><span class="line">        out.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        out.<span class="built_in">push</span>(number);</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.<span class="built_in">empty</span>() &amp;&amp; out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;in;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;out;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-225-用队列实现栈"><a href="#LeetCode-225-用队列实现栈" class="headerlink" title="LeetCode 225 用队列实现栈"></a>LeetCode 225 用队列实现栈</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/implement-stack-using-queues">225.用队列实现栈</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>大家可能会像上一题一样，定义一个输入队列，一个输出队列就可以模拟栈的功能，仔细想一下还真不行！</p><p>**队列是先进先出的规则，把一个队列中的数据导入另一个队列中，数据的顺序并没有变，并没有变成先进后出的顺序。**所以用栈实现队列， 和用队列实现栈的思路还是不一样的，这取决于这两个数据结构的性质。但是，我们依然还是要用两个队列来模拟栈，只不过没有输入和输出的关系，另一个队列完全用来备份的！</p><p>队列中最后进入的元素一定要最先出来，这样才能符合栈的<strong>后进先出</strong>特性。此时，<strong>问题就转化为如何取出队列的队尾元素？<strong>为了实现这一点，我们需要</strong>使用另一个队列来备份前n-1个元素，而队尾的元素（第n个元素）就是要出队的元素</strong>。将队尾元素出队后，再将备份队列中的元素重新导入到原队列中。为了控制队列中的元素个数，我们还需要定义一个size变量来记录队列中的元素数量。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;in;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;in_tem;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        in.<span class="built_in">push</span>(x);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(size != <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> number = in.<span class="built_in">front</span>();</span><br><span class="line">            in.<span class="built_in">pop</span>();</span><br><span class="line">            in_tem.<span class="built_in">push</span>(number);</span><br><span class="line">            size--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> temp = in.<span class="built_in">front</span>();</span><br><span class="line">        in.<span class="built_in">pop</span>();</span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!in_tem.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> number = in_tem.<span class="built_in">front</span>();</span><br><span class="line">            in_tem.<span class="built_in">pop</span>();</span><br><span class="line">            in.<span class="built_in">push</span>(number);</span><br><span class="line">            size++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> number = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        in.<span class="built_in">push</span>(number);</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-20-有效的括号"><a href="#LeetCode-20-有效的括号" class="headerlink" title="LeetCode 20 有效的括号"></a>LeetCode 20 有效的括号</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/valid-parentheses">20.有效的括号</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>很经典的栈的应用题，大家不管是学习数据结构与算法或者是考研备考过程中或多或少都会接触到这类经典问题</p><p>由于栈结构的特殊性，它非常适合用于解决对称匹配类的题目。首先，我们需要弄清楚在字符串中括号不匹配的几种情况。</p><ul><li>匹配不正确，即左右括号不匹配的情况，例如：<code>s=&quot;(]&quot;</code></li><li>左括号多，右括号少。表现在：当字符串s遍历完之后，栈不为空。例如：<code>s=&quot;((()&quot;</code></li><li>左括号少，右括号多。表现在：此时栈为空，但是字符串s正遍历的是右括号。例如：<code>s=&quot;()))))&quot;</code></li><li>正确匹配，即字符串遍历完成，栈此时也为空，例如：<code>s=&quot;()[]&#123;&#125;&quot;</code></li></ul><p>还有一些技巧，<strong>在匹配左括号的时候，右括号先入栈</strong>，这样只需要比较当前元素和栈顶相不相等就可以了，比左括号先入栈代码实现要简单的多了！</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;st;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="comment">//第一种情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!st.<span class="built_in">empty</span>() &amp;&amp; st.<span class="built_in">top</span>() != ch) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//第三种情况</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//第四种情况，即匹配的情况</span></span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二种情况</span></span><br><span class="line">        <span class="keyword">if</span>(!st.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-1047-删除字符串中的所有相邻重复项"><a href="#LeetCode-1047-删除字符串中的所有相邻重复项" class="headerlink" title="LeetCode 1047 删除字符串中的所有相邻重复项"></a>LeetCode 1047 删除字符串中的所有相邻重复项</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string">1047.删除字符串中的所有相邻重复项</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>本题目和<code>20.有效的括号</code>题目思路类似，都是使用栈来解决的经典题目。不同的是，本题要匹配相邻元素，而非左右括号。</p><p>我们在删除相邻重复项的时候，其实就是要知道当前遍历的这个元素，与前一位是不是遍历过一样数值的元素，那么如何记录前面遍历过的元素呢？当然是使用栈来存放，栈的目的，就是存放遍历过的元素，当遍历当前的这个元素的时候，去栈里看一下我们是不是遍历过相同数值的相邻元素，然后再去做对应的消除操作。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string result;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.<span class="built_in">empty</span>() &amp;&amp; ch == st.<span class="built_in">top</span>()) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> ch = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result += ch;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈与队列part02</title>
      <link href="/posts/40546.html"/>
      <url>/posts/40546.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-150-逆波兰表达式求值"><a href="#LeetCode-150-逆波兰表达式求值" class="headerlink" title="LeetCode 150 逆波兰表达式求值"></a>LeetCode 150 逆波兰表达式求值</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation">150.逆波兰表达式求值</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>逆波兰表达式就是一种后缀表达式，所谓后缀就是指运算符写在操作数的后面</p><p>我们平常使用的算数式是一种中缀表达式，如<code>(1+2)*(3/4)</code>，该式的逆波兰表达式写成<code>12+34/*</code>。中后缀表达式的转换方法此处不做过多介绍，可以参考<a href="https://www.bilibili.com/video/BV1b7411N798/?p=29&share_source=copy_web&vd_source=0db260a29b428cc91330eced2669ad8a">王道计算机考研 数据结构</a></p><p>后缀表达式的计算：</p><ol><li>从左往右扫描下一个元素，知道处理完所有元素</li><li>若扫描到操作数则压入栈，并返回1；否则执行3</li><li>若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到1</li></ol><p><strong>注意，第三步中先出栈的式“右操作数”</strong> 动画演示还是参考上述视频</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">long</span> <span class="type">long</span>&gt;st;</span><br><span class="line">        <span class="keyword">for</span>(string s : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s == <span class="string">&quot;+&quot;</span> || s == <span class="string">&quot;-&quot;</span> || s == <span class="string">&quot;*&quot;</span> || s == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num1 = st.<span class="built_in">top</span>();      <span class="comment">//右操作数</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> num2 = st.<span class="built_in">top</span>();      <span class="comment">//左操作数</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(s == <span class="string">&quot;+&quot;</span>) &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(num2 + num1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;-&quot;</span>) &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(num2 - num1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s == <span class="string">&quot;*&quot;</span>) &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(num2 * num1);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    st.<span class="built_in">push</span>(num2 / num1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoll</span>(s));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-347-前K个高频元素"><a href="#LeetCode-347-前K个高频元素" class="headerlink" title="LeetCode 347 前K个高频元素"></a>LeetCode 347 前K个高频元素</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/top-k-frequent-elements">347.前K个高频元素</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>两种思路，第一种是使用<strong>哈希表</strong>实现，第二种是使用<strong>优先队列</strong></p><h4 id="思路一：哈希表"><a href="#思路一：哈希表" class="headerlink" title="思路一：哈希表"></a>思路一：哈希表</h4><p>这道题目主要涉及到如下三块内容：</p><ol><li>要统计元素出现频率</li><li>对频率排序</li><li>找出前K个高频元素</li></ol><p>我们之前已经学习过哈希表了，相信大家在看到这个题目的时候最先想到一定是哈希表（unordered_map），pair中的第一个位置记录数组元素，第二个位置记录该数组元素出现的频率，然后根据频率大小进行排序。但是，**我们怎么对map里的元素进行排序呢？**有人想到sort库函数，但是sort库函数不能对map里的元素进行排序。</p><p>我们可以这样操作：我们使用unordered_map记录每个数字出现的频率之后，遍历哈希表，找到出现次数最多的那个频率maxTime，然后开始收集高频元素</p><ul><li>从maxTime开始，逐步递减频率</li><li>每次遍历哈希表，收集所有频率等于当前频率maxTime的元素</li><li>直到收集到k个元素为止</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> it : map) &#123;</span><br><span class="line">        <span class="keyword">if</span>(it.second == maxTime) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(it.first);</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxTime--;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二：优先队列"><a href="#思路二：优先队列" class="headerlink" title="思路二：优先队列"></a>思路二：优先队列</h4><p>上述的哈希表方法是对整个数组进行排序，这样效率较低。那么，我们能否有一种方法只维护前K个有序序列就行了呢？当然可以，那就是优先队列！那么，什么是优先队列呢？要了解优先队列，我们首先需要理解堆的概念。</p><p><strong>堆是一颗完全二叉树，树中每个节点的值都不小于（或不大于）其左右孩子的值。<strong>如果父亲节点是大于等于左右孩子就是</strong>大根堆</strong>，小于等于左右孩子就是<strong>小根堆</strong>。大根堆就是指堆头是最大元素，小顶堆是指堆头是最小元素，除此之外，大家还需要了解构建堆的过程，因为篇幅有限，因此可以通过视频<a href="https://www.bilibili.com/video/BV1b7411N798/?p=96&share_source=copy_web&vd_source=0db260a29b428cc91330eced2669ad8a">王道计算机考研 数据结构</a>了解堆的构建过程。<strong>堆在算法在常用于处理Top-K问题，即前K个最大&#x2F;最小&#x2F;最频繁的元素</strong></p><p>优先级队列其实就是<strong>一个披着队列外衣的堆</strong>，因为优先级队列对外接口只是从队头取元素，从队尾添加元素，再无其他取元素的方式，看起来就是一个队列。而且优先级队列内部元素是自动依照元素的权值排列。那么它是如何有序排列的呢？缺省情况下priority_queue利用大根堆完成对元素的排序，这个大根堆是以vector为表现形式的完全二叉树。</p><p>此时要思考一下，是使用小根堆呢，还是大根堆？有的人一想，题目要求前K个高频元素，那么果断用大根堆啊。那么问题来了，定义一个大小为k的大根堆，在每次移动更新大根堆的时候，每次弹出都把最大的元素弹出去了，那么怎么保留下来前K个高频元素呢。</p><img src="https://img.imgdd.com/a50b001d-26e8-42f2-8404-3be78bfe0761.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>所以我们要用小顶堆，因为要统计最大前k个元素，只有小顶堆每次将最小的元素弹出，最后小顶堆里积累的才是前k个最大元素。</p><img src="https://img.imgdd.com/ad86b9a0-8bfd-4b31-9715-10b23a7b0e81.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><h4 id="思路一：哈希表-1"><a href="#思路一：哈希表-1" class="headerlink" title="思路一：哈希表"></a>思路一：哈希表</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxTime = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;ret;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map;      <span class="comment">// 元素 次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> number : nums) &#123;</span><br><span class="line">            map[number]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到出现的最大次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it : map) &#123;</span><br><span class="line">            <span class="keyword">if</span>(it.second &gt; maxTime) &#123;</span><br><span class="line">                maxTime = it.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> it : map) &#123;</span><br><span class="line">                <span class="keyword">if</span>(it.second == maxTime) &#123;</span><br><span class="line">                    ret.<span class="built_in">push_back</span>(it.first);</span><br><span class="line">                    k--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxTime--;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="思路二：优先队列-1"><a href="#思路二：优先队列-1" class="headerlink" title="思路二：优先队列"></a>思路二：优先队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.second &gt; rhs.second; <span class="comment">// 小顶堆，频率小的在上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//统计每个元素出现的频率</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> number : nums) &#123;</span><br><span class="line">            map[number]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//定义小顶堆，维护前k个频类最高的元素</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,mycomparison&gt;pri_que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> it = map.<span class="built_in">begin</span>();it != map.<span class="built_in">end</span>();it++) &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="keyword">if</span>(pri_que.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">result</span>(k);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k - <span class="number">1</span>;i &gt;= <span class="number">0</span>;i--) &#123;</span><br><span class="line">            result[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-239-滑动窗口最大值"><a href="#LeetCode-239-滑动窗口最大值" class="headerlink" title="LeetCode 239 滑动窗口最大值"></a>LeetCode 239 滑动窗口最大值</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/sliding-window-maximum">239.滑动窗口最大值</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>有同学在学习了优先队列后，可能会想到使用大根堆存放滑动窗口中的k个数字，每次取出堆顶元素（最大值）即可。然而，这里会有一个问题：滑动窗口是动态变化的，而大根堆每次只能弹出最大值，无法移除其他元素。因此，当滑动窗口向右移动时，无法保证弹出的元素正好是大根堆的堆顶元素（最大元素），所以无法直接使用大根堆来解决问题。</p><p>此时我们需要一个队列，这个队列呢，放进去窗口里的元素，然后随着窗口的移动，队列也一进一出，每次移动之后，队列告诉我们里面的最大值是什么。所以，它应该能实现如下功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次窗口移动的时候，调用que.pop(滑动窗口中移除元素的数值)，que.push(滑动窗口添加元素的数值)，然后que.getMaxValue()就返回我们要的最大值。</p><p>但是，我们并没有这种现成的数据结构，只能通过自己定义一个队列进行实现。接着就是最重要的一个问题，那就是<strong>如何实现队列里的元素序列有序？顺序是单调递增还是单调递减？</strong></p><p><strong>其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。<strong>这个维护元素单调递减的队列就叫做</strong>单调队列</strong>，**不要以为实现的单调队列就是 对窗口里面的数进行排序，如果排序的话，那和优先级队列又有什么区别了呢。来看一下单调队列如何维护队列里的元素。</p><ol><li>先将前k个元素入队，当元素3入队时，发现队列中的最后一个元素1小于3，为了实现单调递减，我们将元素1出队（即deq.pop_front()）,接着下一个元素-1入队，发现队列最后一个元素3比自己大，符合单调递减顺序，于是继续入队。这样，在第一轮循环（第一次滑动窗口）结束时，我们就可以知道最大值是队列的队头元素3。</li></ol><img src="https://img.imgdd.com/6a0c41c9-ae60-46c4-a7a2-c34f3c0ad9a0.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><ol start="2"><li>接着，滑块继续向前移动，此时元素-3发现队列最后一个元素-1比自己大，符合单调递减顺序，于是继续入队。</li></ol><img src="https://img.imgdd.com/73fbac73-7f8e-4722-8a36-6c125759ddd1.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><ol start="3"><li>接着，滑动窗口继续向前移动，此时队列内的元素个数已经为k，我们需要执行pop操作，弹出队列头部的元素3，然后将元素5入队。入队时会发现队列中的最后一个元素-3小于5，于是将-3弹出；再比较队列中的最后一个元素-1，仍然小于5，于是将-1也弹出。</li></ol><img src="https://img.imgdd.com/ae95cbfe-4e75-4eca-b06f-b63965b56798.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>后续过程不再给出文字描述，直接看流程图</p><img src="https://img.imgdd.com/799850d8-8307-4647-901f-6a5771278796.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>下面代码就是我们自己设计的双向队列：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;que;      <span class="comment">//注意是deque而不是queue</span></span><br><span class="line">    <span class="comment">//每次弹出的时候，比较当前要弹出的数值value是否等于队列出口元素，如果相等则弹出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素数值，那么就将队列后端数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时，当前队列里的最大值就是队头第一个元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt;que;      <span class="comment">//注意是deque而不是queue</span></span><br><span class="line">    <span class="comment">//每次弹出的时候，比较当前要弹出的数值value是否等于队列出口元素，如果相等则弹出</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果push的数值大于入口元素数值，那么就将队列后端数值弹出，直到push的数值小于等于队列入口元素的数值为止。</span></span><br><span class="line">    <span class="comment">// 这样就保持了队列里的数值是单调从大到小的了。</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; value &gt; que.<span class="built_in">back</span>()) &#123;</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时，当前队列里的最大值就是队头第一个元素</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMaxValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="comment">//先将前k个元素放进队列</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="comment">//滑动窗口移除最前面元素</span></span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]);</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">getMaxValue</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: O(n)</li><li>空间复杂度: O(k)</li></ul><p>这部分的代码比较抽象，还是需要大家多在草稿纸上模拟其过程才能更好的理解</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>大家貌似对单调队列 都有一些疑惑，首先要明确的是，题解中单调队列里的pop和push接口，仅适用于本题。单调队列不是一成不变的，而是不同场景不同写法，总之要保证队列里单调递减或递增的原则，所以叫做单调队列。不要以为本题中的单调队列实现就是固定的写法。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>委托构造和继承构造函数</title>
      <link href="/posts/33535.html"/>
      <url>/posts/33535.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-委托构造函数"><a href="#1-委托构造函数" class="headerlink" title="1.委托构造函数"></a>1.委托构造函数</h1><p><code>委托构造函数允许使用同一个类中的一个构造函数调用其他的构造函数，从而简化相关变量的初始化</code>。下面通过一个例子说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;<span class="comment">// 冗余代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;<span class="comment">// 冗余代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;<span class="comment">// 冗余代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_max;</span><br><span class="line"><span class="type">int</span> m_min;</span><br><span class="line"><span class="type">int</span> m_mid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">&quot;, middle: &quot;</span> &lt;&lt; t.m_mid &lt;&lt; <span class="string">&quot;, max: &quot;</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面三个重载的构造函数中都出现重复的代码，在C++11以前，我们会把重复的代码放到一个函数里，然后调用；在C++11以后，加入了委托构造，我们就可以轻松地完成代码的优化了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) : <span class="built_in">Test</span>(max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid) : <span class="built_in">Test</span>(max,min) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_max;</span><br><span class="line"><span class="type">int</span> m_min;</span><br><span class="line"><span class="type">int</span> m_mid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">&quot;, middle: &quot;</span> &lt;&lt; t.m_mid &lt;&lt; <span class="string">&quot;, max: &quot;</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完代码之后，冗余的代码全部都没有了，并且<code>在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用</code>。在使用委托构造函数的时候还需要注意一些几个问题：</p><ul><li>这种链式的构造函数调用不能形成一个闭环，否则会在运行期间抛出异常</li><li>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) &#123;</span><br><span class="line"><span class="built_in">Test</span>(max);          <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid) &#123;</span><br><span class="line"><span class="built_in">Test</span>(max, min);     <span class="comment">//报错</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_mid = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误, 使用了委托构造函数就不能再次m_max初始化了</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) : <span class="built_in">Test</span>(max), <span class="built_in">m_max</span>(max) &#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-继承构造函数"><a href="#2-继承构造函数" class="headerlink" title="2.继承构造函数"></a>2.继承构造函数</h1><p>C++11中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i) :<span class="built_in">Base</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">Base</span>(i, j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">Base</span>(i, j, k) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> &lt;&lt; c.m_j &lt;&lt; <span class="string">&quot;, string: &quot;</span> &lt;&lt; c.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过继承构造函数在子类中重新定义和基类一样的构造函数：通过使用<code>using 基类名::基类的构造函数名</code>（类名和构造函数名一样）来使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> &lt;&lt; c.m_j &lt;&lt; <span class="string">&quot;, string: &quot;</span> &lt;&lt; c.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在修改之后的子类中，没有添加任何构造函数，而是添加了<code>using Base::Base;</code>这样就可以在子类中直接继承父类的所有的构造函数，通过他们去构造子类对象了。</p><p>另外如果在子类中隐藏了父类中的同名函数，也可以通过using的方式在子类中使用基类中的这些父类函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base class: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, string str)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base class: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="keyword">using</span> Base::func;       <span class="comment">// 引入Base的func重载</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;child class: i&#x27;am huang&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">250</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">func</span>();</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">18</span>);</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">18</span>, <span class="string">&quot;huang&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码输出结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child <span class="keyword">class</span>: i<span class="string">&#x27;am huang</span></span><br><span class="line"><span class="string">base class: i = 18</span></span><br><span class="line"><span class="string">base class: i = 18, str = huang</span></span><br></pre></td></tr></table></figure><p>子类中的<code>func()</code>函数隐藏了基类中的两个<code>func()</code>因此默认情况下通过子类对象只能调用无参的func()，在上面的子类代码中添加了<code>using Base::func;</code>之后，就可以通过子类对象直接调用父类中被隐藏的带参func()函数了。</p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串part01</title>
      <link href="/posts/22964.html"/>
      <url>/posts/22964.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-344-反转字符串"><a href="#LeetCode-344-反转字符串" class="headerlink" title="LeetCode 344 反转字符串"></a>LeetCode 344 反转字符串</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/reverse-string">344.反转字符串</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>如果使用C++、Java等语言进行编程时需要注意，虽然这些语言都提供了丰富的库函数，但我们当前的目的是进行算法练习，因此建议尽量避免直接使用库函数。毕竟，未来在面试时，面试官考察的不是你对库函数的熟悉程度，这一点希望大家能够注意。</p><p>我这里就介绍两种方法：</p><ol><li>首尾指针。定义两个指针，一个指针在字符串前面，一个指针在字符串后面，两个指针同时向中间移动，并交换元素</li><li>栈。栈具有先进后出的特性，我们只需要把元素全部入栈，然后再一次出栈就能实现字符串翻转</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p><strong>1.首尾指针法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseStr</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;left &lt;= right;left++,right--) &#123;</span><br><span class="line">            <span class="type">char</span> ch = s[left];</span><br><span class="line">            s[left] = s[right];</span><br><span class="line">            s[right] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverseStr</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>2.利用栈</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt;st;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            st.<span class="built_in">push</span>(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> ch = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            s[i++] = ch;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-541-反转字符串II"><a href="#LeetCode-541-反转字符串II" class="headerlink" title="LeetCode 541 反转字符串II"></a>LeetCode 541 反转字符串II</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/reverse-string-ii">541.反转字符串II</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题目不涉及到什么算法，只需要跟着题目的反转规则模拟即可</p><ol><li>从0开始遍历字符串，步长为2k</li><li>每一次遍历之后计算剩余长度remainLen，如果<code>remainLen &lt; k</code>，则将剩余字符全部反转。</li><li>如果<code>remainLen &lt; 2*k &amp;&amp; remainLen &gt;= k</code>时，则反转前k个字符</li><li>如果发生上述两种情况，表明剩余字符长度小于2k，那么在下一次遍历时就会自己退出循环</li><li>其他情况，即<code>remainLen &gt;= 2*k</code>，直接反转前k个字符</li></ol><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> indexLen = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i += (<span class="number">2</span>*k)) &#123;</span><br><span class="line">            <span class="type">int</span> remainLen = indexLen - i;</span><br><span class="line">            <span class="keyword">if</span>(remainLen &lt; k) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i,s.<span class="built_in">end</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(remainLen &lt; <span class="number">2</span>*k &amp;&amp; remainLen &gt;= k) &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i,s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i,s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>using的使用</title>
      <link href="/posts/55817.html"/>
      <url>/posts/55817.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-定义别名"><a href="#1-定义别名" class="headerlink" title="1.定义别名"></a>1.定义别名</h1><p>在C++中，可以通过<code>typedef</code>重定义一个类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 旧类型名 新类型名;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br></pre></td></tr></table></figure><p>被重定义的类型并不意味着一个新类型，而是给原来的类型起了一个别名。在C++11中规定一种新的方法，使用using来定义类型别名。语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> 新类型名 = 旧类型名;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">unsigned</span> <span class="type">int</span>;</span><br></pre></td></tr></table></figure><p>通过<code>using</code>和<code>typedef</code>的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个函数指针，using的优势就能凸显出来了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用typedef定义函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*func_ptr)</span><span class="params">(<span class="type">int</span>, <span class="type">double</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用using定义函数指针</span></span><br><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">int</span>(*)(<span class="type">int</span>, <span class="type">double</span>);</span><br></pre></td></tr></table></figure><p>如果比较熟悉函数指针，就能看出func_ptr是一个别名，本质是函数指针，它指向返回值类型为int，参数分别为int和double类型的函数地址。如果使用using定义函数指针别名的写法看起来就非常直观了，<code>把别名的名字强制分离到了左边，而把别名对应的实际类型放在了右边，比较清晰，可读性比较好</code></p><h1 id="2-模板的别名"><a href="#2-模板的别名" class="headerlink" title="2.模板的别名"></a>2.模板的别名</h1><p>使用typedef重定义的时候在某些情况下会有一点限制，比如无法重定义一个模板。如果我们需要一个固定以int类型为key的map，它可以和很多类型的value值进行映射，如果使用typedef这样直接定义就非常麻烦:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, string&gt; m1;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m2;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, <span class="type">double</span>&gt; m3;</span><br></pre></td></tr></table></figure><p>如果我么们通过模板进行定义呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> map&lt;<span class="type">int</span>, T&gt;m;   <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><p>编译器会报错，因为typename不支持给模板定义别名，这个简单的需求仅通过typedef很难办到，需要添加一个外敷类（此处不展开说明）。在C++11中，可以使用<code>using</code>来为模板定义别名，可以写成这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> mymap = map&lt;<span class="type">int</span>, T&gt;;</span><br></pre></td></tr></table></figure><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重定义别名，它是map&lt;int,T&gt;类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> mymap = map&lt;<span class="type">int</span>, T&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">mymap&lt;string&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;huang&quot;</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;nba&quot;</span>));</span><br><span class="line"></span><br><span class="line">mymap&lt;<span class="type">double</span>&gt;m1;</span><br><span class="line">m<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">3.14</span>));</span><br><span class="line">m<span class="number">1.</span><span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">1.314</span>));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>最后要强调的是：using语法和typedef一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。</code></p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表part02</title>
      <link href="/posts/55019.html"/>
      <url>/posts/55019.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-454-四数相加II"><a href="#LeetCode-454-四数相加II" class="headerlink" title="LeetCode 454 四数相加II"></a>LeetCode 454 四数相加II</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/4sum-ii">454.四数相加II</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为这是四个独立的数组，因此，只需要找到<code>A[i]+B[j]+C[k]+D[l]=0</code>即可，无需考虑是否有重复的四个元素相加为0。</p><ul><li>首先，将四个数组分成两部分，A数组和B数组作为一组，C数组和D数组作为另一组。</li><li>接下俩，通过遍历A数组和B数组的所有元素，计算每一对<code>A[i]+B[j]</code>的和，并将其存入哈希表中，哈希表的key是该元素组合的和，value是该和出现的次数。</li><li>然后，再遍历C数组和D数组，计算每一对<code>C[k]+D[l]</code>的和，查找哈希表中是否存在<code>0-(C[k]+D[l])</code>这个键。如果存在，就将该键对应的值（即出现次数）累加到结果中。</li></ul><p>当然，我们也可以A、B和C一组，D一组，不过这样就是三重for循环，时间复杂度O(n3)，因此，为了降低时间复杂度，我们还是分成两组进行求解</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums2) &#123;</span><br><span class="line">                map[i + j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j : nums4) &#123;</span><br><span class="line">                <span class="keyword">if</span>(map.<span class="built_in">find</span>(<span class="number">0</span> - (i + j)) != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    count += map[<span class="number">0</span> - (i + j)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-383-赎金信"><a href="#LeetCode-383-赎金信" class="headerlink" title="LeetCode 383 赎金信"></a>LeetCode 383 赎金信</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/ransom-note">383.赎金信</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题目和昨天的<code>242.有效的字母异位词</code>题目很相似，也可以通过使用数组哈希的方式进行查询。</p><p>当然，这道题目也能用map，但是<strong>使用map的空间消耗要比数组大一些的，因为map要维护红黑树或者哈希表，而且还要做哈希函数，是费时的！数据量大的话就能体现出来差别了。所以在能使用数组哈希的时候尽量使用数组</strong></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> letter[<span class="number">32</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : magazine) &#123;</span><br><span class="line">            letter[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : ransomNote) &#123;</span><br><span class="line">            letter[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : letter) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-15-三数之和"><a href="#LeetCode-15-三数之和" class="headerlink" title="LeetCode 15 三数之和"></a>LeetCode 15 三数之和</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/3sum">15.三数之和</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>这道题目咋一看不是和<code>454.四数相加II</code>题目类似吗，然后使用哈希的解法一顿操作。其实，这道题目并不适合使用哈希法来解，这是因为题目要求<strong>不可以包含重复的三元组</strong>，因此，使用哈希法在不超时的情况下做到对结果去重是很困难的，很有多细节需要处理。就拿题目示例1的数据举个例子。</p><img src="https://img.imgdd.com/4c71ff50-efcf-4e28-bf31-22accd0b9df4.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>假设此时下标1和下标2的元素和1已加入哈希表中，然后遍历下标0，发现符合题目要求，将[-1,0,1]加入结果中。接着继续遍历，当遍历到下标4时，发现再次符合要求，便把[-1,0,1]加入结果中。这样就会导致三元组重复出现，违背了题目要求。当然，这道题目也是能使用哈希表来求解，但是去重的过程不好处理，有很多小细节，此处就不再继续赘述。</p><h4 id="双指针求解"><a href="#双指针求解" class="headerlink" title="双指针求解"></a>双指针求解</h4><p>**那么这题该怎么求解呢？**可以使用双指针进行求解。我们拿数组<code>nums=[-4,-1,-1,-1,0,1,2,2]</code>来举例。</p><img src="https://img.imgdd.com/f855bf88-3491-4ffb-8aeb-2e561c3d2c29.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>首先将数组排序，排好序之后用i标记下标0，同时定义一个下标left在i+1的位置上，定义下标right在数组结尾的位置上。此时，我们就将该问题就转变成<code>nums[i]+nums[left]+nums[right]==0</code>问题，<strong>但是我们如何确定left和right指针的移动呢？</strong></p><ul><li>如果<code>nums[i]+nums[left]+nums[right]&lt;0</code>就说明，此时三数之和小了，需要就left指针向右移动，这样才会让三数之和变大</li><li>反之，如果<code>nums[i]+nums[left]+nums[right]&gt;0</code>就说明，此时三数之和大了，需要就right指针向左移动，这样才会让三数之和变小</li><li>如果<code>nums[i]+nums[left]+nums[right]==0</code>就说明此时的nums[i]、nums[left]和nums[right]这三个数正是我们需要的，加入到结果数组中，并且left向右移动，right向左移动</li></ul><p>于是就有了初版的代码，大家可以根据代码流程在草稿纸模拟nums数组求解：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="去重逻辑"><a href="#去重逻辑" class="headerlink" title="去重逻辑"></a>去重逻辑</h4><p>上面代码似乎没什么问题，很合理对吧？但是，还有一个很关键的问题，那就是<strong>去重问题</strong>。我们再通过nums来模拟一遍。</p><p>假设此时下标1和下标2的元素和1已加入哈希表中，然后遍历下标0，发现符合题目要求，将[-1,0,1]加入结果集中。接着继续遍历，当遍历到下标4时，发现再次符合要求，便把[-1,0,1]加入结果集中。这样就会导致三元组重复出现，违背了题目要求。</p><img src="https://img.imgdd.com/4dc24a93-30d8-4ea3-8e32-6297114ebe15.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>说到去重，其实主要考虑三个数的去重，即nums[i]，nums[left]和nums[right]。假设nums[i]重复了怎么办，很简单，既然nums[i]是nums里遍历的元素，那么应该直接跳过去。**但这里又有一个问题，是判断nums[i]与nums[i+1]是否相同，还是判断nums[i]与nums[i-1] 是否相同。**有同学可能想，这不都一样吗。其实不一样！如果我们选择前者写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>]) &#123; </span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果此时<code>nums=[-1,-1,2]</code>那不就把整个情况都pass掉了，显然这是不合理的，<strong>我们要做的是不能有重复的三元组，但三元组内的元素是可以重复的！</strong>。因此，我们还是这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nums[left]和nums[right]的去重逻辑就简单很多了，直接给出代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left<span class="number">+1</span>]) left++;</span><br><span class="line"><span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right<span class="number">-1</span>]) right--;</span><br></pre></td></tr></table></figure><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>) left++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[left] == nums[left<span class="number">+1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(right &gt; left &amp;&amp; nums[right] == nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-18-四数之和"><a href="#LeetCode-18-四数之和" class="headerlink" title="LeetCode 18 四数之和"></a>LeetCode 18 四数之和</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/4sum">18.四数之和</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>与<code>15.三数之和</code>题目思路类似，都是使用双指针法, 基本解法就是在<code>15.三数之和</code>的基础上再套一层for循环。不过有一些细节需要注意：</p><ul><li>不要判断<code>nums[k]&gt;target</code>就返回了，三数之和可以通过<code>nums[i]&gt;0</code>就返回，是因为0已经是确定的数了，四数之和这道题目 target是任意值。比如：<code>nums= [-4, -3, -2, -1],target=-10</code>，不能因为-4&gt;-10而跳过。但是我们依旧可以去做剪枝，逻辑变成<code>nums[k]&gt;target &amp;&amp; (nums[k]&gt;=0 || target&gt;=0)</code>就可以了。</li><li>四数之和的双指针解法是两层for循环<code>nums[k]+nums[i]</code>为确定值，依然是循环内有left和right下标作为双指针，找出<code>nums[k]+nums[i]+nums[left]+nums[right]==target</code>的情况，</li><li>注意数组是否会溢出</li></ul><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k &lt; nums.<span class="built_in">size</span>();k++) &#123;</span><br><span class="line">            <span class="comment">//-6,-2,...     target: -8</span></span><br><span class="line">            <span class="keyword">if</span>(nums[k] &gt; target &amp;&amp; nums[k] &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//k去重</span></span><br><span class="line">            <span class="keyword">if</span>(k &gt; <span class="number">0</span> &amp;&amp; nums[k] == nums[k - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = k + <span class="number">1</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[k] + nums[i] &gt; target &amp;&amp; nums[k] + nums[i] &gt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//i去重</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt; k + <span class="number">1</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span>((<span class="type">long</span>)nums[k] + nums[i] + nums[left] + nums[right] &lt; target) left++;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)nums[k] + nums[i] + nums[left] + nums[right] &gt; target) right--;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(vector&lt;<span class="type">int</span>&gt;&#123;nums[k], nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                        <span class="comment">//left和right去重</span></span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) right--;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) left++;</span><br><span class="line">                        left++;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动类型推导</title>
      <link href="/posts/12428.html"/>
      <url>/posts/12428.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-final"><a href="#1-final" class="headerlink" title="1.final"></a>1.final</h1><p>C++11的关键字<code>final</code>有两个用途。<code>第一，它阻止某个虚函数不能被重写；第二，它限制某个类不能被继承。</code>如果使用<code>final</code>修饰函数，<code>只能修饰虚函数</code>，并且<code>要把final关键字放到类或者函数后面</code></p><h2 id="1-1-修饰函数"><a href="#1-1-修饰函数" class="headerlink" title="1.1 修饰函数"></a>1.1 修饰函数</h2><p>如果将类方法标记为fianal，这意味着无法在子类中重写该方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//使用final关键字标记该方法</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">final</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> :<span class="keyword">public</span> Child &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//报错，此时不能再重写该虚函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1-2-修饰类"><a href="#1-2-修饰类" class="headerlink" title="1.2 修饰类"></a>1.2 修饰类</h2><p>C++11中允许将类标记为final，直接在类名称后面使用关键字final，如此，意味着继承该类会导致编译错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用final关键字标记Child类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">final</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错，此时不能继承Child类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> :<span class="keyword">public</span> Child &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>Child</code>类被<code>final</code>修饰过，因此<code>Child</code>类不允许有派生类，<code>GrandChild</code>类的继承是非法的</p><h1 id="2-override"><a href="#2-override" class="headerlink" title="2.override"></a>2.override</h1><p><code>override</code>关键字<code>确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，（起到检查的作用，让人一眼就能看出来该方法是重写父类中的方法）</code>这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Base class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> :<span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Child class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GrandChild</span> :<span class="keyword">public</span> Child &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//报错，因为override表明这是一个重写函数，但是父类中却没有这样的函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test11</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GrandChild class...&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动类型推导</title>
      <link href="/posts/12430.html"/>
      <url>/posts/12430.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-模板的右尖括号"><a href="#1-模板的右尖括号" class="headerlink" title="1.模板的右尖括号"></a>1.模板的右尖括号</h1><p>泛型编程中，模板实例化是一个非常繁琐的地方，那就是连续的<code>两个右尖括号（&gt;&gt;）</code>会被编译器解析成右移操作，而不是模板参数表的结束，在C++11以前需要在<code>&gt;&gt;</code>之间加上一个空格<code>&gt; &gt;</code>。C++11之后就不需要再加上空格，改进了编译器的解析规则，尽可能的将多个右尖括号解析成模板参数结束符。</p><h1 id="2-默认模板参数"><a href="#2-默认模板参数" class="headerlink" title="2.默认模板参数"></a>2.默认模板参数</h1><p>在C++11以前，类模板是可以有默认的模板参数，但是不支持函数的默认模板参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T = <span class="type">int</span>, T t = <span class="number">520</span>&gt; </span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">void</span> <span class="built_in">print</span>() &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;current value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Test&lt;&gt;t;</span><br><span class="line">t.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">Test&lt;<span class="type">int</span>, <span class="number">1024</span>&gt;t1;</span><br><span class="line">t<span class="number">1.</span><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>在C++11中添加了默认模板参数的支持：</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T </span>= <span class="type">long</span>, <span class="keyword">typename</span> U = <span class="type">int</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">mytest</span>(T t = <span class="string">&#x27;A&#x27;</span>, U u = <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;t: &quot;</span> &lt;&lt; t &lt;&lt; <span class="string">&quot;, u: &quot;</span> &lt;&lt; u &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">mytest</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// 自动推导，根据传递的实参 mytest&lt;char,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;int,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;char,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">int</span>, <span class="type">char</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;int,char&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>);<span class="comment">// mytest&lt;char,int&gt;</span></span><br><span class="line"><span class="built_in">mytest</span>();<span class="comment">// 没有显示指定类型，没有传递实参，使用默认类型 mytest&lt;long,int&gt;</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面例子可以得出结论：<code>当所有模板参数都有默认参数时，函数模板调用相当于调用普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板类名后跟随&lt;&gt;进行实例化</code></p><p><code>此外，函数模板的默认模板参数在使用时和其他默认参数也有些不同，它没有必须写在参数表最后的限制。</code>当默认模板参数和模板参数自动推导同时使用时（优先级从高到低）：</p><ul><li>如果可以推导出参数类型则使用推导出的类型</li><li>如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数（默认的函数参数不能用于类型推导）</li><li>如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希表part01</title>
      <link href="/posts/40691.html"/>
      <url>/posts/40691.html</url>
      
        <content type="html"><![CDATA[<h2 id="常见的三种哈希结构"><a href="#常见的三种哈希结构" class="headerlink" title="常见的三种哈希结构"></a>常见的三种哈希结构</h2><p><strong>用来快速判断一个元素是否出现集合里的情况</strong>，我们一般会选择如下三种数据结构。</p><ul><li>数组</li><li>set （集合）</li><li>map（映射）</li></ul><p>在C++中，set和map分别提供了以下三种数据结构：</p><table><thead><tr><th align="center">集合</th><th align="center">底层实现</th><th align="center">是否有序</th><th align="center">数值是否可以重复</th><th align="center">能否更改数值</th><th align="center">查询效率</th><th align="center">增删效率</th></tr></thead><tbody><tr><td align="center">std::set</td><td align="center">红黑树</td><td align="center">有序</td><td align="center">否</td><td align="center">否</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::multiset</td><td align="center">红黑树</td><td align="center">有序</td><td align="center">是</td><td align="center">否</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::unordered_set</td><td align="center">哈希表</td><td align="center">无序</td><td align="center">否</td><td align="center">否</td><td align="center">O(1)</td><td align="center">O(1)</td></tr></tbody></table><p>std::set和std::multiset底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><table><thead><tr><th align="center">映射</th><th align="center">底层实现</th><th align="center">是否有序</th><th align="center">数值是否可以重复</th><th align="center">能否更改数值</th><th align="center">查询效率</th><th align="center">增删效率</th></tr></thead><tbody><tr><td align="center">std::map</td><td align="center">红黑树</td><td align="center">key有序</td><td align="center">key不可重复</td><td align="center">key不可修改</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::multimap</td><td align="center">红黑树</td><td align="center">key有序</td><td align="center">key可重复是</td><td align="center">key不可修改</td><td align="center">O(logn)</td><td align="center">O(logn)</td></tr><tr><td align="center">std::unordered_map</td><td align="center">哈希表</td><td align="center">key无序</td><td align="center">key不可重复</td><td align="center">key不可修改</td><td align="center">O(1)</td><td align="center">O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><p>当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。</p><h2 id="三种哈希结构的使用场景"><a href="#三种哈希结构的使用场景" class="headerlink" title="三种哈希结构的使用场景"></a>三种哈希结构的使用场景</h2><ol><li><p>若数据范围有限（如元素值较小或数组长度固定），优先使用数组哈希（通过元素值直接映射下标），存储高效且访问速度快；</p></li><li><p>若数据范围较大或元素值分布稀疏，使用哈希集合（如 std::unordered_set） 可避免空间浪费；</p></li><li><p>若需统计元素出现频次，则需采用哈希映射（如 std::unordered_map） 记录键值对，兼顾存在性检查和次数统计。</p></li></ol><h2 id="LeetCode-242-有效的字母异位词"><a href="#LeetCode-242-有效的字母异位词" class="headerlink" title="LeetCode 242 有效的字母异位词"></a>LeetCode 242 有效的字母异位词</h2><p><strong>题目链接：</strong><a href="https://leetcode.cn/problems/valid-anagram">242.有效的字母异位词</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题可以使用数组哈希的方式进行查询。我们通过定义一个数组来记录字符串s中的出现次数，**那么我们应该定义多大空间的数组呢？**显然，我们要记录字符串s中每一个字符出现的次数，因此我们需要开辟一个空间大小为26的数组letter。需要把字符映射到数组也就是哈希表的索引下标上，**因为字符a到字符z的ASCII是26个连续的数值，所以字符a映射为下标0，相应的字符z映射为下标25。**我们在遍历字符串s的时候，只需要将<code>s[i]-&#39;a&#39;</code>所在的元素进行<code>+1</code>操作即可。</p><img src="https://img.imgdd.com/f431153a-58af-4ae0-9f12-265b1b23339e.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>遍历完字符串s之后，我们再遍历字符串t，不同的是我们要对t中出现的字符映射哈希表索引上的数值进行<code>-1</code>的操作。</p><img src="https://img.imgdd.com/0ce71d0a-0d08-46f3-b131-a096bfff1256.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>最后，对letter数组进行遍历，<strong>如果数组中有的元素不为零0，说明字符串s和t一定是谁多了字符或者谁少了字符，返回false。</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compareStr</span><span class="params">(string s,string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> letter[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//第一次遍历字符串s，记录s中每个字符出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            letter[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第二次遍历字符串t</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : t) &#123;</span><br><span class="line">            letter[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后遍历letter数组，如果有非0，表示出现非公共字母</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> count : letter) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ret = <span class="built_in">compareStr</span>(s,t);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-349-两个数组的交集"><a href="#LeetCode-349-两个数组的交集" class="headerlink" title="LeetCode 349 两个数组的交集"></a>LeetCode 349 两个数组的交集</h2><p>**题目链接：**<a href="https://leetcode.cn/problems/intersection-of-two-arrays">https://leetcode.cn/problems/intersection-of-two-arrays</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>这道题目，因为数组的长度范围是 1-1000，而每一个元素的数组是0-1000，很明显这题不能像上一题一样使用数组作为哈希表的结构</p><p>我们此时可以使用unorder_set的哈希结构求解两个范围较大的数组的交集。</p><ul><li>首先将nums1的元素存入哈希集合temp，该哈希集合会自动去重</li><li>然后遍历nums2，检查每个元素是否存在哈希集合temp中，若存在加入结果集result</li><li>注意，结果集result也要使用unorder_set结构，因为nums2可能会出现重复的元素，避免这些重复元素再次加入到结果集内</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存放结果</span></span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;result;           </span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;<span class="built_in">temp</span>(nums<span class="number">1.</span><span class="built_in">begin</span>(),nums<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> number : nums2) &#123;</span><br><span class="line">            <span class="comment">//每次从nums2中取出一个元素后，在哈希表中查找是否存在</span></span><br><span class="line">            <span class="keyword">if</span>(temp.<span class="built_in">find</span>(number) != temp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result.<span class="built_in">insert</span>(number);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">ret</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-202-快乐数"><a href="#LeetCode-202-快乐数" class="headerlink" title="LeetCode 202 快乐数"></a>LeetCode 202 快乐数</h2><p>**题目链接：**<a href="https://leetcode.cn/problems/happy-number">https://leetcode.cn/problems/happy-number</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>题目中说过会出现无限循环的情况，**那么无限循环的情况会是什么呢？**如果仔细思考能够发现，如果某一个数重复出现，那不就表明它接下来的计算还会得出已经出现过的结果。例如：<code>4-&gt;16-&gt;37-&gt;58-&gt;89-&gt;145-&gt;42-&gt;20-&gt;4-&gt;16-&gt;...</code></p><p>因此，为了判断是否出现重复出现数字的情况，我们可以使用unordered_set结构进行判断</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSum</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n) &#123;</span><br><span class="line">            sum += <span class="built_in">pow</span>(n%<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;set;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="built_in">getSum</span>(n);</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(set.<span class="built_in">find</span>(sum) != set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                set.<span class="built_in">insert</span>(sum);</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-1-两数之和"><a href="#LeetCode-1-两数之和" class="headerlink" title="LeetCode 1 两数之和"></a>LeetCode 1 两数之和</h2><p>**题目链接：**<a href="https://leetcode.cn/problems/two-sum/">https://leetcode.cn/problems/two-sum\</a></p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>这道题目我们使用unordered_map，key保存的是元素值，value保存的是当前元素值在数组中的下标。</p><p>遍历数组时，对于每个元素nums[i]，计算目标差值gap，然后在哈希表中查找是否存在这个差值，如果能找到，表明有另一个数可以和其相加得到target，此时返回当前数的索引和匹配值的索引；否则，否则将当前元素及其索引存入哈希表以便后续查找，确保只需一次遍历即可找到解。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;result;</span><br><span class="line">        <span class="comment">//元素 下标</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;map;    </span><br><span class="line">        map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[<span class="number">0</span>],<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; nums.<span class="built_in">size</span>();i++) &#123;</span><br><span class="line">            <span class="type">int</span> gap = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(gap);</span><br><span class="line">            <span class="keyword">if</span>(iter != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(i);</span><br><span class="line">                result.<span class="built_in">push_back</span>(iter-&gt;second);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt;(nums[i],i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>指针控制类型</title>
      <link href="/posts/22516.html"/>
      <url>/posts/22516.html</url>
      
        <content type="html"><![CDATA[<p>在C++程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为<strong>NULL</strong>，避免产生野指针。在C++98&#x2F;03标准中，将一个指针初始化为空有两种方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* p1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* p2 = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><p>在底层NULL的源码定义是这样的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在C中，NULL会被强制转换重<code>void*</code>类型，但是在C++中，是不允许一个<code>void*</code>类型的指针隐式转换为其他类型的指针，因此，为了兼容以前的设计，C++就把NULL定义成字面量0。但是，<strong>C++中将NULL定义为字面值常量0</strong>在某些场景下并不能很好的工作，例如，函数重载时，<strong>NULL和0无法区分</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(char* p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(int p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">func</span>(<span class="number">250</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码打印结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br></pre></td></tr></table></figure><p>从打印结果可以看出，虽然调用<code>func(NULL)</code>，但最终还是调用<code>void func(int p)</code>，其实，这个原因正是因为C++把NULL定义成字面量0，因此，函数重载的是<code>void func(int p)</code></p><p>出于兼容性的考虑，C++11标准并没有对NULL的宏定义做任何修改，而是另其炉灶，引入了一个新的关键字nullptr。<strong>nullptr专用于初始化空类型指针，不同类型的指针变量都可以使用nullptr来初始化</strong>。可以将nullptr隐式转换成int*、char*以及double*指针类型。使用nullptr也可以很完美的解决上边提到的函数重载问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(char* p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;void func(int p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span>* ptr1 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">char</span>* ptr2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">double</span>* ptr3 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">void</span>* ptr4 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++里不允许void*隐式类型转换成其他类型的指针</span></span><br><span class="line"><span class="type">int</span>* ptr5 = (<span class="type">int</span>*)ptr4;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int</span></span><br><span class="line"><span class="built_in">func</span>(<span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">//char*</span></span><br><span class="line"><span class="built_in">func</span>(<span class="number">250</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试代码结果打印</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span>* p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br></pre></td></tr></table></figure><p>通过输出的结果可以看出，<strong>nullptr无法隐式转换为整形，但是可以隐式匹配指针类型。在 C++11标准下，相比NULL和0，推荐大家都是用nullptr来初始化空指针。</strong></p>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常量表达式修饰符-constexpr</title>
      <link href="/posts/63765.html"/>
      <url>/posts/63765.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-constexpr"><a href="#1-constexpr" class="headerlink" title="1.constexpr"></a>1.constexpr</h2><h3 id="1-1-const"><a href="#1-1-const" class="headerlink" title="1.1 const"></a>1.1 const</h3><p>在C++11之前只有const关键字，从功能上来说它有双重语义：<strong>变量只读、修饰常量</strong>，通过一个例子体会一下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义两个变量</span></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">520</span>;</span><br><span class="line"><span class="type">int</span> a2 = <span class="number">250</span>;</span><br><span class="line"><span class="comment">//定义常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> count = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; b = a1;</span><br><span class="line">b = a2;<span class="comment">//错误</span></span><br><span class="line">a1 = <span class="number">1314</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl;<span class="comment">//输出1314</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> array[count];<span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> array[a1];<span class="comment">//报错 </span></span><br><span class="line"><span class="type">int</span> array[num];<span class="comment">//报错 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数<code>void func(const int num)</code>的参数<code>num</code>表示<strong>该变量只读，但不是常量</strong>。因此，以<code>int array[num];</code>方式定义数组，编译器会报错，提示<code>num不作为常量使用</code></li><li><code>const int count = 24</code>中的<code>const</code>却是一个常量，因此可以使用这个常量来定义一个静态数组。</li><li>b是一个常量的引用，因此它初始化之后就不能被修改，因此<code>b = a2</code>会报错</li><li>引用b是只读的，并不能保证它的值不会被改变，也就是说它不是常量</li></ul><h3 id="1-2-constexpt"><a href="#1-2-constexpt" class="headerlink" title="1.2 constexpt"></a>1.2 constexpt</h3><p>在C++11中添加了一个新的关键字<code>constexpr</code>，这个关键字是用来修饰常量表达式的。所谓<strong>常量表达式，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。</strong></p><p>C++程序从编写完毕到执行分为四个阶段：<strong>预处理、 编译、汇编和链接</strong>。需要额外强调的是，常量表达式和非常量表达式的计算时机不同，<strong>非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段</strong>，这极大提高了程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p><p><strong>那么编译器如何识别表达式是常量表达式还是变量表达式呢？<strong>在C++11中添加了<code>constexpr</code>关键字之后就可以在程序中使用它来修饰常量表达式，用来提高程序的执行效率。在使用中建议将const和constexpr的功能区分开，即</strong>凡是表达“只读”语义的场景都使用const，表达“常量”语义的场景都使用constexpr。</strong></p><p>在C++11之前，<code>const</code>和<code>constexpr</code>是等价的，都可以在程序编译阶段计算出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> m = <span class="built_in">f</span>();  <span class="comment">// 不是常量表达式，m的值只有在运行时才会获取。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=i<span class="number">+1</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> j=i<span class="number">+1</span>;    <span class="comment">// 是一个常量表达式</span></span><br></pre></td></tr></table></figure><p>但是在C++11之后，对于<strong>内置数据类型</strong>，推荐使用<code>constexpr</code>修饰，这样编译器在程序的编译阶段就能计算出常量的结果。但如果是<strong>自定义数据类型</strong>（<code>struct</code>和<code>class</code>），不能直接使用<code>constexpr</code>修饰</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器提示 constexpr在此处无效</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果要修饰自定义数据类型，可以这样写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span> &#123;</span><br><span class="line"><span class="type">int</span> num1;</span><br><span class="line"><span class="type">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> T t&#123; <span class="number">1</span>,<span class="number">2</span> &#125;;<span class="comment">//定义一个常量的结构体对象，并在声明时初始化</span></span><br><span class="line">t.num1 = <span class="number">10</span>;<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-常量表达式函数"><a href="#2-常量表达式函数" class="headerlink" title="2.常量表达式函数"></a>2.常量表达式函数</h2><p>可以使用<code>constexpr</code>修饰函数的返回值，这种函数被称作<strong>常量表达式函数</strong>，这些函数主要包括以下几种：<strong>普通函数&#x2F;类成员函数、类的构造函数、模板函数。</strong></p><h3 id="2-1修饰函数"><a href="#2-1修饰函数" class="headerlink" title="2.1修饰函数"></a>2.1修饰函数</h3><p><code>constexpr</code>并不能修饰任意函数的返回值，使得这些函数都能成为常量表达式函数，必须满足以下条件：</p><ol><li>函数必须要有返回值，并且return返回的表达式必须是常量表达式。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误 没有返回值（报错信息：constexpr函数&quot;func1&quot;不能生成常量表达式）</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//错误 返回值不是常量表达式（报错信息：表达式的计算机过不是常数）</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>函数在使用之前，必须要有对应的定义语句</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func3</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ret = <span class="built_in">func3</span>();<span class="comment">//报错，因为在使用之前只有声明没有定义</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func3</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>整个函数的函数体中，不能出现非常量表达式之外的语句（using指令、typedef语句以及static_assert断言、return语句除外）。因此，常量表达式函数是一类功能非常简单的函数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误 for循环是一个非法操作</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func4</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func5</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">using</span> mytype = <span class="type">int</span>;</span><br><span class="line"><span class="keyword">constexpr</span> mytype a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">constexpr</span> mytype b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">constexpr</span> mytype c = a * b;</span><br><span class="line"><span class="keyword">return</span> c - (a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 以上三条规则不仅对应普通函数适用，对应类的成员函数也是适用的：</p><h3 id="2-2-修饰模板函数"><a href="#2-2-修饰模板函数" class="headerlink" title="2.2 修饰模板函数"></a>2.2 修饰模板函数</h3><p>C++11 语法中，<code>constexpr</code>可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。<strong>如果constexpr修饰的模板函数实例化结果不满足常量表达式函数的要求，则constexpr会被自动忽略，即该函数就等同于一个普通函数。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">display</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* name;<span class="comment">//注意此处不能使用string</span></span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> p &#123;<span class="string">&quot;Lina&quot;</span>,<span class="number">18</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> ret = <span class="built_in">display</span>(p);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//常量表达式函数</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">display</span>(<span class="number">250</span>);</span><br><span class="line">cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> p1 &#123; <span class="string">&quot;Mike&quot;</span>, <span class="number">19</span> &#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> ret2 = <span class="built_in">display</span>(p1);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; ret<span class="number">2.</span>name &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; ret<span class="number">2.</span>age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>struct Person ret = display(p);</code>由于参数p是变量，因此，返回值的类型就不是常量表达式，也不满足常量表达式函数的要求，此时<code>constexpr</code>是无效的</li><li><code>constexpr int ret1 = display(250);</code>由于参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li><li><code>constexpr struct Person ret2 = display(p1);</code>由于参数是常量，符合常量表达式函数的要求，此时<code>constexpr</code>是有效的</li></ul><h3 id="2-3-修饰构造函数"><a href="#2-3-修饰构造函数" class="headerlink" title="2.3 修饰构造函数"></a>2.3 修饰构造函数</h3><p>如果要使用<code>constexpr</code>来修饰一个构造函数，那么这个<strong>构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Person</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">int</span> age)</span> :name(p), age(age) &#123;</span>&#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> <span class="built_in">p1</span>(<span class="string">&quot;luffy&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;luffy&#x27;s name: &quot;</span> &lt;&lt; p<span class="number">1.</span>name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; p<span class="number">1.</span>age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动类型推导</title>
      <link href="/posts/12429.html"/>
      <url>/posts/12429.html</url>
      
        <content type="html"><![CDATA[<h1 id="1-auto"><a href="#1-auto" class="headerlink" title="1.auto"></a>1.auto</h1><p>在C++11之前，auto和static是对应的，表示<strong>变量自动存储</strong>，但是非static的局部变量默认都是自动存储的，因此这个关键字变得非常鸡肋，但是，在C++11中他们被赋予了新的含义，使用这个关键字能够像别的语言一样<strong>自动推导出变量的实际类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> <span class="type">int</span> a = <span class="number">0</span>;<span class="comment">// C++11以前：显式声明为自动存储（默认就是auto，一般不写）</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> b = <span class="number">0</span>;<span class="comment">// 静态存储，生命周期持续到程序结束</span></span><br><span class="line">a++;</span><br><span class="line">b++;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;auto a=&quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; static int b=&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>();<span class="comment">// auto a=1 static int b=1</span></span><br><span class="line"><span class="built_in">func</span>();<span class="comment">// auto a=1 static int b=2</span></span><br><span class="line"><span class="built_in">func</span>();<span class="comment">// auto a=1 static int b=3</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-1-推导规则"><a href="#1-1-推导规则" class="headerlink" title="1.1 推导规则"></a>1.1 推导规则</h2><p>从上面的案例能发现，在C++11以前，auto并不代表一种实际的数据类型，只是一个类型声明的“占位符”，auto并非在任意场景下都能够推导出变量的实际类型。**使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型。**使用语法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> 变量名 = 变量值;</span><br></pre></td></tr></table></figure><p>下面举个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;<span class="comment">// x是int类型</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">3.1415</span>;<span class="comment">// y是double类型</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="string">&#x27;a&#x27;</span>;<span class="comment">// z是char类型</span></span><br><span class="line"><span class="keyword">auto</span> a;<span class="comment">// 报错，没有进行初始化</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">double</span> x;<span class="comment">// 报错，不能与任何其他类型组合（不能修改数据类型）</span></span><br></pre></td></tr></table></figure><p>auto还可以和指针、引用结合起来使用也可以带上const、volatile限定符，在不同的场景下有对应的推导规则，规则内容如下：</p><ul><li>当变量不是指针或引用类型时，推导结果中不会保留const、volatile关键字</li><li>当变量是指针或引用类型时，推导结果中会保留const、bolatile关键字</li></ul><p>光是看上面的文字就觉得有些抽象，下面通过几个例子感受一下，第一个例子先介绍变量带指针和引用并使用auto进行类型推导：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">auto</span>* a = &amp;temp;<span class="comment">// &amp;temp: int* --&gt; auto* = int* --&gt; auto: int</span></span><br><span class="line"><span class="keyword">auto</span> b = &amp;temp;<span class="comment">// &amp;temp: int* --&gt; auto: int* </span></span><br><span class="line"><span class="keyword">auto</span>&amp; c = temp;<span class="comment">// auto: int</span></span><br><span class="line"><span class="keyword">auto</span> d = temp;<span class="comment">// auto: int</span></span><br></pre></td></tr></table></figure><p>第二个例子介绍的是带const限定的变量，并使用auto进行类型推导</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">250</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> a1 = tmp;<span class="comment">// auto: int</span></span><br><span class="line"><span class="keyword">auto</span> a2 = a1;<span class="comment">// a1: const int --&gt; auto: int</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span>&amp; a3 = tmp;<span class="comment">// a3: const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>&amp; a4 = a3;<span class="comment">// a4: const int&amp;</span></span><br><span class="line"><span class="keyword">auto</span>* pt4 = &amp;a1;<span class="comment">// pt4: const int*</span></span><br></pre></td></tr></table></figure><ul><li>变量<code>a1</code>的数据类型为<code>const int</code>，因此auto关键字被推导为<code>int</code>类型</li><li>变量<code>a2</code>的数据类型为<code>int</code>，但是a2没有声明为指针或引用，因此<code>const</code>属性被去掉, <code>auto</code>被推导为<code>int</code></li><li>变量<code>a3</code>的数据类型为<code>const int&amp;</code>，a3被声明为引用，因此const属性被保留，<code>auto</code>关键字被推导为<code>int</code>类型</li><li>变量<code>a4</code>的数据类型为<code>const int&amp;</code>，a4被声明为引用，因此const属性被保留，<code>auto</code>关键字被推导为<code>const int</code>类型</li><li>变量<code>pt4</code>的数据类型为<code>const int*</code>，pt4被声明为指针，因此推导结果保留const，<code>auto</code>关键字被推导<code>const int</code>类型</li></ul><h2 id="1-2-auto的限制"><a href="#1-2-auto的限制" class="headerlink" title="1.2 auto的限制"></a>1.2 auto的限制</h2><p>auto关键字并不是万能的，在某些场景下不能完成类型推导</p><ol><li>不能作为函数的参数使用。因为只有在函数调用的时候才会给函数参数传递实参，但是auto要求必须要初始化赋值，因此，二者矛盾</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)</span> </span>&#123;      <span class="comment">//报错：此处不能使用auto</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;,b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>不能用于类的非静态成员变量的初始化。因为类的非静态成员变量不属于类，它属于对象的，只有当这个类被创建出来后才能给该成员变量赋值。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">auto</span> v1 = <span class="number">0</span>;<span class="comment">// 报错</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">auto</span> v2 = <span class="number">0</span>;<span class="comment">// 报错 类的静态非常量成员不允许在类内部直接初始化（基础语法）</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> v3 = <span class="number">10</span>;<span class="comment">// 正确</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>不能使用auto关键字定义数组</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> array[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> t1 = array;<span class="comment">// 正确 auto: int*</span></span><br><span class="line"><span class="keyword">auto</span> t2[] = array;<span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">auto</span> t3[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;<span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>无法使用auto推导出模板参数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test&lt;<span class="type">double</span>&gt; t;</span><br><span class="line">    Test&lt;<span class="keyword">auto</span>&gt; t1 = t;      <span class="comment">// 报错 无法推导出模板类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-auto的应用"><a href="#1-3-auto的应用" class="headerlink" title="1.3 auto的应用"></a>1.3 auto的应用</h2><ol><li>用于STL容器的遍历</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&quot;ace&quot;</span>));</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="string">&quot;sabo&quot;</span>));</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;luffy&quot;</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = mp.<span class="built_in">begin</span>(); it != mp.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><code>用于泛型编程</code>，在使用模板的时候，大多数情况下我们不知道该定义什么类型的变量，例如：</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> string <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> A&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> ret = A::<span class="built_in">get</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;ret: &quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">func</span>&lt;T1&gt;();</span><br><span class="line"><span class="built_in">func</span>&lt;T2&gt;();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中定义了模板函数func，在函数内部调用类A的静态方法get()，但是我们不知道调用的是哪一个返回值的get()方法，因此返回值的类型不能确定，如果不使用auto，就需要再定义一个模板参数，并且在外部调用时手动指定get的返回值类型，具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;        <span class="comment">// 添加了模板参数B</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    B val = A::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;T1, <span class="type">int</span>&gt;();                 </span><br><span class="line">    <span class="built_in">func</span>&lt;T2, string&gt;();              </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-decltype"><a href="#2-decltype" class="headerlink" title="2.decltype"></a>2.decltype</h1><p>在<strong>编译时期</strong>进行自动类型推导。引入decltype是因为auto并不适用于所有的自动类型推导场景，在某些特殊情况下auto用起来很不方便，甚至压根无法使用。语法格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(表达式)</span><br></pre></td></tr></table></figure><p>decltype的推导是在编译期完成的，**它只是用于表达式类型的推导，并不会计算表达式的值。**来看一组简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">100</span>;<span class="comment">// b-&gt;int</span></span><br><span class="line"><span class="keyword">decltype</span>(a + <span class="number">3.14</span>) c = <span class="number">3.14</span>;<span class="comment">// c-&gt;double</span></span><br></pre></td></tr></table></figure><h2 id="2-1-推导规则"><a href="#2-1-推导规则" class="headerlink" title="2.1 推导规则"></a>2.1 推导规则</h2><ol><li>表达式为<code>普通变量或普通表达式或类成员表达式</code>，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string text;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; y = x;<span class="comment">// y -&gt; const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(x) a = x;<span class="comment">// a -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(y) b = x;<span class="comment">// b -&gt; const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(Test::value) c = <span class="number">0</span>;<span class="comment">// c -&gt; const int</span></span><br><span class="line"></span><br><span class="line">Test t;</span><br><span class="line"><span class="keyword">decltype</span>(t.text) d = <span class="string">&quot;hello&quot;</span>;<span class="comment">// d -&gt; string</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>表达式是<code>函数调用</code>，则decltype推导的类型应和函数返回值类型一致</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;...&#125;;</span><br><span class="line"><span class="comment">//函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func_int</span><span class="params">()</span></span>;                 <span class="comment">// 返回值为 int</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func_int_r</span><span class="params">()</span></span>;              <span class="comment">// 返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">()</span></span>;            <span class="comment">// 返回值为 int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">func_cint</span><span class="params">()</span></span>;          <span class="comment">// 返回值为 const int</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">func_cint_r</span><span class="params">()</span></span>;       <span class="comment">// 返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">()</span></span>;     <span class="comment">// 返回值为 const int&amp;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> Test <span class="title">func_ctest</span><span class="params">()</span></span>;        <span class="comment">// 返回值为 const Test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>()) a = <span class="number">0</span>;<span class="comment">// a: int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>()) b = n;<span class="comment">// b: int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) c = <span class="number">0</span>;<span class="comment">// c: int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint</span>())  d = <span class="number">0</span>;<span class="comment">// d: int   纯右值，此处忽略const</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_r</span>())  e = n;<span class="comment">// e: const int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) f = <span class="number">0</span>;<span class="comment">// f: const int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_ctest</span>()) g = <span class="built_in">Test</span>();<span class="comment">// g: const Test  纯右值，但是是类类型，可以保留const</span></span><br></pre></td></tr></table></figure><p>函数func_cint()返回的是一个<code>纯右值</code>，<code>对于纯右值而言，只有类类型可以携带const、volatile限定符</code>，除此之外需要忽略掉这两个限定符，因此推导出的变量d的类型为int而不是const int</p><ol start="3"><li>表达式是一个<code>左值，或者被括号()包围</code>，使用decltype推导出的是表达式类型的引用（如果有const、volatile限定符不能忽略）</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">string text;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">const</span> Test obj;</span><br><span class="line"><span class="comment">// 带有括号的表达式</span></span><br><span class="line"><span class="keyword">decltype</span>(obj.num) a = <span class="number">0</span>;<span class="comment">// 规则一 a: int</span></span><br><span class="line"><span class="keyword">decltype</span>((obj.num)) b = a;<span class="comment">// 规则三 b: const int&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加法表达式</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;<span class="comment">// c: int</span></span><br><span class="line"><span class="keyword">decltype</span>(n = n + m) d = n;<span class="comment">// d: int&amp;  n+m保存到n中，此时n是一个左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-decltype的应用"><a href="#2-2-decltype的应用" class="headerlink" title="2.2 decltype的应用"></a>2.2 decltype的应用</h2><p> decltype的应用多出现在泛型编程中，比如我们编写一个类模板，在里边添加遍历容器的函数，操作如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (m_it = t.<span class="built_in">begin</span>(); m_it != t.<span class="built_in">end</span>(); m_it++) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;valu: &quot;</span> &lt;&lt; *m_it &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it; <span class="comment">// 这里不能确定迭代器类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;ls1&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line"><span class="type">const</span> list&lt;<span class="type">int</span>&gt; ls2&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span> &#125;;</span><br><span class="line">Container&lt;list&lt;<span class="type">int</span>&gt;&gt;c1;</span><br><span class="line">Container&lt;<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&gt;c2;</span><br><span class="line">c<span class="number">1.</span><span class="built_in">print</span>(ls1);</span><br><span class="line">c<span class="number">2.</span><span class="built_in">print</span>(ls2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/16107.html"/>
      <url>/posts/16107.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>原始字面量</title>
      <link href="/posts/3774.html"/>
      <url>/posts/3774.html</url>
      
        <content type="html"><![CDATA[<p>在C++11中添加了<strong>定义原始字符串的字面量</strong>，定义方式为<code>R &quot;xxx(原始字符串)xxx&quot;</code>，其中（）两边的字符串可以省略。原始字面量R<strong>可以直接表示字符串的实际含义，而不需要而外的转义字符进行转义</strong></p><p>例如，当我们要打印一个路径时，由于路径字符串中常常包含一些特殊字符，传统方法通常需要使用转义字符’&#39;来处理。但如果使用原始字符串字面量，就可以轻松解决这个问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;D:\hello\world\test.text&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str: &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    string str1 = <span class="string">&quot;D:\\hello\\world\\test.text&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1: &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">    string str2 = <span class="string">R&quot;hello(D:\hello\world\test.text)world&quot;;</span></span><br><span class="line"><span class="string">    cout &lt;&lt; &quot;str2: &quot; &lt;&lt; str2 &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:helloworld    est.text</span><br><span class="line">D:\hello\world\test.text</span><br><span class="line">D:\hello\world\test.text</span><br></pre></td></tr></table></figure><ul><li>第一条语句中，\h和\w转义失败，对应地字符串会原样输出</li><li>第二条语句中，第一个反斜杠是对第二个反斜杠的转义，最终才能得到一个没有特殊含义的普通字符\</li><li>第三条语句中，使用了原始字面量R()中的内容来描述路径的原始字符串，因此无需做任何处理</li></ul><p>在C++11之前如果一个字符串分别写到了不同的行里边，需要加连接符，这种方式不仅繁琐，还破坏了表达式的原始含义，如果使用原始字面量就变得简单很多，很强直观，可读性强。我们再用过一个输出HTML标签的例子体会一下原始字面量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">R&quot;(&lt;html&gt;</span></span><br><span class="line"><span class="string">                    &lt;head&gt;</span></span><br><span class="line"><span class="string">                        &lt;title&gt;</span></span><br><span class="line"><span class="string">                            海贼王</span></span><br><span class="line"><span class="string">                        &lt;/title&gt;</span></span><br><span class="line"><span class="string">                    &lt;/head&gt;</span></span><br><span class="line"><span class="string">                    &lt;body&gt;</span></span><br><span class="line"><span class="string">                        &lt;p&gt;</span></span><br><span class="line"><span class="string">                            我是要成为海贼王的男人!!!</span></span><br><span class="line"><span class="string">                        &lt;/p&gt;</span></span><br><span class="line"><span class="string">                    &lt;/body&gt;</span></span><br><span class="line"><span class="string">                 &lt;/html&gt;)&quot;</span>;</span><br><span class="line">    cout &lt;&lt;  str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">str: &lt;html&gt;</span><br><span class="line">        &lt;head&gt;</span><br><span class="line">            &lt;title&gt;</span><br><span class="line">                海贼王</span><br><span class="line">            &lt;/title&gt;</span><br><span class="line">        &lt;/head&gt;</span><br><span class="line">        &lt;body&gt;</span><br><span class="line">            &lt;p&gt;</span><br><span class="line">                我是要成为海贼王的男人!!!</span><br><span class="line">            &lt;/p&gt;</span><br><span class="line">        &lt;/body&gt;</span><br><span class="line">    &lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>最后强调一个细节：<strong>在R “xxx()xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，并且</strong>加的字符串必须在括号两边同时出现(两边出现的字符一模一样)</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str2 = <span class="string">R&quot;hello(D:\hello\world\test.text)hello&quot;</span>;      <span class="comment">//正确</span></span><br><span class="line">string str3 = <span class="string">R&quot;hello(D:\hello\world\test.text)world&quot;;      //错误</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++11 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录算法训练营第四天</title>
      <link href="/posts/23629.html"/>
      <url>/posts/23629.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-24-两两交换链表中的节点"><a href="#LeetCode-24-两两交换链表中的节点" class="headerlink" title="LeetCode 24 两两交换链表中的节点"></a>LeetCode 24 两两交换链表中的节点</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/swap-nodes-in-pairs">24.两两交换链表中的节点</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题就是正常的<strong>模拟</strong>，建议使用虚拟头结点。做题分析的时候一定要画图，因为这道题目涉及多个指针操作，相互指向。</p><ol><li>初始时，我们让cur指向虚拟头结点，然后进行如下步骤就可以交换相邻两个节点。在交换过程中，cur指向当前节点，cur-&gt;next指向当前需要交换的第一个节点（temp），而temp-&gt;next则是第二个节点（p）。通过调整指针，完成交换。</li></ol><img src="https://img.imgdd.com/c5182e60-ee9a-4bec-986c-b4074a0689f5.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><ol start="2"><li><p>接下来我们要更新cur的值，每次交换完成后，cur要指向交换后的第二个节点，即原来的第一个节点。这样就可以继续交换接下来的节点。</p></li><li><p>最后，就是要确定循环停止的终止条件。终止条件需要确保链表中还有足够的节点进行交换。当cur-&gt;next &#x3D;&#x3D; nullptr时，意味着已经没有更多的节点；当cur-&gt;next-&gt;next &#x3D;&#x3D; nullptr时，意味着剩下的节点不足两节点进行交换。</p></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* cur = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* temp = cur-&gt;next;</span><br><span class="line">            ListNode* p = temp-&gt;next;</span><br><span class="line">            <span class="comment">//开始交换</span></span><br><span class="line">            cur-&gt;next = temp-&gt;next;</span><br><span class="line">            temp-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = temp;</span><br><span class="line">            cur = temp;         <span class="comment">//cur = cur-&gt;next-&gt;next;</span></span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-19-删除链表的倒数第N个节点"><a href="#LeetCode-19-删除链表的倒数第N个节点" class="headerlink" title="LeetCode 19 删除链表的倒数第N个节点"></a>LeetCode 19 删除链表的倒数第N个节点</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list">19.删除链表的倒数第N个节点</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ol><li><p>删除链表倒数第N个节点，可以将该问题转化成如何找到链表倒数第N个节点</p></li><li><p>我们可以通过快慢指针的方法找到链表倒数第N个节点。先让fast指针向前移动n+1步，使得fast和slow之间相隔n+1个节点，为什么是n+1呢？因为这样同时移动的时候slow指针才能指向待删除节点的前一个节点（方便进行删除操作）</p></li><li><p>fast指针和slow指针同时移动，直到fast指向末尾，然后删除slow指向的下一个节点</p></li></ol><img src="https://img.imgdd.com/9bb3bfa4-1fe0-4e0e-8eca-57b0f9175820.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* slow = dummyHead;</span><br><span class="line">        ListNode* fast = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(n-- &amp;&amp; fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* p = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = p-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-面试题-02-07-链表相交"><a href="#LeetCode-面试题-02-07-链表相交" class="headerlink" title="LeetCode 面试题 02.07 链表相交"></a>LeetCode 面试题 02.07 链表相交</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci">面试题 02.07.链表相交</a></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><ol><li><p>分别遍历链表A和链表B，统计它们的长度lenA和lenB,目的是为了后续对齐两个链表的遍历起点。</p></li><li><p>对齐两个链表的遍历起点。假设 lenA &gt; lenB，让指向链表A的指针curA先移动lenA-lenB 步。这样，两个链表末尾剩余节点数相等，此时就能同步遍历比较</p></li></ol><img src="https://img.imgdd.com/cf81ee82-d505-4d1a-8ae3-4eba1f74327a.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><ol start="3"><li>从对齐后的位置开始，同时移动curA和curB，逐个比较它们指向的节点是否相同。如果 curA&#x3D;&#x3D;curB，说明找到了相交节点，直接返回该节点。</li></ol><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* curA = headA;</span><br><span class="line">        ListNode* curB = headB;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>, lenB = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//计算A链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            lenA++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算B链表长度</span></span><br><span class="line">        <span class="keyword">while</span>(curB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">            lenB++;</span><br><span class="line">        &#125;</span><br><span class="line">        curA = headA;</span><br><span class="line">        curB = headB;</span><br><span class="line">        <span class="comment">//统一使curA指向最长的链表</span></span><br><span class="line">        <span class="keyword">if</span> (lenB &gt; lenA) &#123;</span><br><span class="line">            <span class="built_in">swap</span> (lenA, lenB);</span><br><span class="line">            <span class="built_in">swap</span> (curA, curB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> gapLen = lenA - lenB;</span><br><span class="line">        <span class="keyword">while</span>(gapLen--) &#123;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(curA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(curA == curB) &#123;</span><br><span class="line">                <span class="keyword">return</span> curA;</span><br><span class="line">            &#125;</span><br><span class="line">            curA = curA-&gt;next;</span><br><span class="line">            curB = curB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-142-环形链表"><a href="#LeetCode-142-环形链表" class="headerlink" title="LeetCode 142 环形链表"></a>LeetCode 142 环形链表</h2><p><strong>题目连接:</strong> <a href="">142.环形链表</a></p><h3 id="判断环"><a href="#判断环" class="headerlink" title="判断环"></a>判断环</h3><p>通过快慢指针法，分别fast指针和slow指针，从头结点开始触发，<strong>fast指针每次移动两个节点，slow指针每次移动一个节点</strong>，如果fast和slow指针在途中相遇，说明这个链表有环。<strong>有环的话为什么一定在环内相遇呢？</strong></p><p>这是因为，fast指针一定会先于slow指针先进入环，如果链表存在环，此时该问题就会变成高中物理的追击问题</p><h3 id="寻找环的入口"><a href="#寻找环的入口" class="headerlink" title="寻找环的入口"></a>寻找环的入口</h3><p><strong>如果有环，那么我们如何找到环的入口？</strong> 假设从头结点到环的入口的距离是x，入口到相遇点的距离是y，相遇点再到环形入口的距离是z</p><img src="https://img.imgdd.com/337c4450-40bf-40c1-9c77-bb01d092a737.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>相遇时，slow指针走过了<code>x+y</code>的距离，fast指针走过了<code>x+y+n(y+z)</code>的距离，n表示fast指针在环内走了n圈才和slow指针相遇。我们通过<code>t=x/v</code>将两者联系起来，即<code>(x+y)/1=[x+y+n(y+z)]/2</code>,花间可得<code>x=(n-1)(y+z)+z</code></p><img src="https://img.imgdd.com/eba2a7f3-b264-4106-8459-7f41f0938820.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><p>注意最后的式子n一定大于等于1，因为fast指针<strong>至少</strong>要多走一圈才能追上并和slow相遇。当<code>n=1</code>时，<code>x=z</code>表明fast指针在环里走了一圈之后就和slow指针相遇。这就意味着，<strong>从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点，那么当这两个指针相遇的时候就是环形入口的节点。</strong></p><p>**如果n大于1会是什么情况？**我们假设令<code>n=3</code>，代入式子可得<code>x=2(y+z)+z</code>。可以发现<code>2(y+z)</code>就表示两圈圆，所以可得出结论，fast指针在环里走了两圈之后和slow指针在入口相遇。</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="comment">//保证链表是个环</span></span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="comment">//快慢指针相遇，此时同时从相遇点开始同时进行移动</span></span><br><span class="line">            <span class="keyword">if</span>(fast == slow) &#123;</span><br><span class="line">                ListNode* index1 = head;</span><br><span class="line">                ListNode* index2 = fast;</span><br><span class="line">                <span class="keyword">while</span>(index1 != index2) &#123;</span><br><span class="line">                    index1 = index1-&gt;next;</span><br><span class="line">                    index2 = index2-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> index2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码随想录算法训练营第三天</title>
      <link href="/posts/43916.html"/>
      <url>/posts/43916.html</url>
      
        <content type="html"><![CDATA[<h2 id="链表基础"><a href="#链表基础" class="headerlink" title="链表基础"></a>链表基础</h2><p>链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向nullptr，链表的入口节点称为链表的头结点（head）</p><img src="https://img.imgdd.com/7242fb8d-3d84-424f-bf77-c7228f6cf73b.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;" /><h2 id="链表的类型"><a href="#链表的类型" class="headerlink" title="链表的类型"></a>链表的类型</h2><ol><li>单链表（Singly Linked List）：每个节点只包含一个指针，指向下一个节点。</li><li>双链表（Doubly Linked List）：每个节点包含两个指针，一个指向前一个节点，另一个指向下一个节点。</li><li>循环链表（Circular Linked List）：链表的最后一个节点的指针域指向第一个节点，形成一个环。</li></ol><img src="https://img.imgdd.com/7687a501-6da3-4b2a-a2f5-22322da64105.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;"/><h2 id="LeetCode-203-移除链表元素"><a href="#LeetCode-203-移除链表元素" class="headerlink" title="LeetCode 203 移除链表元素"></a>LeetCode 203 移除链表元素</h2><h3 id="虚拟头结点"><a href="#虚拟头结点" class="headerlink" title="虚拟头结点"></a>虚拟头结点</h3><p>虚拟头结点是一个在链表头部添加的额外节点，它不存储任何数据，只起到辅助作用。虚拟头结点的引入可以使得链表的操作得到统一。</p><ul><li>无论是在链表的开头、中间还是末尾插入或删除节点，我们都可以使用相同的逻辑进行操作</li><li>虚拟头节点还能够解决空链表的情况。如果链表为空且没有虚拟头节点，我们需要对空链表和非空链表进行不同的处理。然而，通过添加虚拟头节点，链表的头部始终存在，我们可以统一对链表进行处理，无论链表是否为空。</li></ul><p>可能大家光是看文字可能没有什么感觉，但是到了做题的时候，你就会发现虚拟头节点会给你带来很多便利</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* p = dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;next-&gt;val == val) &#123;</span><br><span class="line">                ListNode* q = p-&gt;next;</span><br><span class="line">                p-&gt;next = q-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> q;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        head = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-707-设计链表"><a href="#LeetCode-707-设计链表" class="headerlink" title="LeetCode 707 设计链表"></a>LeetCode 707 设计链表</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/design-linked-list">707.设计链表</a></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line">MyLinkedList* obj = <span class="keyword">new</span> <span class="built_in">MyLinkedList</span>();</span><br><span class="line"><span class="type">int</span> param_1 = obj-&gt;<span class="built_in">get</span>(index);</span><br><span class="line">obj-&gt;<span class="built_in">addAtHead</span>(val);</span><br><span class="line">obj-&gt;<span class="built_in">addAtTail</span>(val);</span><br><span class="line">obj-&gt;<span class="built_in">addAtIndex</span>(index,val);</span><br><span class="line">obj-&gt;<span class="built_in">deleteAtIndex</span>(index);</span><br></pre></td></tr></table></figure><ul><li>第一句代码通过new创建了一个MyLinkedList类型的对象obj，然后对obj执行增删改查操作。因此，在MyLinkedList的方法中，必然会创建一个新的链表。</li><li>我们还需要一个变量记录链表内的元素个数。因为在我们进行增、删、改、查之前要对输入的下标的合法性进行检查，所以有必要记录链表内的元素个数</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkNode* next;</span><br><span class="line">        <span class="built_in">LinkNode</span>():<span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">        <span class="built_in">LinkNode</span>(<span class="type">int</span> x):<span class="built_in">val</span>(x),<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        _dummyHead = <span class="keyword">new</span> <span class="built_in">LinkNode</span>();</span><br><span class="line">        _size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断下标是否合法</span></span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* cur = _dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* curNode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        curNode-&gt;next = _dummyHead-&gt;next;</span><br><span class="line">        _dummyHead-&gt;next  = curNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* curNode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        LinkNode* p = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = curNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkNode* curNode = <span class="keyword">new</span> <span class="built_in">LinkNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; _size) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = curNode;</span><br><span class="line">        _size++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; _size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* p = _dummyHead;</span><br><span class="line">        <span class="keyword">while</span>(index--) &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkNode* temp = p-&gt;next;</span><br><span class="line">        p-&gt;next = temp-&gt;next;</span><br><span class="line">        _size--;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LinkNode* _dummyHead;</span><br><span class="line">    <span class="type">int</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-206-反转链表"><a href="#LeetCode-206-反转链表" class="headerlink" title="LeetCode 206 反转链表"></a>LeetCode 206 反转链表</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/design-linked-list">206.反转链表</a></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>我们一下就能想到，如果我们再开辟一块内存空间，然后重新遍历一遍链表不就能实现链表元素的反转吗？但是这大大浪费了内存空间，也违背了我们刷题学习算法的初衷。</p><p>其实，我们直接把链表指针进行反转，就能实现反转链表，那么如何进行反转呢？</p><p>首先，我们定义一个p指针指向头节点，然后定义一个q指针，初始化为nullptr。我们只需要令p-&gt;next&#x3D;q，q&#x3D;p就能实现翻转操作，那么此时如何令p指针向前走呢？</p><p>这是，我们就需要提前定义一个temp指针保存p指针的下一个节点，这样，p指针就能找到它的下一个节点了。</p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* p = head;</span><br><span class="line">        ListNode* q = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">//标记p的下一个节点</span></span><br><span class="line">            ListNode* temp = p-&gt;next;       </span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">            q = p;</span><br><span class="line">            p = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        head = q;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组part02</title>
      <link href="/posts/29031.html"/>
      <url>/posts/29031.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-209-长度最小的子数组"><a href="#LeetCode-209-长度最小的子数组" class="headerlink" title="LeetCode 209 长度最小的子数组"></a>LeetCode 209 长度最小的子数组</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/minimum-size-subarray-sum">209.长度最小的子数组</a></p><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>定义left和right两个指针，两指针同向移动且不会回头，指针需要通过判断区间[left,right]是否合法来决定指针的走向，收缩的本质即去掉不再需要的元素（也就是先固定右指针，判断条件是否可以收缩左指针范围）。因为在指针移动过程中，区间[left,right]很像一个滑动的窗口，故称为滑动窗口算法。滑动窗口的典型应用场景就是找数组中的子数组或字符串中的字串是否符合某一条件</p><p><strong>如果加入滑动窗口中有负数怎么办？</strong></p><p>如果滑动窗口中有负数，就无法直接使用滑动窗口算法，因为此时收缩窗口不一定使区间和减小，扩张窗口也不一定使区间和增大，导致窗口的调整变得不可控。若要覆盖所有情况，只能让左指针left逐个回退到right，这就退化成暴力搜索了。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题中要想实现滑动窗口，我们就要明确如下三点：</p><ul><li>窗口内表示的是什么？</li><li>如何移动窗口起始位置</li><li>如何移动窗口终止位置</li></ul><p>对于第一点，我们可以从题目中明确知道区间内表示的是元素的总和；对于第二点，如果当前区间内的总和小于target，left指针固定，right指针一直向前移动；对于第三点，如果当前区间内的总和大于target，right指针固定，left指针向前移动。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = <span class="number">0</span>, sum = <span class="number">0</span>, subLen = <span class="number">0</span>, result = INT32_MAX;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sum += nums[right]; </span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123;</span><br><span class="line">                subLen = right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(subLen &lt; result) &#123;</span><br><span class="line">                    result = subLen;</span><br><span class="line">                &#125;</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result &lt; subLen ? result : subLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-59-螺旋数组II"><a href="#LeetCode-59-螺旋数组II" class="headerlink" title="LeetCode 59 螺旋数组II"></a>LeetCode 59 螺旋数组II</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/spiral-matrix-ii">59.螺旋数组II</a></p><p><strong>思路</strong></p><p>本题并不涉及什么算法，主要考察的是<strong>模拟遍历的过程</strong>，编写代码时要统一边界条件，这要我们写代码时才不会混乱</p><ol><li>首先要明确一点，我们在Day1的文章说过，遍历数组时通常会采用<strong>左闭右闭</strong>或<strong>左闭右开</strong>的形式，这题当然也不例外，假设我们遍历每一条边均采用左闭右开的原则，确保边界条件统一</li></ol><ul><li>填充上行从左到右</li><li>填充右列从上到下</li><li>填充下行从右到左</li><li>填充左列从下到上</li></ul> <img src="https://img.imgdd.com/7eb60706-f824-4bb5-967b-fd4e412bd3c9.jpg" style="width: 70%; height: 70%; object-fit: cover;display: block; margin: 0 auto;"/><ol start="2"><li><p>其次，我们按照<strong>由外到内</strong>的遍历顺序，每次向内侧遍历时，循环的终止条件会逐渐减少。因此，我们需要设置一个offset变量，通过n-offset来确定终止条件。</p></li><li><p>最后是循环次数。从上面的图可以看出，当n&#x3D;3时，遍历1次；当n&#x3D;4时，遍历2次。因此，可以得出结论，遍历次数为n&#x2F;2。当n为奇数时，中心位置需要单独处理。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">ret</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n,<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> loop = n/<span class="number">2</span>;         <span class="comment">//控制循环次数</span></span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;         <span class="comment">//n-offset 控制每条边遍历次数</span></span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(loop--) &#123;</span><br><span class="line">            <span class="type">int</span> i = startx;</span><br><span class="line">            <span class="type">int</span> j = starty;</span><br><span class="line">            <span class="comment">//遍历上行</span></span><br><span class="line">            <span class="keyword">for</span>(;j &lt; n - offset;j++) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历右列</span></span><br><span class="line">            <span class="keyword">for</span>(;i &lt; n - offset;i++) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历下行</span></span><br><span class="line">            <span class="keyword">for</span>(;j &gt; startx;j--) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历左列</span></span><br><span class="line">            <span class="keyword">for</span>(;i &gt; starty;i--) &#123;</span><br><span class="line">                ret[i][j] = count++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果n是奇数，中间位置单独处理</span></span><br><span class="line">        <span class="keyword">if</span>(n%<span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            ret[startx][starty] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组part01</title>
      <link href="/posts/24744.html"/>
      <url>/posts/24744.html</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-704-二分查找"><a href="#LeetCode-704-二分查找" class="headerlink" title="LeetCode 704 二分查找"></a>LeetCode 704 二分查找</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/binary-search">704.二分查找</a></p><p>二分查找的前提是<strong>数组为有序数组</strong>，同时强调<strong>数组中没有重复元素</strong>，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。这些都是二分法的前提条件。</p><p>二分法有两种定义方式：</p><ul><li><strong>左闭右闭 即 [left,right]</strong></li><li><strong>左闭右开 即 [left,right]</strong></li></ul><h3 id="二分查找第一种写法"><a href="#二分查找第一种写法" class="headerlink" title="二分查找第一种写法"></a>二分查找第一种写法</h3><ul><li>因为左闭右闭的特性，因此，当 left&#x3D;&#x3D;right 也是成立的，所以循环条件使用 left&lt;&#x3D;right</li><li>其次，当if (nums[middle] &gt; target) 时，right 要赋值为 middle-1，因为左闭右闭特性，right&#x3D;middle-1时，区间依旧合法</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//左闭右闭区间，此处的right是nums.size()-1</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//注意此处是lef&lt;=right</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二分查找第二种写法"><a href="#二分查找第二种写法" class="headerlink" title="二分查找第二种写法"></a>二分查找第二种写法</h3><ul><li>因为左闭右开的特性，因此，当 left&#x3D;&#x3D;right 是没有意义的，所以循环条件使用 left&lt;right</li><li>其次，当if (nums[middle] &gt; target) 时，right 要赋值为 middle，因为左闭右开特性，right&#x3D;middle时，区间依旧合法；如果right&#x3D;middle-1，那么middle-1这个下标位置就被忽略。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//左闭右开区间</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> middle = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) &#123;</span><br><span class="line">                right = middle;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[middle] &lt; target) &#123;</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> middle;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-27-移动元素"><a href="#LeetCode-27-移动元素" class="headerlink" title="LeetCode 27 移动元素"></a>LeetCode 27 移动元素</h2><p><strong>题目连接:</strong> <a href="https://leetcode.cn/problems/remove-element">27.移动元素</a></p><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p>快慢指针是指两个指针<strong>从同一侧开始遍历数组</strong>，将这两个指针分别定义为<strong>快指针（fast）和慢指针（slow）</strong>，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如快指针（fast）每次增长两个，慢指针（slow）每次增长一个。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>通过快指针判断当前值是否等于val来处理遍历逻辑。快指针(fast)、慢指针(slow)均从起点出发，slow标记我们应该放置非目标元素的位置，而fast则遍历整个数组来寻找非目标元素</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt;= nums.<span class="built_in">size</span>()<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val &amp;&amp; fast == slow) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[fast] == val) &#123;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">                slow++;</span><br><span class="line">                fast++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="LeetCode-977-有序数组的平方"><a href="#LeetCode-977-有序数组的平方" class="headerlink" title="LeetCode 977 有序数组的平方"></a>LeetCode 977 有序数组的平方</h2><p><strong>题目链接:</strong> <a href="https://leetcode.cn/problems/squares-of-a-sorted-array">977.移动数组的平方</a></p><h3 id="首尾指针"><a href="#首尾指针" class="headerlink" title="首尾指针"></a>首尾指针</h3><p>头指针（head）和尾指针（tail）分别从数组首部和尾部向中间进行遍历，快速排序和前面的二分查找都是首位指针的具体应用场景</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>因为数组的非递减顺序特性，这是很重要的一点，正是有了这个特性，我们才能通过首尾指针从数组两端向中间遍历，然后每次比较两端元素的平方，选择较大的平方值填入结果数组的末尾</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">result</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>, index = result.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">pow</span>(nums[left],<span class="number">2</span>) &lt; <span class="built_in">pow</span>(nums[right],<span class="number">2</span>)) &#123;</span><br><span class="line">                result[index] = <span class="built_in">pow</span>(nums[right],<span class="number">2</span>);</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result[index] = <span class="built_in">pow</span>(nums[left],<span class="number">2</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
